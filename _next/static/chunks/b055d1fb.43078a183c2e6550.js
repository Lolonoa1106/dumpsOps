"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [950],
  {
    891: (e, t, r) => {
      let i, s, n, a, o, l;
      r.r(t),
        r.d(t, {
          ACESFilmicToneMapping: () => u.FV,
          AONode: () => aE,
          AddEquation: () => u.gO9,
          AddOperation: () => u.XrR,
          AdditiveAnimationBlendMode: () => u.DAe,
          AdditiveBlending: () => u.EZo,
          AgXToneMapping: () => u.LAk,
          AlphaFormat: () => u.wrO,
          AlwaysCompare: () => u.FFZ,
          AlwaysDepth: () => u.lGu,
          AlwaysStencilFunc: () => u.sKt,
          AmbientLight: () => u.$p8,
          AmbientLightNode: () => gO,
          AnalyticLightNode: () => ps,
          AnimationAction: () => u.pPE,
          AnimationClip: () => u.tz3,
          AnimationLoader: () => u.kEx,
          AnimationMixer: () => u.Iw4,
          AnimationObjectGroup: () => u.P5j,
          AnimationUtils: () => u.AKb,
          ArcCurve: () => u.ibB,
          ArrayCamera: () => u.nZQ,
          ArrayElementNode: () => O,
          ArrayNode: () => e3,
          ArrowHelper: () => u.E0M,
          AssignNode: () => tI,
          AttachedBindMode: () => u.BER,
          AttributeNode: () => iK,
          Audio: () => u.fP5,
          AudioAnalyser: () => u.CwR,
          AudioContext: () => u.UtX,
          AudioListener: () => u.Pf$,
          AudioLoader: () => u.Am1,
          AxesHelper: () => u.IzY,
          BackSide: () => u.hsX,
          BasicDepthPacking: () => u.Rkk,
          BasicEnvironmentNode: () => oR,
          BasicShadowMap: () => u.bTm,
          BatchNode: () => ag,
          BatchedMesh: () => u.$Ed,
          Bone: () => u.$Kf,
          BooleanKeyframeTrack: () => u.YOZ,
          Box2: () => u.UtB,
          Box3: () => u.NRn,
          Box3Helper: () => u.BND,
          BoxGeometry: () => u.iNn,
          BoxHelper: () => u.IWo,
          BufferAttribute: () => u.THS,
          BufferAttributeNode: () => iB,
          BufferGeometry: () => u.LoY,
          BufferGeometryLoader: () => u.SUR,
          BufferNode: () => i5,
          BumpMapNode: () => nS,
          BundleGroup: () => fY,
          BypassNode: () => iG,
          ByteType: () => u.tJf,
          Cache: () => u.l2R,
          CacheNode: () => iV,
          Camera: () => u.i7d,
          CameraHelper: () => u.WTh,
          CanvasTexture: () => u.GOR,
          CapsuleGeometry: () => u.qU7,
          CatmullRomCurve3: () => u.B6O,
          CineonToneMapping: () => u.nNL,
          CircleGeometry: () => u.tcD,
          ClampToEdgeWrapping: () => u.ghU,
          ClippingGroup: () => f4,
          Clock: () => u.zD7,
          CodeNode: () => hJ,
          Color: () => u.Q1f,
          ColorKeyframeTrack: () => u.T6I,
          ColorManagement: () => u.ppV,
          ColorSpaceNode: () => ix,
          CompressedArrayTexture: () => u.iOZ,
          CompressedCubeTexture: () => u.c5h,
          CompressedTexture: () => u.FvD,
          CompressedTextureLoader: () => u.YRT,
          ComputeNode: () => iL,
          ConeGeometry: () => u.qFE,
          ConstNode: () => Q,
          ConstantAlphaFactor: () => u.e0p,
          ConstantColorFactor: () => u.RrE,
          ContextNode: () => it,
          Controls: () => u.H2z,
          ConvertNode: () => G,
          CubeCamera: () => u.F1T,
          CubeReflectionMapping: () => u.hy7,
          CubeRefractionMapping: () => u.xFO,
          CubeTexture: () => u.b4q,
          CubeTextureLoader: () => u.ScU,
          CubeTextureNode: () => s5,
          CubeUVReflectionMapping: () => u.Om,
          CubicBezierCurve: () => u.Z0B,
          CubicBezierCurve3: () => u.s0K,
          CubicInterpolant: () => u.Pdi,
          CullFaceBack: () => u.Vb5,
          CullFaceFront: () => u.Jnc,
          CullFaceFrontBack: () => u.ywQ,
          CullFaceNone: () => u.WNZ,
          Curve: () => u.Ipv,
          CurvePath: () => u.jGm,
          CustomBlending: () => u.bCz,
          CustomToneMapping: () => u.g7M,
          CylinderGeometry: () => u.Ho_,
          Cylindrical: () => u.hjs,
          Data3DTexture: () => u.dYF,
          DataArrayTexture: () => u.rFo,
          DataTexture: () => u.GYF,
          DataTextureLoader: () => u.BRH,
          DataUtils: () => u.GxU,
          DecrementStencilOp: () => u.ROr,
          DecrementWrapStencilOp: () => u.fJr,
          DefaultLoadingManager: () => u.h_9,
          DepthFormat: () => u.zdS,
          DepthStencilFormat: () => u.dcC,
          DepthTexture: () => u.VCu,
          DetachedBindMode: () => u.Fvi,
          DirectionalLight: () => u.ZyN,
          DirectionalLightHelper: () => u.PFK,
          DirectionalLightNode: () => gF,
          DiscreteInterpolant: () => u.Yhb,
          DodecahedronGeometry: () => u.nEu,
          DoubleSide: () => u.$EB,
          DstAlphaFactor: () => u.hdd,
          DstColorFactor: () => u.wn6,
          DynamicCopyUsage: () => u.MOq,
          DynamicDrawUsage: () => u.Vnu,
          DynamicReadUsage: () => u.hIf,
          EdgesGeometry: () => u.TDQ,
          EllipseCurve: () => u.S20,
          EnvironmentNode: () => us,
          EqualCompare: () => u.kO0,
          EqualDepth: () => u.U3G,
          EqualStencilFunc: () => u.jsO,
          EquirectUVNode: () => oy,
          EquirectangularReflectionMapping: () => u.wfO,
          EquirectangularRefractionMapping: () => u.uV5,
          Euler: () => u.O9p,
          EventDispatcher: () => u.Qev,
          ExpressionNode: () => iH,
          ExtrudeGeometry: () => u.QCA,
          FileLoader: () => u.Y9S,
          Float16BufferAttribute: () => u.Oax,
          Float32BufferAttribute: () => u.qtW,
          FloatType: () => u.RQf,
          Fog: () => u.jUj,
          FogExp2: () => u.cRK,
          FramebufferTexture: () => u.Pem,
          FrontFacingNode: () => sV,
          FrontSide: () => u.hB5,
          Frustum: () => u.PPD,
          FunctionCallNode: () => tL,
          FunctionNode: () => h1,
          FunctionOverloadingNode: () => dN,
          GLBufferAttribute: () => u.oh6,
          GLSL1: () => u.Wyr,
          GLSL3: () => u.Wdf,
          GLSLNodeParser: () => gQ,
          GreaterCompare: () => u.eoi,
          GreaterDepth: () => u.K52,
          GreaterEqualCompare: () => u.gWB,
          GreaterEqualDepth: () => u.Gwm,
          GreaterEqualStencilFunc: () => u.TMh,
          GreaterStencilFunc: () => u.RcT,
          GridHelper: () => u.fTw,
          Group: () => u.YJl,
          HalfFloatType: () => u.ix0,
          HemisphereLight: () => u.dth,
          HemisphereLightHelper: () => u.R1W,
          HemisphereLightNode: () => gG,
          IESSpotLight: () => fX,
          IESSpotLightNode: () => gV,
          IcosahedronGeometry: () => u.WBB,
          ImageBitmapLoader: () => u.Kzg,
          ImageLoader: () => u.$NF,
          ImageUtils: () => u.HgN,
          IncrementStencilOp: () => u.HLH,
          IncrementWrapStencilOp: () => u.Ru$,
          IndexNode: () => ai,
          IndirectStorageBufferAttribute: () => f0,
          InstanceNode: () => ad,
          InstancedBufferAttribute: () => u.uWO,
          InstancedBufferGeometry: () => u.CmU,
          InstancedInterleavedBuffer: () => u.LuO,
          InstancedMesh: () => u.ZLX,
          InstancedMeshNode: () => ac,
          Int16BufferAttribute: () => u.Hrb,
          Int32BufferAttribute: () => u.vmz,
          Int8BufferAttribute: () => u.wvS,
          IntType: () => u.Yuy,
          InterleavedBuffer: () => u.eB$,
          InterleavedBufferAttribute: () => u.eHs,
          Interpolant: () => u.lGw,
          InterpolateDiscrete: () => u.ljd,
          InterpolateLinear: () => u.PJ3,
          InterpolateSmooth: () => u.EQC,
          InvertStencilOp: () => u.oVO,
          IrradianceNode: () => aB,
          JoinNode: () => z,
          KeepStencilOp: () => u.VVr,
          KeyframeTrack: () => u.UJ6,
          LOD: () => u.UpK,
          LatheGeometry: () => u.nzx,
          Layers: () => u.zgK,
          LessCompare: () => u.vim,
          LessDepth: () => u.brA,
          LessEqualCompare: () => u.TiK,
          LessEqualDepth: () => u.xSv,
          LessEqualStencilFunc: () => u.CR7,
          LessStencilFunc: () => u.kYr,
          Light: () => u.veJ,
          LightProbe: () => u.FZo,
          LightProbeNode: () => gk,
          Lighting: () => g9,
          LightingContextNode: () => aw,
          LightingModel: () => oC,
          LightingNode: () => aC,
          LightsNode: () => cF,
          Line: () => u.N1A,
          Line2NodeMaterial: () => op,
          Line3: () => u.cZY,
          LineBasicMaterial: () => u.mrM,
          LineBasicNodeMaterial: () => oa,
          LineCurve: () => u.GZZ,
          LineCurve3: () => u.VnP,
          LineDashedMaterial: () => u.Fvt,
          LineDashedNodeMaterial: () => ol,
          LineLoop: () => u.FCc,
          LineSegments: () => u.DXC,
          LinearFilter: () => u.k6q,
          LinearInterpolant: () => u.ezk,
          LinearMipMapLinearFilter: () => u.NZq,
          LinearMipMapNearestFilter: () => u.iUH,
          LinearMipmapLinearFilter: () => u.$_I,
          LinearMipmapNearestFilter: () => u.kRr,
          LinearSRGBColorSpace: () => u.Zr2,
          LinearToneMapping: () => u.kyO,
          LinearTransfer: () => u.VxR,
          Loader: () => u.aHM,
          LoaderUtils: () => u.r6x,
          LoadingManager: () => u.KPJ,
          LoopNode: () => ab,
          LoopOnce: () => u.G3T,
          LoopPingPong: () => u.lc7,
          LoopRepeat: () => u.aMy,
          LuminanceAlphaFormat: () => u.CMB,
          LuminanceFormat: () => u.Kzv,
          MOUSE: () => u.kBv,
          MRTNode: () => df,
          MatcapUVNode: () => uy,
          Material: () => u.imn,
          MaterialLoader: () => u.jut,
          MaterialNode: () => nC,
          MaterialReferenceNode: () => nr,
          MathUtils: () => u.cj9,
          Matrix2: () => u.k_V,
          Matrix3: () => u.dwI,
          Matrix4: () => u.kn4,
          MaxEquation: () => u.$ei,
          MaxMipLevelNode: () => i1,
          MemberNode: () => K,
          Mesh: () => u.eaF,
          MeshBasicMaterial: () => u.V9B,
          MeshBasicNodeMaterial: () => oM,
          MeshDepthMaterial: () => u.CSG,
          MeshDistanceMaterial: () => u.aVO,
          MeshLambertMaterial: () => u.G_z,
          MeshLambertNodeMaterial: () => oV,
          MeshMatcapMaterial: () => u.FNr,
          MeshMatcapNodeMaterial: () => uT,
          MeshNormalMaterial: () => u.qBx,
          MeshNormalNodeMaterial: () => of,
          MeshPhongMaterial: () => u.tXL,
          MeshPhongNodeMaterial: () => oG,
          MeshPhysicalMaterial: () => u.uSd,
          MeshPhysicalNodeMaterial: () => ud,
          MeshSSSNodeMaterial: () => uc,
          MeshStandardMaterial: () => u._4j,
          MeshStandardNodeMaterial: () => ul,
          MeshToonMaterial: () => u.Df,
          MeshToonNodeMaterial: () => uf,
          MinEquation: () => u.znC,
          MirroredRepeatWrapping: () => u.kTW,
          MixOperation: () => u.KRh,
          ModelNode: () => sx,
          MorphNode: () => aR,
          MultiplyBlending: () => u.EdD,
          MultiplyOperation: () => u.caT,
          NearestFilter: () => u.hxR,
          NearestMipMapLinearFilter: () => u.a$r,
          NearestMipMapNearestFilter: () => u.$O9,
          NearestMipmapLinearFilter: () => u.Cfg,
          NearestMipmapNearestFilter: () => u.pHI,
          NeutralToneMapping: () => u.aJ8,
          NeverCompare: () => u.amv,
          NeverDepth: () => u.eHc,
          NeverStencilFunc: () => u.HPb,
          NoBlending: () => u.XIg,
          NoColorSpace: () => u.jf0,
          NoToneMapping: () => u.y_p,
          Node: () => V,
          NodeAccess: () => F,
          NodeAttribute: () => gt,
          NodeBuilder: () => gw,
          NodeCache: () => go,
          NodeCode: () => gn,
          NodeFrame: () => gM,
          NodeFunctionInput: () => gB,
          NodeLoader: () => f1,
          NodeMaterial: () => os,
          NodeMaterialLoader: () => f2,
          NodeMaterialObserver: () => h,
          NodeObjectLoader: () => f3,
          NodeShaderStage: () => w,
          NodeType: () => B,
          NodeUniform: () => gr,
          NodeUpdateType: () => M,
          NodeUtils: () => E,
          NodeVar: () => gi,
          NodeVarying: () => gs,
          NormalAnimationBlendMode: () => u.Ke9,
          NormalBlending: () => u.NTi,
          NormalMapNode: () => nT,
          NotEqualCompare: () => u.jzd,
          NotEqualDepth: () => u.bw0,
          NotEqualStencilFunc: () => u.klZ,
          NumberKeyframeTrack: () => u.Hit,
          Object3D: () => u.B69,
          Object3DNode: () => sh,
          ObjectLoader: () => u.XTe,
          ObjectSpaceNormalMap: () => u.vyJ,
          OctahedronGeometry: () => u.Ufg,
          OneFactor: () => u.qad,
          OneMinusConstantAlphaFactor: () => u.ov9,
          OneMinusConstantColorFactor: () => u.$Yl,
          OneMinusDstAlphaFactor: () => u.Nt7,
          OneMinusDstColorFactor: () => u.aEY,
          OneMinusSrcAlphaFactor: () => u.OuU,
          OneMinusSrcColorFactor: () => u.LiQ,
          OrthographicCamera: () => u.qUd,
          OutputStructNode: () => dp,
          PCFShadowMap: () => u.QP0,
          PCFSoftShadowMap: () => u.Wk7,
          PMREMGenerator: () => l4,
          PMREMNode: () => ut,
          ParameterNode: () => dl,
          PassNode: () => hk,
          Path: () => u.wAk,
          PerspectiveCamera: () => u.ubm,
          PhongLightingModel: () => oL,
          PhysicalLightingModel: () => lv,
          Plane: () => u.Zcv,
          PlaneGeometry: () => u.bdM,
          PlaneHelper: () => u.ZM4,
          PointLight: () => u.HiM,
          PointLightHelper: () => u.F1l,
          PointLightNode: () => po,
          PointUVNode: () => ha,
          Points: () => u.ONl,
          PointsMaterial: () => u.BH$,
          PointsNodeMaterial: () => uA,
          PolarGridHelper: () => u.hzE,
          PolyhedronGeometry: () => u.pFK,
          PositionalAudio: () => u.xZx,
          PostProcessing: () => fZ,
          PosterizeNode: () => hL,
          PropertyBinding: () => u.Nwf,
          PropertyMixer: () => u.N2s,
          PropertyNode: () => ti,
          QuadMesh: () => d2,
          QuadraticBezierCurve: () => u.dAo,
          QuadraticBezierCurve3: () => u.CV9,
          Quaternion: () => u.PTz,
          QuaternionKeyframeTrack: () => u.MBL,
          QuaternionLinearInterpolant: () => u.GBG,
          RED_GREEN_RGTC2_Format: () => u.HO_,
          RED_RGTC1_Format: () => u.Kef,
          REVISION: () => u.sPf,
          RGBADepthPacking: () => u.N5j,
          RGBAFormat: () => u.GWd,
          RGBAIntegerFormat: () => u.c90,
          RGBA_ASTC_10x10_Format: () => u.y3Z,
          RGBA_ASTC_10x5_Format: () => u.uB5,
          RGBA_ASTC_10x6_Format: () => u.lyL,
          RGBA_ASTC_10x8_Format: () => u.bC7,
          RGBA_ASTC_12x10_Format: () => u.ojs,
          RGBA_ASTC_12x12_Format: () => u.S$4,
          RGBA_ASTC_4x4_Format: () => u.qa3,
          RGBA_ASTC_5x4_Format: () => u.B_h,
          RGBA_ASTC_5x5_Format: () => u.czI,
          RGBA_ASTC_6x5_Format: () => u.rSH,
          RGBA_ASTC_6x6_Format: () => u.Qrf,
          RGBA_ASTC_8x5_Format: () => u.psI,
          RGBA_ASTC_8x6_Format: () => u.a5J,
          RGBA_ASTC_8x8_Format: () => u._QJ,
          RGBA_BPTC_Format: () => u.Fn,
          RGBA_ETC2_EAC_Format: () => u.KDk,
          RGBA_PVRTC_2BPPV1_Format: () => u.pBf,
          RGBA_PVRTC_4BPPV1_Format: () => u.HXV,
          RGBA_S3TC_DXT1_Format: () => u.Nz6,
          RGBA_S3TC_DXT3_Format: () => u.jR7,
          RGBA_S3TC_DXT5_Format: () => u.BXX,
          RGBDepthPacking: () => u.wTz,
          RGBFormat: () => u.HIg,
          RGBIntegerFormat: () => u.VGF,
          RGB_BPTC_SIGNED_Format: () => u.H23,
          RGB_BPTC_UNSIGNED_Format: () => u.W9U,
          RGB_ETC1_Format: () => u.CVz,
          RGB_ETC2_Format: () => u.Riy,
          RGB_PVRTC_2BPPV1_Format: () => u.kTp,
          RGB_PVRTC_4BPPV1_Format: () => u.k6Q,
          RGB_S3TC_DXT1_Format: () => u.IE4,
          RGDepthPacking: () => u.k8v,
          RGFormat: () => u.paN,
          RGIntegerFormat: () => u.TkQ,
          RTTNode: () => d4,
          RangeNode: () => ca,
          RawShaderMaterial: () => u.D$Q,
          Ray: () => u.RlV,
          Raycaster: () => u.tBo,
          RectAreaLight: () => u.ure,
          RectAreaLightNode: () => gL,
          RedFormat: () => u.VT0,
          RedIntegerFormat: () => u.ZQM,
          ReferenceNode: () => s7,
          ReflectorNode: () => dY,
          ReinhardToneMapping: () => u.Mjd,
          RemapNode: () => iz,
          RenderOutputNode: () => iX,
          RenderTarget: () => u.O0B,
          RenderTarget3D: () => u.XMJ,
          RenderTargetArray: () => u.rrX,
          RendererReferenceNode: () => iA,
          RendererUtils: () => c$,
          RepeatWrapping: () => u.GJx,
          ReplaceStencilOp: () => u.kG0,
          ReverseSubtractEquation: () => u.nST,
          RingGeometry: () => u.rKP,
          RotateNode: () => u_,
          SIGNED_RED_GREEN_RGTC2_Format: () => u.CWW,
          SIGNED_RED_RGTC1_Format: () => u.XG_,
          SRGBColorSpace: () => u.er$,
          SRGBTransfer: () => u.KLL,
          Scene: () => u.Z58,
          SceneNode: () => hd,
          ScreenNode: () => aF,
          ScriptableNode: () => h9,
          ScriptableValueNode: () => h3,
          SetNode: () => H,
          ShaderMaterial: () => u.BKk,
          ShadowBaseNode: () => cU,
          ShadowMaterial: () => u.q2,
          ShadowNode: () => c2,
          ShadowNodeMaterial: () => uw,
          Shape: () => u.ypk,
          ShapeGeometry: () => u.MSw,
          ShapePath: () => u.Ld9,
          ShapeUtils: () => u.xJ6,
          ShortType: () => u.fBL,
          Skeleton: () => u.EAD,
          SkeletonHelper: () => u._xc,
          SkinnedMesh: () => u.I46,
          SkinningNode: () => ay,
          Source: () => u.kLi,
          Sphere: () => u.iyt,
          SphereGeometry: () => u.Gu$,
          Spherical: () => u.YHV,
          SphericalHarmonics3: () => u.xOk,
          SplineCurve: () => u.xfg,
          SplitNode: () => W,
          SpotLight: () => u.nCl,
          SpotLightHelper: () => u.Fpm,
          SpotLightNode: () => gD,
          Sprite: () => u.kxk,
          SpriteMaterial: () => u.RoJ,
          SpriteNodeMaterial: () => uS,
          SpriteSheetUVNode: () => dU,
          SrcAlphaFactor: () => u.ie2,
          SrcAlphaSaturateFactor: () => u.hgQ,
          SrcColorFactor: () => u.f4X,
          StackNode: () => du,
          StaticCopyUsage: () => u.Hrq,
          StaticDrawUsage: () => u.agE,
          StaticReadUsage: () => u.uXQ,
          StereoCamera: () => u.keZ,
          StorageArrayElementNode: () => ht,
          StorageBufferAttribute: () => he,
          StorageBufferNode: () => hi,
          StorageInstancedBufferAttribute: () => d7,
          StorageTexture: () => fJ,
          StorageTextureNode: () => hg,
          StreamCopyUsage: () => u.rOG,
          StreamDrawUsage: () => u.Ktl,
          StreamReadUsage: () => u.uov,
          StringKeyframeTrack: () => u.hZF,
          StructNode: () => dc,
          StructTypeNode: () => dh,
          SubtractEquation: () => u.FXf,
          SubtractiveBlending: () => u.Kwu,
          TOUCH: () => u.wtR,
          TSL: () => p6,
          TangentSpaceNormalMap: () => u.bI3,
          TempNode: () => k,
          TetrahedronGeometry: () => u.Zpd,
          Texture: () => u.gPd,
          Texture3DNode: () => hy,
          TextureLoader: () => u.Tap,
          TextureNode: () => i3,
          TextureSizeNode: () => iJ,
          TextureUtils: () => u.Vwu,
          TimestampQuery: () => u.v9J,
          ToneMappingNode: () => iE,
          ToonOutlinePassNode: () => hz,
          TorusGeometry: () => u.O3Y,
          TorusKnotGeometry: () => u.UPV,
          Triangle: () => u.lMl,
          TriangleFanDrawMode: () => u.rYR,
          TriangleStripDrawMode: () => u.O49,
          TrianglesDrawMode: () => u.RJ4,
          TriplanarTexturesNode: () => dP,
          TubeGeometry: () => u.j6,
          UVMapping: () => u.UTZ,
          Uint16BufferAttribute: () => u.A$4,
          Uint32BufferAttribute: () => u.MW4,
          Uint8BufferAttribute: () => u.baL,
          Uint8ClampedBufferAttribute: () => u.fc6,
          Uniform: () => u.nc$,
          UniformArrayNode: () => i7,
          UniformGroupNode: () => e6,
          UniformNode: () => tt,
          UniformsGroup: () => u.dzP,
          UnsignedByteType: () => u.OUM,
          UnsignedInt248Type: () => u.V3x,
          UnsignedInt5999Type: () => u.Dmk,
          UnsignedIntType: () => u.bkx,
          UnsignedShort4444Type: () => u.Wew,
          UnsignedShort5551Type: () => u.gJ2,
          UnsignedShortType: () => u.cHt,
          UserDataNode: () => hb,
          VSMShadowMap: () => u.RyA,
          VarNode: () => is,
          VaryingNode: () => id,
          Vector2: () => u.I9Y,
          Vector3: () => u.Pq0,
          Vector4: () => u.IUQ,
          VectorKeyframeTrack: () => u.RiT,
          VertexColorNode: () => hn,
          VideoFrameTexture: () => u.SYV,
          VideoTexture: () => u.Nv2,
          ViewportDepthNode: () => aK,
          ViewportDepthTextureNode: () => aX,
          ViewportSharedTextureNode: () => od,
          ViewportTextureNode: () => aW,
          VolumeNodeMaterial: () => uI,
          WebGL3DRenderTarget: () => u.ALV,
          WebGLArrayRenderTarget: () => u.y9J,
          WebGLCoordinateSystem: () => u.TdN,
          WebGLCubeRenderTarget: () => u.o6l,
          WebGLRenderTarget: () => u.nWS,
          WebGPUCoordinateSystem: () => u.i7u,
          WebGPURenderer: () => fK,
          WebXRController: () => u.R3r,
          WireframeGeometry: () => u.XJ7,
          WrapAroundEnding: () => u.dhZ,
          ZeroCurvatureEnding: () => u.rQf,
          ZeroFactor: () => u.ojh,
          ZeroSlopeEnding: () => u.h2z,
          ZeroStencilOp: () => u.kqe,
          createCanvasElement: () => u.lPF,
          defaultBuildStages: () => I,
          defaultShaderStages: () => U,
          shaderStages: () => P,
          vectorComponents: () => L,
        });
      var u = r(43264);
      let d = [
        "alphaMap",
        "alphaTest",
        "anisotropy",
        "anisotropyMap",
        "anisotropyRotation",
        "aoMap",
        "attenuationColor",
        "attenuationDistance",
        "bumpMap",
        "clearcoat",
        "clearcoatMap",
        "clearcoatNormalMap",
        "clearcoatNormalScale",
        "clearcoatRoughness",
        "color",
        "dispersion",
        "displacementMap",
        "emissive",
        "emissiveMap",
        "envMap",
        "gradientMap",
        "ior",
        "iridescence",
        "iridescenceIOR",
        "iridescenceMap",
        "iridescenceThicknessMap",
        "lightMap",
        "map",
        "matcap",
        "metalness",
        "metalnessMap",
        "normalMap",
        "normalScale",
        "opacity",
        "roughness",
        "roughnessMap",
        "sheen",
        "sheenColor",
        "sheenColorMap",
        "sheenRoughnessMap",
        "shininess",
        "specular",
        "specularColor",
        "specularColorMap",
        "specularIntensity",
        "specularIntensityMap",
        "specularMap",
        "thickness",
        "transmission",
        "transmissionMap",
      ];
      class h {
        constructor(e) {
          (this.renderObjects = new WeakMap()),
            (this.hasNode = this.containsNode(e)),
            (this.hasAnimation = !0 === e.object.isSkinnedMesh),
            (this.refreshUniforms = d),
            (this.renderId = 0);
        }
        firstInitialization(e) {
          return (
            !1 === this.renderObjects.has(e) &&
            (this.getRenderObjectData(e), !0)
          );
        }
        getRenderObjectData(e) {
          let t = this.renderObjects.get(e);
          if (void 0 === t) {
            let { geometry: r, material: i, object: s } = e;
            if (
              ((t = {
                material: this.getMaterialData(i),
                geometry: {
                  id: r.id,
                  attributes: this.getAttributesData(r.attributes),
                  indexVersion: r.index ? r.index.version : null,
                  drawRange: {
                    start: r.drawRange.start,
                    count: r.drawRange.count,
                  },
                },
                worldMatrix: s.matrixWorld.clone(),
              }),
              s.center && (t.center = s.center.clone()),
              s.morphTargetInfluences &&
                (t.morphTargetInfluences = s.morphTargetInfluences.slice()),
              null !== e.bundle && (t.version = e.bundle.version),
              t.material.transmission > 0)
            ) {
              let { width: r, height: i } = e.context;
              (t.bufferWidth = r), (t.bufferHeight = i);
            }
            this.renderObjects.set(e, t);
          }
          return t;
        }
        getAttributesData(e) {
          let t = {};
          for (let r in e) {
            let i = e[r];
            t[r] = { version: i.version };
          }
          return t;
        }
        containsNode(e) {
          let t = e.material;
          for (let e in t) if (t[e] && t[e].isNode) return !0;
          return (
            null !== e.renderer.nodes.modelViewMatrix ||
            null !== e.renderer.nodes.modelNormalViewMatrix
          );
        }
        getMaterialData(e) {
          let t = {};
          for (let r of this.refreshUniforms) {
            let i = e[r];
            null != i &&
              ("object" == typeof i && void 0 !== i.clone
                ? !0 === i.isTexture
                  ? (t[r] = { id: i.id, version: i.version })
                  : (t[r] = i.clone())
                : (t[r] = i));
          }
          return t;
        }
        equals(e) {
          let { object: t, material: r, geometry: i } = e,
            s = this.getRenderObjectData(e);
          if (!0 !== s.worldMatrix.equals(t.matrixWorld))
            return s.worldMatrix.copy(t.matrixWorld), !1;
          let n = s.material;
          for (let e in n) {
            let t = n[e],
              i = r[e];
            if (void 0 !== t.equals) {
              if (!1 === t.equals(i)) return t.copy(i), !1;
            } else if (!0 === i.isTexture) {
              if (t.id !== i.id || t.version !== i.version)
                return (t.id = i.id), (t.version = i.version), !1;
            } else if (t !== i) return (n[e] = i), !1;
          }
          if (n.transmission > 0) {
            let { width: t, height: r } = e.context;
            if (s.bufferWidth !== t || s.bufferHeight !== r)
              return (s.bufferWidth = t), (s.bufferHeight = r), !1;
          }
          let a = s.geometry,
            o = i.attributes,
            l = a.attributes,
            u = Object.keys(l),
            d = Object.keys(o);
          if (a.id !== i.id) return (a.id = i.id), !1;
          if (u.length !== d.length)
            return (s.geometry.attributes = this.getAttributesData(o)), !1;
          for (let e of u) {
            let t = l[e],
              r = o[e];
            if (void 0 === r) return delete l[e], !1;
            if (t.version !== r.version) return (t.version = r.version), !1;
          }
          let h = i.index,
            c = a.indexVersion,
            p = h ? h.version : null;
          if (c !== p) return (a.indexVersion = p), !1;
          if (
            a.drawRange.start !== i.drawRange.start ||
            a.drawRange.count !== i.drawRange.count
          )
            return (
              (a.drawRange.start = i.drawRange.start),
              (a.drawRange.count = i.drawRange.count),
              !1
            );
          if (s.morphTargetInfluences) {
            let e = !1;
            for (let r = 0; r < s.morphTargetInfluences.length; r++)
              s.morphTargetInfluences[r] !== t.morphTargetInfluences[r] &&
                (e = !0);
            if (e) return !0;
          }
          return (
            s.center && !1 === s.center.equals(t.center)
              ? s.center.copy(t.center)
              : null !== e.bundle && (s.version = e.bundle.version),
            !0
          );
        }
        needsRefresh(e, t) {
          if (this.hasNode || this.hasAnimation || this.firstInitialization(e))
            return !0;
          let { renderId: r } = t;
          if (this.renderId !== r) return (this.renderId = r), !0;
          let i = !0 === e.object.static,
            s =
              null !== e.bundle &&
              !0 === e.bundle.static &&
              this.getRenderObjectData(e).version === e.bundle.version;
          return !i && !s && !0 !== this.equals(e);
        }
      }
      function c(e, t = 0) {
        let r = 0xdeadbeef ^ t,
          i = 0x41c6ce57 ^ t;
        if (e instanceof Array)
          for (let t = 0, s; t < e.length; t++)
            (r = Math.imul(r ^ (s = e[t]), 0x9e3779b1)),
              (i = Math.imul(i ^ s, 0x5f356495));
        else
          for (let t = 0, s; t < e.length; t++)
            (r = Math.imul(r ^ (s = e.charCodeAt(t)), 0x9e3779b1)),
              (i = Math.imul(i ^ s, 0x5f356495));
        return (
          (r =
            Math.imul(r ^ (r >>> 16), 0x85ebca6b) ^
            Math.imul(i ^ (i >>> 13), 0xc2b2ae35)),
          0x100000000 *
            (2097151 &
              (i =
                Math.imul(i ^ (i >>> 16), 0x85ebca6b) ^
                Math.imul(r ^ (r >>> 13), 0xc2b2ae35))) +
            (r >>> 0)
        );
      }
      let p = (e) => c(e),
        g = (e) => c(e),
        m = (...e) => c(e);
      function f(e, t = !1) {
        let r = [];
        for (let { property: i, childNode: s } of (!0 === e.isNode &&
          (r.push(e.id), (e = e.getSelf())),
        y(e)))
          r.push(c(i.slice(0, -4)), s.getCacheKey(t));
        return c(r);
      }
      function* y(e, t = !1) {
        for (let r in e) {
          if (!0 === r.startsWith("_")) continue;
          let i = e[r];
          if (!0 === Array.isArray(i))
            for (let e = 0; e < i.length; e++) {
              let s = i[e];
              s &&
                (!0 === s.isNode || (t && "function" == typeof s.toJSON)) &&
                (yield { property: r, index: e, childNode: s });
            }
          else if (i && !0 === i.isNode) yield { property: r, childNode: i };
          else if ("object" == typeof i)
            for (let e in i) {
              let s = i[e];
              s &&
                (!0 === s.isNode || (t && "function" == typeof s.toJSON)) &&
                (yield { property: r, index: e, childNode: s });
            }
        }
      }
      let x = new Map([
          [1, "float"],
          [2, "vec2"],
          [3, "vec3"],
          [4, "vec4"],
          [9, "mat3"],
          [16, "mat4"],
        ]),
        b = new WeakMap();
      function T(e) {
        return x.get(e);
      }
      function _(e) {
        if (/[iu]?vec\d/.test(e))
          return e.startsWith("ivec")
            ? Int32Array
            : e.startsWith("uvec")
            ? Uint32Array
            : Float32Array;
        if (/mat\d/.test(e) || /float/.test(e)) return Float32Array;
        if (/uint/.test(e)) return Uint32Array;
        if (/int/.test(e)) return Int32Array;
        throw Error(`THREE.NodeUtils: Unsupported type: ${e}`);
      }
      function v(e) {
        return /float|int|uint/.test(e)
          ? 1
          : /vec2/.test(e)
          ? 2
          : /vec3/.test(e)
          ? 3
          : /vec4/.test(e) || /mat2/.test(e)
          ? 4
          : /mat3/.test(e)
          ? 9
          : /mat4/.test(e)
          ? 16
          : void console.error("THREE.TSL: Unsupported type:", e);
      }
      function N(e) {
        if (null == e) return null;
        let t = typeof e;
        if (!0 === e.isNode) return "node";
        if ("number" === t) return "float";
        if ("boolean" === t) return "bool";
        if ("string" === t) return "string";
        if ("function" === t) return "shader";
        else if (!0 === e.isVector2) return "vec2";
        else if (!0 === e.isVector3) return "vec3";
        else if (!0 === e.isVector4) return "vec4";
        else if (!0 === e.isMatrix2) return "mat2";
        else if (!0 === e.isMatrix3) return "mat3";
        else if (!0 === e.isMatrix4) return "mat4";
        else if (!0 === e.isColor) return "color";
        else if (e instanceof ArrayBuffer) return "ArrayBuffer";
        return null;
      }
      function S(e, ...t) {
        let r = e ? e.slice(-4) : void 0;
        if (
          (1 === t.length &&
            ("vec2" === r
              ? (t = [t[0], t[0]])
              : "vec3" === r
              ? (t = [t[0], t[0], t[0]])
              : "vec4" === r && (t = [t[0], t[0], t[0], t[0]])),
          "color" === e)
        )
          return new u.Q1f(...t);
        if ("vec2" === r) return new u.I9Y(...t);
        if ("vec3" === r) return new u.Pq0(...t);
        if ("vec4" === r) return new u.IUQ(...t);
        if ("mat2" === r) return new u.k_V(...t);
        else if ("mat3" === r) return new u.dwI(...t);
        else if ("mat4" === r) return new u.kn4(...t);
        else if ("bool" === e) return t[0] || !1;
        else if ("float" === e || "int" === e || "uint" === e) return t[0] || 0;
        else if ("string" === e) return t[0] || "";
        else if ("ArrayBuffer" === e) return C(t[0]);
        return null;
      }
      function R(e) {
        let t = b.get(e);
        return void 0 === t && ((t = {}), b.set(e, t)), t;
      }
      function A(e) {
        let t = "",
          r = new Uint8Array(e);
        for (let e = 0; e < r.length; e++) t += String.fromCharCode(r[e]);
        return btoa(t);
      }
      function C(e) {
        return Uint8Array.from(atob(e), (e) => e.charCodeAt(0)).buffer;
      }
      var E = Object.freeze({
        __proto__: null,
        arrayBufferToBase64: A,
        base64ToArrayBuffer: C,
        getCacheKey: f,
        getDataFromObject: R,
        getLengthFromType: v,
        getNodeChildren: y,
        getTypeFromLength: T,
        getTypedArrayFromType: _,
        getValueFromType: S,
        getValueType: N,
        hash: m,
        hashArray: g,
        hashString: p,
      });
      let w = { VERTEX: "vertex", FRAGMENT: "fragment" },
        M = {
          NONE: "none",
          FRAME: "frame",
          RENDER: "render",
          OBJECT: "object",
        },
        B = {
          BOOLEAN: "bool",
          INTEGER: "int",
          FLOAT: "float",
          VECTOR2: "vec2",
          VECTOR3: "vec3",
          VECTOR4: "vec4",
          MATRIX2: "mat2",
          MATRIX3: "mat3",
          MATRIX4: "mat4",
        },
        F = {
          READ_ONLY: "readOnly",
          WRITE_ONLY: "writeOnly",
          READ_WRITE: "readWrite",
        },
        U = ["fragment", "vertex"],
        I = ["setup", "analyze", "generate"],
        P = [...U, "compute"],
        L = ["x", "y", "z", "w"],
        D = 0;
      class V extends u.Qev {
        static get type() {
          return "Node";
        }
        constructor(e = null) {
          super(),
            (this.nodeType = e),
            (this.updateType = M.NONE),
            (this.updateBeforeType = M.NONE),
            (this.updateAfterType = M.NONE),
            (this.uuid = u.cj9.generateUUID()),
            (this.version = 0),
            (this.global = !1),
            (this.isNode = !0),
            (this._cacheKey = null),
            (this._cacheKeyVersion = 0),
            Object.defineProperty(this, "id", { value: D++ });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        get type() {
          return this.constructor.type;
        }
        onUpdate(e, t) {
          return (
            (this.updateType = t), (this.update = e.bind(this.getSelf())), this
          );
        }
        onFrameUpdate(e) {
          return this.onUpdate(e, M.FRAME);
        }
        onRenderUpdate(e) {
          return this.onUpdate(e, M.RENDER);
        }
        onObjectUpdate(e) {
          return this.onUpdate(e, M.OBJECT);
        }
        onReference(e) {
          return (this.updateReference = e.bind(this.getSelf())), this;
        }
        getSelf() {
          return this.self || this;
        }
        updateReference() {
          return this;
        }
        isGlobal() {
          return this.global;
        }
        *getChildren() {
          for (let { childNode: e } of y(this)) yield e;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        traverse(e) {
          for (let t of (e(this), this.getChildren())) t.traverse(e);
        }
        getCacheKey(e = !1) {
          return (
            (!0 === (e = e || this.version !== this._cacheKeyVersion) ||
              null === this._cacheKey) &&
              ((this._cacheKey = m(f(this, e), this.customCacheKey())),
              (this._cacheKeyVersion = this.version)),
            this._cacheKey
          );
        }
        customCacheKey() {
          return 0;
        }
        getScope() {
          return this;
        }
        getHash() {
          return this.uuid;
        }
        getUpdateType() {
          return this.updateType;
        }
        getUpdateBeforeType() {
          return this.updateBeforeType;
        }
        getUpdateAfterType() {
          return this.updateAfterType;
        }
        getElementType(e) {
          let t = this.getNodeType(e);
          return e.getElementType(t);
        }
        getMemberType() {
          return "void";
        }
        getNodeType(e) {
          let t = e.getNodeProperties(this);
          return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
        }
        getShared(e) {
          let t = this.getHash(e);
          return e.getNodeFromHash(t) || this;
        }
        setup(e) {
          let t = e.getNodeProperties(this),
            r = 0;
          for (let e of this.getChildren()) t["node" + r++] = e;
          return t.outputNode || null;
        }
        analyze(e) {
          if (1 === e.increaseUsage(this))
            for (let t of Object.values(e.getNodeProperties(this)))
              t && !0 === t.isNode && t.build(e);
        }
        generate(e, t) {
          let { outputNode: r } = e.getNodeProperties(this);
          if (r && !0 === r.isNode) return r.build(e, t);
        }
        updateBefore() {
          console.warn("Abstract function.");
        }
        updateAfter() {
          console.warn("Abstract function.");
        }
        update() {
          console.warn("Abstract function.");
        }
        build(e, t = null) {
          let r = this.getShared(e);
          if (this !== r) return r.build(e, t);
          e.addNode(this), e.addChain(this);
          let i = null,
            s = e.getBuildStage();
          if ("setup" === s) {
            this.updateReference(e);
            let t = e.getNodeProperties(this);
            if (!0 !== t.initialized) {
              t.initialized = !0;
              let r = this.setup(e),
                i = r && !0 === r.isNode;
              for (let r of Object.values(t))
                r && !0 === r.isNode && r.build(e);
              i && r.build(e), (t.outputNode = r);
            }
          } else if ("analyze" === s) this.analyze(e);
          else if ("generate" === s)
            if (1 === this.generate.length) {
              let r = this.getNodeType(e),
                s = e.getDataFromNode(this);
              void 0 === (i = s.snippet)
                ? (s.snippet = i = this.generate(e) || "")
                : void 0 !== s.flowCodes &&
                  void 0 !== e.context.nodeBlock &&
                  e.addFlowCodeHierarchy(this, e.context.nodeBlock),
                (i = e.format(i, r, t));
            } else i = this.generate(e, t) || "";
          return e.removeChain(this), e.addSequentialNode(this), i;
        }
        getSerializeChildren() {
          return y(this);
        }
        serialize(e) {
          let t = this.getSerializeChildren(),
            r = {};
          for (let { property: i, index: s, childNode: n } of t)
            void 0 !== s
              ? (void 0 === r[i] && (r[i] = Number.isInteger(s) ? [] : {}),
                (r[i][s] = n.toJSON(e.meta).uuid))
              : (r[i] = n.toJSON(e.meta).uuid);
          Object.keys(r).length > 0 && (e.inputNodes = r);
        }
        deserialize(e) {
          if (void 0 !== e.inputNodes) {
            let t = e.meta.nodes;
            for (let r in e.inputNodes)
              if (Array.isArray(e.inputNodes[r])) {
                let i = [];
                for (let s of e.inputNodes[r]) i.push(t[s]);
                this[r] = i;
              } else if ("object" == typeof e.inputNodes[r]) {
                let i = {};
                for (let s in e.inputNodes[r]) {
                  let n = e.inputNodes[r][s];
                  i[s] = t[n];
                }
                this[r] = i;
              } else {
                let i = e.inputNodes[r];
                this[r] = t[i];
              }
          }
        }
        toJSON(e) {
          let { uuid: t, type: r } = this,
            i = void 0 === e || "string" == typeof e;
          i && (e = { textures: {}, images: {}, nodes: {} });
          let s = e.nodes[t];
          function n(e) {
            let t = [];
            for (let r in e) {
              let i = e[r];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (
            (void 0 === s &&
              ((s = {
                uuid: t,
                type: r,
                meta: e,
                metadata: {
                  version: 4.6,
                  type: "Node",
                  generator: "Node.toJSON",
                },
              }),
              !0 !== i && (e.nodes[s.uuid] = s),
              this.serialize(s),
              delete s.meta),
            i)
          ) {
            let t = n(e.textures),
              r = n(e.images),
              i = n(e.nodes);
            t.length > 0 && (s.textures = t),
              r.length > 0 && (s.images = r),
              i.length > 0 && (s.nodes = i);
          }
          return s;
        }
      }
      class O extends V {
        static get type() {
          return "ArrayElementNode";
        }
        constructor(e, t) {
          super(),
            (this.node = e),
            (this.indexNode = t),
            (this.isArrayElementNode = !0);
        }
        getNodeType(e) {
          return this.node.getElementType(e);
        }
        generate(e) {
          let t = this.node.build(e),
            r = this.indexNode.build(e, "uint");
          return `${t}[ ${r} ]`;
        }
      }
      class G extends V {
        static get type() {
          return "ConvertNode";
        }
        constructor(e, t) {
          super(), (this.node = e), (this.convertTo = t);
        }
        getNodeType(e) {
          let t = this.node.getNodeType(e),
            r = null;
          for (let i of this.convertTo.split("|"))
            (null === r || e.getTypeLength(t) === e.getTypeLength(i)) &&
              (r = i);
          return r;
        }
        serialize(e) {
          super.serialize(e), (e.convertTo = this.convertTo);
        }
        deserialize(e) {
          super.deserialize(e), (this.convertTo = e.convertTo);
        }
        generate(e, t) {
          let r = this.node,
            i = this.getNodeType(e),
            s = r.build(e, i);
          return e.format(s, i, t);
        }
      }
      class k extends V {
        static get type() {
          return "TempNode";
        }
        constructor(e = null) {
          super(e), (this.isTempNode = !0);
        }
        hasDependencies(e) {
          return e.getDataFromNode(this).usageCount > 1;
        }
        build(e, t) {
          if ("generate" === e.getBuildStage()) {
            let r = e.getVectorType(this.getNodeType(e, t)),
              i = e.getDataFromNode(this);
            if (void 0 !== i.propertyName)
              return e.format(i.propertyName, r, t);
            if ("void" !== r && "void" !== t && this.hasDependencies(e)) {
              let s = super.build(e, r),
                n = e.getVarFromNode(this, null, r),
                a = e.getPropertyName(n);
              return (
                e.addLineFlowCode(`${a} = ${s}`, this),
                (i.snippet = s),
                (i.propertyName = a),
                e.format(i.propertyName, r, t)
              );
            }
          }
          return super.build(e, t);
        }
      }
      class z extends k {
        static get type() {
          return "JoinNode";
        }
        constructor(e = [], t = null) {
          super(t), (this.nodes = e);
        }
        getNodeType(e) {
          return null !== this.nodeType
            ? e.getVectorType(this.nodeType)
            : e.getTypeFromLength(
                this.nodes.reduce(
                  (t, r) => t + e.getTypeLength(r.getNodeType(e)),
                  0
                )
              );
        }
        generate(e, t) {
          let r = this.getNodeType(e),
            i = this.nodes,
            s = e.getComponentType(r),
            n = [];
          for (let t of i) {
            let r = t.build(e),
              i = e.getComponentType(t.getNodeType(e));
            i !== s && (r = e.format(r, i, s)), n.push(r);
          }
          let a = `${e.getType(r)}( ${n.join(", ")} )`;
          return e.format(a, r, t);
        }
      }
      let $ = L.join("");
      class W extends V {
        static get type() {
          return "SplitNode";
        }
        constructor(e, t = "x") {
          super(),
            (this.node = e),
            (this.components = t),
            (this.isSplitNode = !0);
        }
        getVectorLength() {
          let e = this.components.length;
          for (let t of this.components) e = Math.max(L.indexOf(t) + 1, e);
          return e;
        }
        getComponentType(e) {
          return e.getComponentType(this.node.getNodeType(e));
        }
        getNodeType(e) {
          return e.getTypeFromLength(
            this.components.length,
            this.getComponentType(e)
          );
        }
        generate(e, t) {
          let r = this.node,
            i = e.getTypeLength(r.getNodeType(e)),
            s = null;
          if (i > 1) {
            let n = null;
            this.getVectorLength() >= i &&
              (n = e.getTypeFromLength(
                this.getVectorLength(),
                this.getComponentType(e)
              ));
            let a = r.build(e, n);
            s =
              this.components.length === i &&
              this.components === $.slice(0, this.components.length)
                ? e.format(a, n, t)
                : e.format(`${a}.${this.components}`, this.getNodeType(e), t);
          } else s = r.build(e, t);
          return s;
        }
        serialize(e) {
          super.serialize(e), (e.components = this.components);
        }
        deserialize(e) {
          super.deserialize(e), (this.components = e.components);
        }
      }
      class H extends k {
        static get type() {
          return "SetNode";
        }
        constructor(e, t, r) {
          super(),
            (this.sourceNode = e),
            (this.components = t),
            (this.targetNode = r);
        }
        getNodeType(e) {
          return this.sourceNode.getNodeType(e);
        }
        generate(e) {
          let { sourceNode: t, components: r, targetNode: i } = this,
            s = this.getNodeType(e),
            n = e.getComponentType(i.getNodeType(e)),
            a = e.getTypeFromLength(r.length, n),
            o = i.build(e, a),
            l = t.build(e, s),
            u = e.getTypeLength(s),
            d = [];
          for (let e = 0; e < u; e++) {
            let t = L[e];
            t === r[0] ? (d.push(o), (e += r.length - 1)) : d.push(l + "." + t);
          }
          return `${e.getType(s)}( ${d.join(", ")} )`;
        }
      }
      class q extends k {
        static get type() {
          return "FlipNode";
        }
        constructor(e, t) {
          super(), (this.sourceNode = e), (this.components = t);
        }
        getNodeType(e) {
          return this.sourceNode.getNodeType(e);
        }
        generate(e) {
          let { components: t, sourceNode: r } = this,
            i = this.getNodeType(e),
            s = r.build(e),
            n = e.getVarFromNode(this),
            a = e.getPropertyName(n);
          e.addLineFlowCode(a + " = " + s, this);
          let o = e.getTypeLength(i),
            l = [],
            u = 0;
          for (let e = 0; e < o; e++) {
            let r = L[e];
            r === t[u]
              ? (l.push("1.0 - " + a + "." + r), u++)
              : l.push(a + "." + r);
          }
          return `${e.getType(i)}( ${l.join(", ")} )`;
        }
      }
      class j extends V {
        static get type() {
          return "InputNode";
        }
        constructor(e, t = null) {
          super(t),
            (this.isInputNode = !0),
            (this.value = e),
            (this.precision = null);
        }
        getNodeType() {
          return null === this.nodeType ? N(this.value) : this.nodeType;
        }
        getInputType(e) {
          return this.getNodeType(e);
        }
        setPrecision(e) {
          return (this.precision = e), this;
        }
        serialize(e) {
          super.serialize(e),
            (e.value = this.value),
            this.value &&
              this.value.toArray &&
              (e.value = this.value.toArray()),
            (e.valueType = N(this.value)),
            (e.nodeType = this.nodeType),
            "ArrayBuffer" === e.valueType && (e.value = A(e.value)),
            (e.precision = this.precision);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.nodeType = e.nodeType),
            (this.value = Array.isArray(e.value)
              ? S(e.valueType, ...e.value)
              : e.value),
            (this.precision = e.precision || null),
            this.value &&
              this.value.fromArray &&
              (this.value = this.value.fromArray(e.value));
        }
        generate() {
          console.warn("Abstract function.");
        }
      }
      let X = /float|u?int/;
      class Q extends j {
        static get type() {
          return "ConstNode";
        }
        constructor(e, t = null) {
          super(e, t), (this.isConstNode = !0);
        }
        generateConst(e) {
          return e.generateConst(this.getNodeType(e), this.value);
        }
        generate(e, t) {
          let r = this.getNodeType(e);
          return X.test(r) && X.test(t)
            ? e.generateConst(t, this.value)
            : e.format(this.generateConst(e), r, t);
        }
      }
      class K extends V {
        static get type() {
          return "MemberNode";
        }
        constructor(e, t) {
          super(),
            (this.node = e),
            (this.property = t),
            (this.isMemberNode = !0);
        }
        getNodeType(e) {
          return this.node.getMemberType(e, this.property);
        }
        generate(e) {
          return this.node.build(e) + "." + this.property;
        }
      }
      let Y = null,
        Z = new Map();
      function J(e, t) {
        if (Z.has(e))
          return void console.warn(`Redefinition of method chaining ${e}`);
        if ("function" != typeof t)
          throw Error(`Node element ${e} is not a function`);
        Z.set(e, t);
      }
      let ee = (e) =>
          e
            .replace(/r|s/g, "x")
            .replace(/g|t/g, "y")
            .replace(/b|p/g, "z")
            .replace(/a|q/g, "w"),
        et = (e) => ee(e).split("").sort().join(""),
        er = {
          setup: (e, t) => e(eA(t.shift()), ...t),
          get(e, t, r) {
            if ("string" == typeof t && void 0 === e[t]) {
              if (!0 !== e.isStackNode && "assign" === t)
                return (...e) => (Y.assign(r, ...e), r);
              else if (Z.has(t)) {
                let i = Z.get(t);
                return e.isStackNode
                  ? (...e) => r.add(i(...e))
                  : (...e) => i(r, ...e);
              } else if ("self" === t) return e;
              else if (
                t.endsWith("Assign") &&
                Z.has(t.slice(0, t.length - 6))
              ) {
                let i = Z.get(t.slice(0, t.length - 6));
                return e.isStackNode
                  ? (...e) => r.assign(e[0], i(...e))
                  : (...e) => r.assign(i(r, ...e));
              } else if (!0 === /^[xyzwrgbastpq]{1,4}$/.test(t))
                return eR(new W(r, (t = ee(t))));
              else if (!0 === /^set[XYZWRGBASTPQ]{1,4}$/.test(t))
                return (
                  (t = et(t.slice(3).toLowerCase())), (r) => eR(new H(e, t, r))
                );
              else if (!0 === /^flip[XYZWRGBASTPQ]{1,4}$/.test(t))
                return (
                  (t = et(t.slice(4).toLowerCase())), () => eR(new q(eR(e), t))
                );
              else if ("width" === t || "height" === t || "depth" === t)
                return (
                  "width" === t
                    ? (t = "x")
                    : "height" === t
                    ? (t = "y")
                    : "depth" === t && (t = "z"),
                  eR(new W(e, t))
                );
              else if (!0 === /^\d+$/.test(t))
                return eR(new O(r, new Q(Number(t), "uint")));
              else if (!0 === /^get$/.test(t)) return (e) => eR(new K(r, e));
            }
            return Reflect.get(e, t, r);
          },
          set: (e, t, r, i) =>
            "string" == typeof t &&
            void 0 === e[t] &&
            (!0 === /^[xyzwrgbastpq]{1,4}$/.test(t) ||
              "width" === t ||
              "height" === t ||
              "depth" === t ||
              !0 === /^\d+$/.test(t))
              ? (i[t].assign(r), !0)
              : Reflect.set(e, t, r, i),
        },
        ei = new WeakMap(),
        es = new WeakMap(),
        en = function (e, t = null) {
          let r = N(e);
          if ("node" === r) {
            let t = ei.get(e);
            return (
              void 0 === t &&
                ((t = new Proxy(e, er)), ei.set(e, t), ei.set(t, t)),
              t
            );
          }
          return (null === t && ("float" === r || "boolean" === r)) ||
            (r && "shader" !== r && "string" !== r)
            ? eR(eb(e, t))
            : "shader" === r
            ? eM(e)
            : e;
        },
        ea = function (e, t = null) {
          for (let r in e) e[r] = eR(e[r], t);
          return e;
        },
        eo = function (e, t = null) {
          let r = e.length;
          for (let i = 0; i < r; i++) e[i] = eR(e[i], t);
          return e;
        },
        el = function (e, t = null, r = null, i = null) {
          let s = (e) => eR(null !== i ? Object.assign(e, i) : e);
          return null === t
            ? (...t) => s(new e(...eC(t)))
            : null !== r
            ? ((r = eR(r)), (...i) => s(new e(t, ...eC(i), r)))
            : (...r) => s(new e(t, ...eC(r)));
        },
        eu = function (e, ...t) {
          return eR(new e(...eC(t)));
        };
      class ed extends V {
        constructor(e, t) {
          super(), (this.shaderNode = e), (this.inputNodes = t);
        }
        getNodeType(e) {
          return (
            this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e)
          );
        }
        getMemberType(e, t) {
          return this.getOutputNode(e).getMemberType(e, t);
        }
        call(e) {
          let { shaderNode: t, inputNodes: r } = this,
            i = e.getNodeProperties(t);
          if (i.onceOutput) return i.onceOutput;
          let s = null;
          if (t.layout) {
            let i = es.get(e.constructor);
            void 0 === i && ((i = new WeakMap()), es.set(e.constructor, i));
            let n = i.get(t);
            void 0 === n && ((n = eR(e.buildFunctionNode(t))), i.set(t, n)),
              e.addInclude(n),
              (s = eR(n.call(r)));
          } else {
            let i = t.jsFunc;
            s = eR(null !== r || i.length > 1 ? i(r || [], e) : i(e));
          }
          return t.once && (i.onceOutput = s), s;
        }
        getOutputNode(e) {
          let t = e.getNodeProperties(this);
          return (
            null === t.outputNode && (t.outputNode = this.setupOutput(e)),
            t.outputNode
          );
        }
        setup(e) {
          return this.getOutputNode(e);
        }
        setupOutput(e) {
          return (
            e.addStack(), (e.stack.outputNode = this.call(e)), e.removeStack()
          );
        }
        generate(e, t) {
          return this.getOutputNode(e).build(e, t);
        }
      }
      class eh extends V {
        constructor(e, t) {
          super(t),
            (this.jsFunc = e),
            (this.layout = null),
            (this.global = !0),
            (this.once = !1);
        }
        setLayout(e) {
          return (this.layout = e), this;
        }
        call(e = null) {
          return eA(e), eR(new ed(this, e));
        }
        setup() {
          return this.call();
        }
      }
      let ec = [
          0.5,
          1.5,
          1 / 3,
          1e-6,
          1e6,
          Math.PI,
          2 * Math.PI,
          1 / Math.PI,
          2 / Math.PI,
          1 / (2 * Math.PI),
          Math.PI / 2,
        ],
        ep = new Map();
      for (let e of [!1, !0]) ep.set(e, new Q(e));
      let eg = new Map();
      for (let e of [0, 1, 2, 3]) eg.set(e, new Q(e, "uint"));
      let em = new Map([...eg].map((e) => new Q(e.value, "int")));
      for (let e of [-1, -2]) em.set(e, new Q(e, "int"));
      let ef = new Map([...em].map((e) => new Q(e.value)));
      for (let e of ec) ef.set(e, new Q(e));
      for (let e of ec) ef.set(-e, new Q(-e));
      let ey = { bool: ep, uint: eg, ints: em, float: ef },
        ex = new Map([...ep, ...ef]),
        eb = (e, t) =>
          ex.has(e) ? ex.get(e) : !0 === e.isNode ? e : new Q(e, t),
        eT = (e) => {
          try {
            return e.getNodeType();
          } catch (e) {
            return;
          }
        },
        e_ = function (e, t = null) {
          return (...r) => {
            if (
              ((0 === r.length ||
                (!["bool", "float", "int", "uint"].includes(e) &&
                  r.every((e) => "object" != typeof e))) &&
                (r = [S(e, ...r)]),
              1 === r.length && null !== t && t.has(r[0]))
            )
              return eR(t.get(r[0]));
            if (1 === r.length) {
              let t = eb(r[0], e);
              return eT(t) === e ? eR(t) : eR(new G(t, e));
            }
            return eR(
              new z(
                r.map((e) => eb(e)),
                e
              )
            );
          };
        },
        ev = (e) => ("object" == typeof e && null !== e ? e.value : e),
        eN = (e) =>
          null != e
            ? e.nodeType || e.convertTo || ("string" == typeof e ? e : null)
            : null;
      function eS(e, t) {
        return new Proxy(new eh(e, t), er);
      }
      let eR = (e, t = null) => en(e, t),
        eA = (e, t = null) => new ea(e, t),
        eC = (e, t = null) => new eo(e, t),
        eE = (...e) => new el(...e),
        ew = (...e) => new eu(...e),
        eM = (e, t) => {
          let r = new eS(e, t),
            i = (...e) => {
              let t;
              return (
                eA(e), (t = e[0] && e[0].isNode ? [...e] : e[0]), r.call(t)
              );
            };
          return (
            (i.shaderNode = r),
            (i.setLayout = (e) => (r.setLayout(e), i)),
            (i.once = () => ((r.once = !0), i)),
            i
          );
        };
      J("toGlobal", (e) => ((e.global = !0), e));
      let eB = (e) => {
          Y = e;
        },
        eF = () => Y,
        eU = (...e) => Y.If(...e);
      function eI(e) {
        return Y && Y.add(e), e;
      }
      J("append", eI);
      let eP = new e_("color"),
        eL = new e_("float", ey.float),
        eD = new e_("int", ey.ints),
        eV = new e_("uint", ey.uint),
        eO = new e_("bool", ey.bool),
        eG = new e_("vec2"),
        ek = new e_("ivec2"),
        ez = new e_("uvec2"),
        e$ = new e_("bvec2"),
        eW = new e_("vec3"),
        eH = new e_("ivec3"),
        eq = new e_("uvec3"),
        ej = new e_("bvec3"),
        eX = new e_("vec4"),
        eQ = new e_("ivec4"),
        eK = new e_("uvec4"),
        eY = new e_("bvec4"),
        eZ = new e_("mat2"),
        eJ = new e_("mat3"),
        e0 = new e_("mat4");
      J("toColor", eP),
        J("toFloat", eL),
        J("toInt", eD),
        J("toUint", eV),
        J("toBool", eO),
        J("toVec2", eG),
        J("toIVec2", ek),
        J("toUVec2", ez),
        J("toBVec2", e$),
        J("toVec3", eW),
        J("toIVec3", eH),
        J("toUVec3", eq),
        J("toBVec3", ej),
        J("toVec4", eX),
        J("toIVec4", eQ),
        J("toUVec4", eK),
        J("toBVec4", eY),
        J("toMat2", eZ),
        J("toMat3", eJ),
        J("toMat4", e0);
      let e1 = eE(O),
        e2 = (e, t) => eR(new G(eR(e), t));
      J("element", e1), J("convert", e2);
      class e3 extends k {
        static get type() {
          return "ArrayNode";
        }
        constructor(e, t, r = null) {
          super(e),
            (this.count = t),
            (this.values = r),
            (this.isArrayNode = !0);
        }
        getNodeType(e) {
          return (
            null === this.nodeType &&
              (this.nodeType = this.values[0].getNodeType(e)),
            this.nodeType
          );
        }
        getElementType(e) {
          return this.getNodeType(e);
        }
        generate(e) {
          let t = this.getNodeType(e);
          return e.generateArray(t, this.count, this.values);
        }
      }
      let e4 = (...e) => {
        let t;
        if (1 === e.length) {
          let r = e[0];
          t = new e3(null, r.length, r);
        } else t = new e3(e[0], e[1]);
        return eR(t);
      };
      J("toArray", (e, t) => e4(Array(t).fill(e)));
      class e6 extends V {
        static get type() {
          return "UniformGroupNode";
        }
        constructor(e, t = !1, r = 1) {
          super("string"),
            (this.name = e),
            (this.shared = t),
            (this.order = r),
            (this.isUniformGroup = !0);
        }
        serialize(e) {
          super.serialize(e),
            (e.name = this.name),
            (e.version = this.version),
            (e.shared = this.shared);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.name = e.name),
            (this.version = e.version),
            (this.shared = e.shared);
        }
      }
      let e5 = (e) => new e6(e),
        e8 = (e, t = 0) => new e6(e, !0, t),
        e9 = e8("frame"),
        e7 = e8("render"),
        te = e5("object");
      class tt extends j {
        static get type() {
          return "UniformNode";
        }
        constructor(e, t = null) {
          super(e, t),
            (this.isUniformNode = !0),
            (this.name = ""),
            (this.groupNode = te);
        }
        label(e) {
          return (this.name = e), this;
        }
        setGroup(e) {
          return (this.groupNode = e), this;
        }
        getGroup() {
          return this.groupNode;
        }
        getUniformHash(e) {
          return this.getHash(e);
        }
        onUpdate(e, t) {
          let r = this.getSelf();
          return (
            (e = e.bind(r)),
            super.onUpdate((t) => {
              let i = e(t, r);
              void 0 !== i && (this.value = i);
            }, t)
          );
        }
        generate(e, t) {
          let r = this.getNodeType(e),
            i = this.getUniformHash(e),
            s = e.getNodeFromHash(i);
          void 0 === s && (e.setHashNode(this, i), (s = this));
          let n = s.getInputType(e),
            a = e.getUniformFromNode(
              s,
              n,
              e.shaderStage,
              this.name || e.context.label
            ),
            o = e.getPropertyName(a);
          return (
            void 0 !== e.context.label && delete e.context.label,
            e.format(o, r, t)
          );
        }
      }
      let tr = (e, t) => {
        let r = eN(t || e);
        return eR(
          new tt(
            e && !0 === e.isNode ? (e.node && e.node.value) || e.value : e,
            r
          )
        );
      };
      class ti extends V {
        static get type() {
          return "PropertyNode";
        }
        constructor(e, t = null, r = !1) {
          super(e),
            (this.name = t),
            (this.varying = r),
            (this.isPropertyNode = !0);
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        isGlobal() {
          return !0;
        }
        generate(e) {
          let t;
          return (
            !0 === this.varying
              ? ((t = e.getVaryingFromNode(
                  this,
                  this.name
                )).needsInterpolation = !0)
              : (t = e.getVarFromNode(this, this.name)),
            e.getPropertyName(t)
          );
        }
      }
      let ts = (e, t) => eR(new ti(e, t)),
        tn = (e, t) => eR(new ti(e, t, !0)),
        ta = ew(ti, "vec4", "DiffuseColor"),
        to = ew(ti, "vec3", "EmissiveColor"),
        tl = ew(ti, "float", "Roughness"),
        tu = ew(ti, "float", "Metalness"),
        td = ew(ti, "float", "Clearcoat"),
        th = ew(ti, "float", "ClearcoatRoughness"),
        tc = ew(ti, "vec3", "Sheen"),
        tp = ew(ti, "float", "SheenRoughness"),
        tg = ew(ti, "float", "Iridescence"),
        tm = ew(ti, "float", "IridescenceIOR"),
        tf = ew(ti, "float", "IridescenceThickness"),
        ty = ew(ti, "float", "AlphaT"),
        tx = ew(ti, "float", "Anisotropy"),
        tb = ew(ti, "vec3", "AnisotropyT"),
        tT = ew(ti, "vec3", "AnisotropyB"),
        t_ = ew(ti, "color", "SpecularColor"),
        tv = ew(ti, "float", "SpecularF90"),
        tN = ew(ti, "float", "Shininess"),
        tS = ew(ti, "vec4", "Output"),
        tR = ew(ti, "float", "dashSize"),
        tA = ew(ti, "float", "gapSize"),
        tC = ew(ti, "float", "pointWidth"),
        tE = ew(ti, "float", "IOR"),
        tw = ew(ti, "float", "Transmission"),
        tM = ew(ti, "float", "Thickness"),
        tB = ew(ti, "float", "AttenuationDistance"),
        tF = ew(ti, "color", "AttenuationColor"),
        tU = ew(ti, "float", "Dispersion");
      class tI extends k {
        static get type() {
          return "AssignNode";
        }
        constructor(e, t) {
          super(), (this.targetNode = e), (this.sourceNode = t);
        }
        hasDependencies() {
          return !1;
        }
        getNodeType(e, t) {
          return "void" !== t ? this.targetNode.getNodeType(e) : "void";
        }
        needsSplitAssign(e) {
          let { targetNode: t } = this;
          if (
            !1 === e.isAvailable("swizzleAssign") &&
            t.isSplitNode &&
            t.components.length > 1
          ) {
            let r = e.getTypeLength(t.node.getNodeType(e));
            return L.join("").slice(0, r) !== t.components;
          }
          return !1;
        }
        generate(e, t) {
          let r,
            { targetNode: i, sourceNode: s } = this,
            n = this.needsSplitAssign(e),
            a = i.getNodeType(e),
            o = i.context({ assign: !0 }).build(e),
            l = s.build(e, a),
            u = s.getNodeType(e),
            d = e.getDataFromNode(this);
          if (!0 === d.initialized) "void" !== t && (r = o);
          else if (n) {
            let s = e.getVarFromNode(this, null, a),
              n = e.getPropertyName(s);
            e.addLineFlowCode(`${n} = ${l}`, this);
            let u = i.node.context({ assign: !0 }).build(e);
            for (let t = 0; t < i.components.length; t++) {
              let r = i.components[t];
              e.addLineFlowCode(`${u}.${r} = ${n}[ ${t} ]`, this);
            }
            "void" !== t && (r = o);
          } else
            (r = `${o} = ${l}`),
              ("void" === t || "void" === u) &&
                (e.addLineFlowCode(r, this), "void" !== t && (r = o));
          return (d.initialized = !0), e.format(r, a, t);
        }
      }
      let tP = eE(tI);
      J("assign", tP);
      class tL extends k {
        static get type() {
          return "FunctionCallNode";
        }
        constructor(e = null, t = {}) {
          super(), (this.functionNode = e), (this.parameters = t);
        }
        setParameters(e) {
          return (this.parameters = e), this;
        }
        getParameters() {
          return this.parameters;
        }
        getNodeType(e) {
          return this.functionNode.getNodeType(e);
        }
        generate(e) {
          let t = [],
            r = this.functionNode,
            i = r.getInputs(e),
            s = this.parameters,
            n = (t, r) => {
              let i,
                s = r.type;
              return "pointer" === s ? "&" + t.build(e) : t.build(e, s);
            };
          if (Array.isArray(s))
            for (let e = 0; e < s.length; e++) t.push(n(s[e], i[e]));
          else
            for (let e of i) {
              let r = s[e.name];
              if (void 0 !== r) t.push(n(r, e));
              else
                throw Error(
                  `FunctionCallNode: Input '${e.name}' not found in FunctionNode.`
                );
            }
          let a = r.build(e, "property");
          return `${a}( ${t.join(", ")} )`;
        }
      }
      let tD = (e, ...t) => (
        (t = t.length > 1 || (t[0] && !0 === t[0].isNode) ? eC(t) : eA(t[0])),
        eR(new tL(eR(e), t))
      );
      J("call", tD);
      class tV extends k {
        static get type() {
          return "OperatorNode";
        }
        constructor(e, t, r, ...i) {
          if ((super(), i.length > 0)) {
            let s = new tV(e, t, r);
            for (let t = 0; t < i.length - 1; t++) s = new tV(e, s, i[t]);
            (t = s), (r = i[i.length - 1]);
          }
          (this.op = e),
            (this.aNode = t),
            (this.bNode = r),
            (this.isOperatorNode = !0);
        }
        getNodeType(e, t) {
          let r = this.op,
            i = this.aNode,
            s = this.bNode,
            n = i.getNodeType(e),
            a = void 0 !== s ? s.getNodeType(e) : null;
          if ("void" === n || "void" === a) return "void";
          if ("%" === r) return n;
          if (
            "~" === r ||
            "&" === r ||
            "|" === r ||
            "^" === r ||
            ">>" === r ||
            "<<" === r
          )
            return e.getIntegerType(n);
          if ("!" === r || "==" === r || "&&" === r || "||" === r || "^^" === r)
            return "bool";
          if ("<" === r || ">" === r || "<=" === r || ">=" === r) {
            let r = t
              ? e.getTypeLength(t)
              : Math.max(e.getTypeLength(n), e.getTypeLength(a));
            return r > 1 ? `bvec${r}` : "bool";
          } else {
            if (e.isMatrix(n)) {
              if ("float" === a) return n;
              else if (e.isVector(a)) return e.getVectorFromMatrix(n);
              else if (e.isMatrix(a)) return n;
            } else if (e.isMatrix(a)) {
              if ("float" === n) return a;
              else if (e.isVector(n)) return e.getVectorFromMatrix(a);
            }
            return e.getTypeLength(a) > e.getTypeLength(n) ? a : n;
          }
        }
        generate(e, t) {
          let r = this.op,
            i = this.aNode,
            s = this.bNode,
            n = this.getNodeType(e, t),
            a = null,
            o = null;
          "void" !== n
            ? ((a = i.getNodeType(e)),
              (o = void 0 !== s ? s.getNodeType(e) : null),
              "<" === r || ">" === r || "<=" === r || ">=" === r || "==" === r
                ? e.isVector(a)
                  ? (o = a)
                  : a !== o && (a = o = "float")
                : ">>" === r || "<<" === r
                ? ((a = n), (o = e.changeComponentType(o, "uint")))
                : e.isMatrix(a)
                ? "float" === o
                  ? (o = "float")
                  : e.isVector(o)
                  ? (o = e.getVectorFromMatrix(a))
                  : e.isMatrix(o) || (a = o = n)
                : (a = e.isMatrix(o)
                    ? "float" === a
                      ? "float"
                      : e.isVector(a)
                      ? e.getVectorFromMatrix(o)
                      : (o = n)
                    : (o = n)))
            : (a = o = n);
          let l = i.build(e, a),
            u = void 0 !== s ? s.build(e, o) : null,
            d = e.getTypeLength(t),
            h = e.getFunctionOperator(r);
          if ("void" !== t)
            if ("<" === r && d > 1)
              if (e.useComparisonMethod)
                return e.format(
                  `${e.getMethod("lessThan", t)}( ${l}, ${u} )`,
                  n,
                  t
                );
              else return e.format(`( ${l} < ${u} )`, n, t);
            else if ("<=" === r && d > 1)
              if (e.useComparisonMethod)
                return e.format(
                  `${e.getMethod("lessThanEqual", t)}( ${l}, ${u} )`,
                  n,
                  t
                );
              else return e.format(`( ${l} <= ${u} )`, n, t);
            else if (">" === r && d > 1)
              if (e.useComparisonMethod)
                return e.format(
                  `${e.getMethod("greaterThan", t)}( ${l}, ${u} )`,
                  n,
                  t
                );
              else return e.format(`( ${l} > ${u} )`, n, t);
            else if (">=" === r && d > 1)
              if (e.useComparisonMethod)
                return e.format(
                  `${e.getMethod("greaterThanEqual", t)}( ${l}, ${u} )`,
                  n,
                  t
                );
              else return e.format(`( ${l} >= ${u} )`, n, t);
            else if ("!" === r || "~" === r)
              return e.format(`(${r}${l})`, a, t);
            else if (h) return e.format(`${h}( ${l}, ${u} )`, n, t);
            else if (e.isMatrix(a) && "float" === o)
              return e.format(`( ${u} ${r} ${l} )`, n, t);
            else if ("float" === a && e.isMatrix(o))
              return e.format(`${l} ${r} ${u}`, n, t);
            else return e.format(`( ${l} ${r} ${u} )`, n, t);
          if ("void" !== a)
            if (h) return e.format(`${h}( ${l}, ${u} )`, n, t);
            else if (e.isMatrix(a) && "float" === o)
              return e.format(`${u} ${r} ${l}`, n, t);
            else return e.format(`${l} ${r} ${u}`, n, t);
        }
        serialize(e) {
          super.serialize(e), (e.op = this.op);
        }
        deserialize(e) {
          super.deserialize(e), (this.op = e.op);
        }
      }
      let tO = eE(tV, "+"),
        tG = eE(tV, "-"),
        tk = eE(tV, "*"),
        tz = eE(tV, "/"),
        t$ = eE(tV, "%"),
        tW = eE(tV, "=="),
        tH = eE(tV, "!="),
        tq = eE(tV, "<"),
        tj = eE(tV, ">"),
        tX = eE(tV, "<="),
        tQ = eE(tV, ">="),
        tK = eE(tV, "&&"),
        tY = eE(tV, "||"),
        tZ = eE(tV, "!"),
        tJ = eE(tV, "^^"),
        t0 = eE(tV, "&"),
        t1 = eE(tV, "~"),
        t2 = eE(tV, "|"),
        t3 = eE(tV, "^"),
        t4 = eE(tV, "<<"),
        t6 = eE(tV, ">>");
      J("add", tO),
        J("sub", tG),
        J("mul", tk),
        J("div", tz),
        J("modInt", t$),
        J("equal", tW),
        J("notEqual", tH),
        J("lessThan", tq),
        J("greaterThan", tj),
        J("lessThanEqual", tX),
        J("greaterThanEqual", tQ),
        J("and", tK),
        J("or", tY),
        J("not", tZ),
        J("xor", tJ),
        J("bitAnd", t0),
        J("bitNot", t1),
        J("bitOr", t2),
        J("bitXor", t3),
        J("shiftLeft", t4),
        J("shiftRight", t6);
      let t5 = (...e) => (
        console.warn(
          "TSL.OperatorNode: .remainder() has been renamed to .modInt()."
        ),
        t$(...e)
      );
      J("remainder", t5);
      class t8 extends k {
        static get type() {
          return "MathNode";
        }
        constructor(e, t, r = null, i = null) {
          super(),
            (this.method = e),
            (this.aNode = t),
            (this.bNode = r),
            (this.cNode = i),
            (this.isMathNode = !0);
        }
        getInputType(e) {
          let t = this.aNode.getNodeType(e),
            r = this.bNode ? this.bNode.getNodeType(e) : null,
            i = this.cNode ? this.cNode.getNodeType(e) : null,
            s = e.isMatrix(t) ? 0 : e.getTypeLength(t),
            n = e.isMatrix(r) ? 0 : e.getTypeLength(r),
            a = e.isMatrix(i) ? 0 : e.getTypeLength(i);
          if (s > n && s > a);
          else if (n > a) return r;
          else if (a > s) return i;
          return t;
        }
        getNodeType(e) {
          let t = this.method;
          if (t === t8.LENGTH || t === t8.DISTANCE || t === t8.DOT)
            return "float";
          if (t === t8.CROSS) return "vec3";
          if (t === t8.ALL) return "bool";
          if (t === t8.EQUALS)
            return e.changeComponentType(this.aNode.getNodeType(e), "bool");
          if (t === t8.MOD) return this.aNode.getNodeType(e);
          else return this.getInputType(e);
        }
        generate(e, t) {
          let r = this.method,
            i = this.getNodeType(e),
            s = this.getInputType(e),
            n = this.aNode,
            a = this.bNode,
            o = this.cNode,
            l = e.renderer.coordinateSystem;
          if (r === t8.TRANSFORM_DIRECTION) {
            let r = n,
              i = a;
            return (
              e.isMatrix(r.getNodeType(e))
                ? (i = eX(eW(i), 0))
                : (r = eX(eW(r), 0)),
              rg(tk(r, i).xyz).build(e, t)
            );
          }
          {
            if (r === t8.NEGATE)
              return e.format("( - " + n.build(e, s) + " )", i, t);
            if (r === t8.ONE_MINUS) return tG(1, n).build(e, t);
            if (r === t8.RECIPROCAL) return tz(1, n).build(e, t);
            if (r === t8.DIFFERENCE) return rv(tG(n, a)).build(e, t);
            let d = [];
            return (
              r === t8.CROSS || r === t8.MOD
                ? d.push(n.build(e, i), a.build(e, i))
                : l === u.TdN && r === t8.STEP
                ? d.push(
                    n.build(
                      e,
                      1 === e.getTypeLength(n.getNodeType(e)) ? "float" : s
                    ),
                    a.build(e, s)
                  )
                : (l === u.TdN && (r === t8.MIN || r === t8.MAX)) ||
                  r === t8.MOD
                ? d.push(
                    n.build(e, s),
                    a.build(
                      e,
                      1 === e.getTypeLength(a.getNodeType(e)) ? "float" : s
                    )
                  )
                : r === t8.REFRACT
                ? d.push(n.build(e, s), a.build(e, s), o.build(e, "float"))
                : r === t8.MIX
                ? d.push(
                    n.build(e, s),
                    a.build(e, s),
                    o.build(
                      e,
                      1 === e.getTypeLength(o.getNodeType(e)) ? "float" : s
                    )
                  )
                : (l === u.i7u && r === t8.ATAN && null !== a && (r = "atan2"),
                  d.push(n.build(e, s)),
                  null !== a && d.push(a.build(e, s)),
                  null !== o && d.push(o.build(e, s))),
              e.format(`${e.getMethod(r, i)}( ${d.join(", ")} )`, i, t)
            );
          }
        }
        serialize(e) {
          super.serialize(e), (e.method = this.method);
        }
        deserialize(e) {
          super.deserialize(e), (this.method = e.method);
        }
      }
      (t8.ALL = "all"),
        (t8.ANY = "any"),
        (t8.RADIANS = "radians"),
        (t8.DEGREES = "degrees"),
        (t8.EXP = "exp"),
        (t8.EXP2 = "exp2"),
        (t8.LOG = "log"),
        (t8.LOG2 = "log2"),
        (t8.SQRT = "sqrt"),
        (t8.INVERSE_SQRT = "inversesqrt"),
        (t8.FLOOR = "floor"),
        (t8.CEIL = "ceil"),
        (t8.NORMALIZE = "normalize"),
        (t8.FRACT = "fract"),
        (t8.SIN = "sin"),
        (t8.COS = "cos"),
        (t8.TAN = "tan"),
        (t8.ASIN = "asin"),
        (t8.ACOS = "acos"),
        (t8.ATAN = "atan"),
        (t8.ABS = "abs"),
        (t8.SIGN = "sign"),
        (t8.LENGTH = "length"),
        (t8.NEGATE = "negate"),
        (t8.ONE_MINUS = "oneMinus"),
        (t8.DFDX = "dFdx"),
        (t8.DFDY = "dFdy"),
        (t8.ROUND = "round"),
        (t8.RECIPROCAL = "reciprocal"),
        (t8.TRUNC = "trunc"),
        (t8.FWIDTH = "fwidth"),
        (t8.TRANSPOSE = "transpose"),
        (t8.BITCAST = "bitcast"),
        (t8.EQUALS = "equals"),
        (t8.MIN = "min"),
        (t8.MAX = "max"),
        (t8.MOD = "mod"),
        (t8.STEP = "step"),
        (t8.REFLECT = "reflect"),
        (t8.DISTANCE = "distance"),
        (t8.DIFFERENCE = "difference"),
        (t8.DOT = "dot"),
        (t8.CROSS = "cross"),
        (t8.POW = "pow"),
        (t8.TRANSFORM_DIRECTION = "transformDirection"),
        (t8.MIX = "mix"),
        (t8.CLAMP = "clamp"),
        (t8.REFRACT = "refract"),
        (t8.SMOOTHSTEP = "smoothstep"),
        (t8.FACEFORWARD = "faceforward");
      let t9 = eL(1e-6),
        t7 = eL(1e6),
        re = eL(Math.PI),
        rt = eL(2 * Math.PI),
        rr = eE(t8, t8.ALL),
        ri = eE(t8, t8.ANY),
        rs = eE(t8, t8.RADIANS),
        rn = eE(t8, t8.DEGREES),
        ra = eE(t8, t8.EXP),
        ro = eE(t8, t8.EXP2),
        rl = eE(t8, t8.LOG),
        ru = eE(t8, t8.LOG2),
        rd = eE(t8, t8.SQRT),
        rh = eE(t8, t8.INVERSE_SQRT),
        rc = eE(t8, t8.FLOOR),
        rp = eE(t8, t8.CEIL),
        rg = eE(t8, t8.NORMALIZE),
        rm = eE(t8, t8.FRACT),
        rf = eE(t8, t8.SIN),
        ry = eE(t8, t8.COS),
        rx = eE(t8, t8.TAN),
        rb = eE(t8, t8.ASIN),
        rT = eE(t8, t8.ACOS),
        r_ = eE(t8, t8.ATAN),
        rv = eE(t8, t8.ABS),
        rN = eE(t8, t8.SIGN),
        rS = eE(t8, t8.LENGTH),
        rR = eE(t8, t8.NEGATE),
        rA = eE(t8, t8.ONE_MINUS),
        rC = eE(t8, t8.DFDX),
        rE = eE(t8, t8.DFDY),
        rw = eE(t8, t8.ROUND),
        rM = eE(t8, t8.RECIPROCAL),
        rB = eE(t8, t8.TRUNC),
        rF = eE(t8, t8.FWIDTH),
        rU = eE(t8, t8.TRANSPOSE),
        rI = eE(t8, t8.BITCAST),
        rP = eE(t8, t8.EQUALS),
        rL = eE(t8, t8.MIN),
        rD = eE(t8, t8.MAX),
        rV = eE(t8, t8.MOD),
        rO = eE(t8, t8.STEP),
        rG = eE(t8, t8.REFLECT),
        rk = eE(t8, t8.DISTANCE),
        rz = eE(t8, t8.DIFFERENCE),
        r$ = eE(t8, t8.DOT),
        rW = eE(t8, t8.CROSS),
        rH = eE(t8, t8.POW),
        rq = eE(t8, t8.POW, 2),
        rj = eE(t8, t8.POW, 3),
        rX = eE(t8, t8.POW, 4),
        rQ = eE(t8, t8.TRANSFORM_DIRECTION),
        rK = (e) => tk(rN(e), rH(rv(e), 1 / 3)),
        rY = (e) => r$(e, e),
        rZ = eE(t8, t8.MIX),
        rJ = (e, t = 0, r = 1) => eR(new t8(t8.CLAMP, eR(e), eR(t), eR(r))),
        r0 = (e) => rJ(e),
        r1 = eE(t8, t8.REFRACT),
        r2 = eE(t8, t8.SMOOTHSTEP),
        r3 = eE(t8, t8.FACEFORWARD),
        r4 = eM(([e]) =>
          rm(rf(rV(r$(e.xy, eG(12.9898, 78.233)), re)).mul(43758.5453))
        ),
        r6 = (e, t, r) => rZ(t, r, e),
        r5 = (e, t, r) => r2(t, r, e),
        r8 = (e, t) => (
          console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'),
          r_(e, t)
        );
      J("all", rr),
        J("any", ri),
        J("equals", rP),
        J("radians", rs),
        J("degrees", rn),
        J("exp", ra),
        J("exp2", ro),
        J("log", rl),
        J("log2", ru),
        J("sqrt", rd),
        J("inverseSqrt", rh),
        J("floor", rc),
        J("ceil", rp),
        J("normalize", rg),
        J("fract", rm),
        J("sin", rf),
        J("cos", ry),
        J("tan", rx),
        J("asin", rb),
        J("acos", rT),
        J("atan", r_),
        J("abs", rv),
        J("sign", rN),
        J("length", rS),
        J("lengthSq", rY),
        J("negate", rR),
        J("oneMinus", rA),
        J("dFdx", rC),
        J("dFdy", rE),
        J("round", rw),
        J("reciprocal", rM),
        J("trunc", rB),
        J("fwidth", rF),
        J("atan2", r8),
        J("min", rL),
        J("max", rD),
        J("mod", rV),
        J("step", rO),
        J("reflect", rG),
        J("distance", rk),
        J("dot", r$),
        J("cross", rW),
        J("pow", rH),
        J("pow2", rq),
        J("pow3", rj),
        J("pow4", rX),
        J("transformDirection", rQ),
        J("mix", r6),
        J("clamp", rJ),
        J("refract", r1),
        J("smoothstep", r5),
        J("faceForward", r3),
        J("difference", rz),
        J("saturate", r0),
        J("cbrt", rK),
        J("transpose", rU),
        J("rand", r4);
      class r9 extends V {
        static get type() {
          return "ConditionalNode";
        }
        constructor(e, t, r = null) {
          super(), (this.condNode = e), (this.ifNode = t), (this.elseNode = r);
        }
        getNodeType(e) {
          let { ifNode: t, elseNode: r } = e.getNodeProperties(this);
          if (void 0 === t) return this.setup(e), this.getNodeType(e);
          let i = t.getNodeType(e);
          if (null !== r) {
            let t = r.getNodeType(e);
            if (e.getTypeLength(t) > e.getTypeLength(i)) return t;
          }
          return i;
        }
        setup(e) {
          let t = this.condNode.cache(),
            r = this.ifNode.cache(),
            i = this.elseNode ? this.elseNode.cache() : null,
            s = e.context.nodeBlock;
          (e.getDataFromNode(r).parentNodeBlock = s),
            null !== i && (e.getDataFromNode(i).parentNodeBlock = s);
          let n = e.getNodeProperties(this);
          (n.condNode = t),
            (n.ifNode = r.context({ nodeBlock: r })),
            (n.elseNode = i ? i.context({ nodeBlock: i }) : null);
        }
        generate(e, t) {
          let r = this.getNodeType(e),
            i = e.getDataFromNode(this);
          if (void 0 !== i.nodeProperty) return i.nodeProperty;
          let {
              condNode: s,
              ifNode: n,
              elseNode: a,
            } = e.getNodeProperties(this),
            o = "void" !== t,
            l = o ? ts(r).build(e) : "";
          i.nodeProperty = l;
          let u = s.build(e, "bool");
          e.addFlowCode(
            `
${e.tab}if ( ${u} ) {

`
          ).addFlowTab();
          let d = n.build(e, r);
          if (
            (d && (d = o ? l + " = " + d + ";" : "return " + d + ";"),
            e
              .removeFlowTab()
              .addFlowCode(e.tab + "	" + d + "\n\n" + e.tab + "}"),
            null !== a)
          ) {
            e.addFlowCode(" else {\n\n").addFlowTab();
            let t = a.build(e, r);
            t && (t = o ? l + " = " + t + ";" : "return " + t + ";"),
              e
                .removeFlowTab()
                .addFlowCode(e.tab + "	" + t + "\n\n" + e.tab + "}\n\n");
          } else e.addFlowCode("\n\n");
          return e.format(l, r, t);
        }
      }
      let r7 = eE(r9);
      J("select", r7);
      let ie = (...e) => (
        console.warn(
          "TSL.ConditionalNode: cond() has been renamed to select()."
        ),
        r7(...e)
      );
      J("cond", ie);
      class it extends V {
        static get type() {
          return "ContextNode";
        }
        constructor(e, t = {}) {
          super(), (this.isContextNode = !0), (this.node = e), (this.value = t);
        }
        getScope() {
          return this.node.getScope();
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        analyze(e) {
          this.node.build(e);
        }
        setup(e) {
          let t = e.getContext();
          e.setContext({ ...e.context, ...this.value });
          let r = this.node.build(e);
          return e.setContext(t), r;
        }
        generate(e, t) {
          let r = e.getContext();
          e.setContext({ ...e.context, ...this.value });
          let i = this.node.build(e, t);
          return e.setContext(r), i;
        }
      }
      let ir = eE(it),
        ii = (e, t) => ir(e, { label: t });
      J("context", ir), J("label", ii);
      class is extends V {
        static get type() {
          return "VarNode";
        }
        constructor(e, t = null, r = !1) {
          super(),
            (this.node = e),
            (this.name = t),
            (this.global = !0),
            (this.isVarNode = !0),
            (this.readOnly = r);
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        getMemberType(e, t) {
          return this.node.getMemberType(e, t);
        }
        getElementType(e) {
          return this.node.getElementType(e);
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        generate(e) {
          let { node: t, name: r, readOnly: i } = this,
            { renderer: s } = e,
            n = !0 === s.backend.isWebGPUBackend,
            a = !1,
            o = !1;
          i && ((a = e.isDeterministic(t)), (o = n ? i : a));
          let l = e.getVectorType(this.getNodeType(e)),
            u = t.build(e, l),
            d = e.getVarFromNode(this, r, l, void 0, o),
            h = e.getPropertyName(d),
            c = h;
          if (o)
            if (n) c = a ? `const ${h}` : `let ${h}`;
            else {
              let r = e.getArrayCount(t);
              c = `const ${e.getVar(d.type, h, r)}`;
            }
          return e.addLineFlowCode(`${c} = ${u}`, this), h;
        }
      }
      let ia = eE(is),
        io = (e, t = null) => ia(e, t).append(),
        il = (e, t = null) => ia(e, t, !0).append();
      J("toVar", io), J("toConst", il);
      let iu = (e) => (
        console.warn(
          'TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'
        ),
        ia(e)
      );
      J("temp", iu);
      class id extends V {
        static get type() {
          return "VaryingNode";
        }
        constructor(e, t = null) {
          super(), (this.node = e), (this.name = t), (this.isVaryingNode = !0);
        }
        isGlobal() {
          return !0;
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        setupVarying(e) {
          let t = e.getNodeProperties(this),
            r = t.varying;
          if (void 0 === r) {
            let i = this.name,
              s = this.getNodeType(e);
            (t.varying = r = e.getVaryingFromNode(this, i, s)),
              (t.node = this.node);
          }
          return (
            r.needsInterpolation ||
              (r.needsInterpolation = "fragment" === e.shaderStage),
            r
          );
        }
        setup(e) {
          this.setupVarying(e);
        }
        analyze(e) {
          return this.setupVarying(e), this.node.analyze(e);
        }
        generate(e) {
          let t = e.getNodeProperties(this),
            r = this.setupVarying(e),
            i =
              "fragment" === e.shaderStage &&
              !0 === t.reassignPosition &&
              e.context.needsPositionReassign;
          if (void 0 === t.propertyName || i) {
            let s = this.getNodeType(e),
              n = e.getPropertyName(r, w.VERTEX);
            e.flowNodeFromShaderStage(w.VERTEX, this.node, s, n),
              (t.propertyName = n),
              i
                ? (t.reassignPosition = !1)
                : void 0 === t.reassignPosition &&
                  e.context.isPositionNodeInput &&
                  (t.reassignPosition = !0);
          }
          return e.getPropertyName(r);
        }
      }
      let ih = eE(id),
        ic = (e) => ih(e);
      J("toVarying", ih),
        J("toVertexStage", ic),
        J(
          "varying",
          (...e) => (
            console.warn(
              "TSL.VaryingNode: .varying() has been renamed to .toVarying()."
            ),
            ih(...e)
          )
        ),
        J(
          "vertexStage",
          (...e) => (
            console.warn(
              "TSL.VaryingNode: .vertexStage() has been renamed to .toVertexStage()."
            ),
            ih(...e)
          )
        );
      let ip = eM(([e]) => {
          let t = e.mul(0.9478672986).add(0.0521327014).pow(2.4);
          return rZ(t, e.mul(0.0773993808), e.lessThanEqual(0.04045));
        }).setLayout({
          name: "sRGBTransferEOTF",
          type: "vec3",
          inputs: [{ name: "color", type: "vec3" }],
        }),
        ig = eM(([e]) => {
          let t = e.pow(0.41666).mul(1.055).sub(0.055);
          return rZ(t, e.mul(12.92), e.lessThanEqual(0.0031308));
        }).setLayout({
          name: "sRGBTransferOETF",
          type: "vec3",
          inputs: [{ name: "color", type: "vec3" }],
        }),
        im = "WorkingColorSpace",
        iy = "OutputColorSpace";
      class ix extends k {
        static get type() {
          return "ColorSpaceNode";
        }
        constructor(e, t, r) {
          super("vec4"),
            (this.colorNode = e),
            (this.source = t),
            (this.target = r);
        }
        resolveColorSpace(e, t) {
          return t === im
            ? u.ppV.workingColorSpace
            : t === iy
            ? e.context.outputColorSpace || e.renderer.outputColorSpace
            : t;
        }
        setup(e) {
          let { colorNode: t } = this,
            r = this.resolveColorSpace(e, this.source),
            i = this.resolveColorSpace(e, this.target),
            s = t;
          return (
            !1 !== u.ppV.enabled &&
              r !== i &&
              r &&
              i &&
              (u.ppV.getTransfer(r) === u.KLL && (s = eX(ip(s.rgb), s.a)),
              u.ppV.getPrimaries(r) !== u.ppV.getPrimaries(i) &&
                (s = eX(
                  eJ(u.ppV._getMatrix(new u.dwI(), r, i)).mul(s.rgb),
                  s.a
                )),
              u.ppV.getTransfer(i) === u.KLL && (s = eX(ig(s.rgb), s.a))),
            s
          );
        }
      }
      let ib = (e) => eR(new ix(eR(e), im, iy)),
        iT = (e) => eR(new ix(eR(e), iy, im)),
        i_ = (e, t) => eR(new ix(eR(e), im, t)),
        iv = (e, t) => eR(new ix(eR(e), t, im));
      J("toOutputColorSpace", ib),
        J("toWorkingColorSpace", iT),
        J("workingToColorSpace", i_),
        J("colorSpaceToWorking", iv);
      let iN = class extends O {
        static get type() {
          return "ReferenceElementNode";
        }
        constructor(e, t) {
          super(e, t),
            (this.referenceNode = e),
            (this.isReferenceElementNode = !0);
        }
        getNodeType() {
          return this.referenceNode.uniformType;
        }
        generate(e) {
          let t = super.generate(e),
            r = this.referenceNode.getNodeType(),
            i = this.getNodeType();
          return e.format(t, r, i);
        }
      };
      class iS extends V {
        static get type() {
          return "ReferenceBaseNode";
        }
        constructor(e, t, r = null, i = null) {
          super(),
            (this.property = e),
            (this.uniformType = t),
            (this.object = r),
            (this.count = i),
            (this.properties = e.split(".")),
            (this.reference = r),
            (this.node = null),
            (this.group = null),
            (this.updateType = M.OBJECT);
        }
        setGroup(e) {
          return (this.group = e), this;
        }
        element(e) {
          return eR(new iN(this, eR(e)));
        }
        setNodeType(e) {
          let t = tr(null, e).getSelf();
          null !== this.group && t.setGroup(this.group), (this.node = t);
        }
        getNodeType(e) {
          return (
            null === this.node && (this.updateReference(e), this.updateValue()),
            this.node.getNodeType(e)
          );
        }
        getValueFromReference(e = this.reference) {
          let { properties: t } = this,
            r = e[t[0]];
          for (let e = 1; e < t.length; e++) r = r[t[e]];
          return r;
        }
        updateReference(e) {
          return (
            (this.reference = null !== this.object ? this.object : e.object),
            this.reference
          );
        }
        setup() {
          return this.updateValue(), this.node;
        }
        update() {
          this.updateValue();
        }
        updateValue() {
          null === this.node && this.setNodeType(this.uniformType);
          let e = this.getValueFromReference();
          Array.isArray(e) ? (this.node.array = e) : (this.node.value = e);
        }
      }
      let iR = (e, t, r) => eR(new iS(e, t, r));
      class iA extends iS {
        static get type() {
          return "RendererReferenceNode";
        }
        constructor(e, t, r = null) {
          super(e, t, r), (this.renderer = r), this.setGroup(e7);
        }
        updateReference(e) {
          return (
            (this.reference =
              null !== this.renderer ? this.renderer : e.renderer),
            this.reference
          );
        }
      }
      let iC = (e, t, r = null) => eR(new iA(e, t, r));
      class iE extends k {
        static get type() {
          return "ToneMappingNode";
        }
        constructor(e, t = iM, r = null) {
          super("vec3"),
            (this.toneMapping = e),
            (this.exposureNode = t),
            (this.colorNode = r);
        }
        customCacheKey() {
          return m(this.toneMapping);
        }
        setup(e) {
          let t = this.colorNode || e.context.color,
            r = this.toneMapping;
          if (r === u.y_p) return t;
          let i = null,
            s = e.renderer.library.getToneMappingFunction(r);
          return (
            null !== s
              ? (i = eX(s(t.rgb, this.exposureNode), t.a))
              : (console.error(
                  "ToneMappingNode: Unsupported Tone Mapping configuration.",
                  r
                ),
                (i = t)),
            i
          );
        }
      }
      let iw = (e, t, r) => eR(new iE(e, eR(t), eR(r))),
        iM = iC("toneMappingExposure", "float");
      J("toneMapping", (e, t, r) => iw(t, r, e));
      class iB extends j {
        static get type() {
          return "BufferAttributeNode";
        }
        constructor(e, t = null, r = 0, i = 0) {
          super(e, t),
            (this.isBufferNode = !0),
            (this.bufferType = t),
            (this.bufferStride = r),
            (this.bufferOffset = i),
            (this.usage = u.agE),
            (this.instanced = !1),
            (this.attribute = null),
            (this.global = !0),
            e &&
              !0 === e.isBufferAttribute &&
              ((this.attribute = e),
              (this.usage = e.usage),
              (this.instanced = e.isInstancedBufferAttribute));
        }
        getHash(e) {
          if (0 === this.bufferStride && 0 === this.bufferOffset) {
            let t = e.globalCache.getData(this.value);
            return (
              void 0 === t &&
                ((t = { node: this }), e.globalCache.setData(this.value, t)),
              t.node.uuid
            );
          }
          return this.uuid;
        }
        getNodeType(e) {
          return (
            null === this.bufferType &&
              (this.bufferType = e.getTypeFromAttribute(this.attribute)),
            this.bufferType
          );
        }
        setup(e) {
          if (null !== this.attribute) return;
          let t = this.getNodeType(e),
            r = this.value,
            i = e.getTypeLength(t),
            s = this.bufferStride || i,
            n = this.bufferOffset,
            a = !0 === r.isInterleavedBuffer ? r : new u.eB$(r, s),
            o = new u.eHs(a, i, n);
          a.setUsage(this.usage),
            (this.attribute = o),
            (this.attribute.isInstancedBufferAttribute = this.instanced);
        }
        generate(e) {
          let t = this.getNodeType(e),
            r = e.getBufferAttributeFromNode(this, t),
            i = e.getPropertyName(r),
            s = null;
          return (
            "vertex" === e.shaderStage || "compute" === e.shaderStage
              ? ((this.name = i), (s = i))
              : (s = ih(this).build(e, t)),
            s
          );
        }
        getInputType() {
          return "bufferAttribute";
        }
        setUsage(e) {
          return (
            (this.usage = e),
            this.attribute &&
              !0 === this.attribute.isBufferAttribute &&
              (this.attribute.usage = e),
            this
          );
        }
        setInstanced(e) {
          return (this.instanced = e), this;
        }
      }
      let iF = (e, t = null, r = 0, i = 0) => eR(new iB(e, t, r, i)),
        iU = (e, t = null, r = 0, i = 0) => iF(e, t, r, i).setUsage(u.Vnu),
        iI = (e, t = null, r = 0, i = 0) => iF(e, t, r, i).setInstanced(!0),
        iP = (e, t = null, r = 0, i = 0) => iU(e, t, r, i).setInstanced(!0);
      J("toAttribute", (e) => iF(e.value));
      class iL extends V {
        static get type() {
          return "ComputeNode";
        }
        constructor(e, t, r = [64]) {
          super("void"),
            (this.isComputeNode = !0),
            (this.computeNode = e),
            (this.count = t),
            (this.workgroupSize = r),
            (this.dispatchCount = 0),
            (this.version = 1),
            (this.name = ""),
            (this.updateBeforeType = M.OBJECT),
            (this.onInitFunction = null),
            this.updateDispatchCount();
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        label(e) {
          return (this.name = e), this;
        }
        updateDispatchCount() {
          let { count: e, workgroupSize: t } = this,
            r = t[0];
          for (let e = 1; e < t.length; e++) r *= t[e];
          this.dispatchCount = Math.ceil(e / r);
        }
        onInit(e) {
          return (this.onInitFunction = e), this;
        }
        updateBefore({ renderer: e }) {
          e.compute(this);
        }
        generate(e) {
          let { shaderStage: t } = e;
          if ("compute" === t) {
            let t = this.computeNode.build(e, "void");
            "" !== t && e.addLineFlowCode(t, this);
          }
        }
      }
      let iD = (e, t, r) => eR(new iL(eR(e), t, r));
      J("compute", iD);
      class iV extends V {
        static get type() {
          return "CacheNode";
        }
        constructor(e, t = !0) {
          super(), (this.node = e), (this.parent = t), (this.isCacheNode = !0);
        }
        getNodeType(e) {
          let t = e.getCache(),
            r = e.getCacheFromNode(this, this.parent);
          e.setCache(r);
          let i = this.node.getNodeType(e);
          return e.setCache(t), i;
        }
        build(e, ...t) {
          let r = e.getCache(),
            i = e.getCacheFromNode(this, this.parent);
          e.setCache(i);
          let s = this.node.build(e, ...t);
          return e.setCache(r), s;
        }
      }
      let iO = (e, t) => eR(new iV(eR(e), t));
      J("cache", iO);
      class iG extends V {
        static get type() {
          return "BypassNode";
        }
        constructor(e, t) {
          super(),
            (this.isBypassNode = !0),
            (this.outputNode = e),
            (this.callNode = t);
        }
        getNodeType(e) {
          return this.outputNode.getNodeType(e);
        }
        generate(e) {
          let t = this.callNode.build(e, "void");
          return (
            "" !== t && e.addLineFlowCode(t, this), this.outputNode.build(e)
          );
        }
      }
      let ik = eE(iG);
      J("bypass", ik);
      class iz extends V {
        static get type() {
          return "RemapNode";
        }
        constructor(e, t, r, i = eL(0), s = eL(1)) {
          super(),
            (this.node = e),
            (this.inLowNode = t),
            (this.inHighNode = r),
            (this.outLowNode = i),
            (this.outHighNode = s),
            (this.doClamp = !0);
        }
        setup() {
          let {
              node: e,
              inLowNode: t,
              inHighNode: r,
              outLowNode: i,
              outHighNode: s,
              doClamp: n,
            } = this,
            a = e.sub(t).div(r.sub(t));
          return !0 === n && (a = a.clamp()), a.mul(s.sub(i)).add(i);
        }
      }
      let i$ = eE(iz, null, null, { doClamp: !1 }),
        iW = eE(iz);
      J("remap", i$), J("remapClamp", iW);
      class iH extends V {
        static get type() {
          return "ExpressionNode";
        }
        constructor(e = "", t = "void") {
          super(t), (this.snippet = e);
        }
        generate(e, t) {
          let r = this.getNodeType(e),
            i = this.snippet;
          if ("void" !== r) return e.format(`( ${i} )`, r, t);
          e.addLineFlowCode(i, this);
        }
      }
      let iq = eE(iH),
        ij = (e) => (e ? r7(e, iq("discard")) : iq("discard")).append();
      J("discard", ij);
      class iX extends k {
        static get type() {
          return "RenderOutputNode";
        }
        constructor(e, t, r) {
          super("vec4"),
            (this.colorNode = e),
            (this.toneMapping = t),
            (this.outputColorSpace = r),
            (this.isRenderOutputNode = !0);
        }
        setup({ context: e }) {
          let t = this.colorNode || e.color,
            r =
              (null !== this.toneMapping ? this.toneMapping : e.toneMapping) ||
              u.y_p,
            i =
              (null !== this.outputColorSpace
                ? this.outputColorSpace
                : e.outputColorSpace) || u.jf0;
          return (
            r !== u.y_p && (t = t.toneMapping(r)),
            i !== u.jf0 &&
              i !== u.ppV.workingColorSpace &&
              (t = t.workingToColorSpace(i)),
            t
          );
        }
      }
      let iQ = (e, t = null, r = null) => eR(new iX(eR(e), t, r));
      J("renderOutput", iQ);
      class iK extends V {
        static get type() {
          return "AttributeNode";
        }
        constructor(e, t = null) {
          super(t), (this.global = !0), (this._attributeName = e);
        }
        getHash(e) {
          return this.getAttributeName(e);
        }
        getNodeType(e) {
          let t = this.nodeType;
          if (null === t) {
            let r = this.getAttributeName(e);
            if (e.hasGeometryAttribute(r)) {
              let i = e.geometry.getAttribute(r);
              t = e.getTypeFromAttribute(i);
            } else t = "float";
          }
          return t;
        }
        setAttributeName(e) {
          return (this._attributeName = e), this;
        }
        getAttributeName() {
          return this._attributeName;
        }
        generate(e) {
          let t = this.getAttributeName(e),
            r = this.getNodeType(e);
          if (!0 !== e.hasGeometryAttribute(t))
            return (
              console.warn(
                `AttributeNode: Vertex attribute "${t}" not found on geometry.`
              ),
              e.generateConst(r)
            );
          {
            let i = e.geometry.getAttribute(t),
              s = e.getTypeFromAttribute(i),
              n = e.getAttribute(t, s);
            return "vertex" === e.shaderStage
              ? e.format(n.name, s, r)
              : ih(this).build(e, r);
          }
        }
        serialize(e) {
          super.serialize(e),
            (e.global = this.global),
            (e._attributeName = this._attributeName);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.global = e.global),
            (this._attributeName = e._attributeName);
        }
      }
      let iY = (e, t) => eR(new iK(e, t)),
        iZ = (e = 0) => iY("uv" + (e > 0 ? e : ""), "vec2");
      class iJ extends V {
        static get type() {
          return "TextureSizeNode";
        }
        constructor(e, t = null) {
          super("uvec2"),
            (this.isTextureSizeNode = !0),
            (this.textureNode = e),
            (this.levelNode = t);
        }
        generate(e, t) {
          let r = this.textureNode.build(e, "property"),
            i = null === this.levelNode ? "0" : this.levelNode.build(e, "int");
          return e.format(
            `${e.getMethod("textureDimensions")}( ${r}, ${i} )`,
            this.getNodeType(e),
            t
          );
        }
      }
      let i0 = eE(iJ);
      class i1 extends tt {
        static get type() {
          return "MaxMipLevelNode";
        }
        constructor(e) {
          super(0), (this._textureNode = e), (this.updateType = M.FRAME);
        }
        get textureNode() {
          return this._textureNode;
        }
        get texture() {
          return this._textureNode.value;
        }
        update() {
          let e = this.texture,
            t = e.images,
            r = t && t.length > 0 ? (t[0] && t[0].image) || t[0] : e.image;
          if (r && void 0 !== r.width) {
            let { width: e, height: t } = r;
            this.value = Math.log2(Math.max(e, t));
          }
        }
      }
      let i2 = eE(i1);
      class i3 extends tt {
        static get type() {
          return "TextureNode";
        }
        constructor(e, t = null, r = null, i = null) {
          super(e),
            (this.isTextureNode = !0),
            (this.uvNode = t),
            (this.levelNode = r),
            (this.biasNode = i),
            (this.compareNode = null),
            (this.depthNode = null),
            (this.gradNode = null),
            (this.sampler = !0),
            (this.updateMatrix = !1),
            (this.updateType = M.NONE),
            (this.referenceNode = null),
            (this._value = e),
            (this._matrixUniform = null),
            this.setUpdateMatrix(null === t);
        }
        set value(e) {
          this.referenceNode
            ? (this.referenceNode.value = e)
            : (this._value = e);
        }
        get value() {
          return this.referenceNode ? this.referenceNode.value : this._value;
        }
        getUniformHash() {
          return this.value.uuid;
        }
        getNodeType() {
          return !0 === this.value.isDepthTexture
            ? "float"
            : this.value.type === u.bkx
            ? "uvec4"
            : this.value.type === u.Yuy
            ? "ivec4"
            : "vec4";
        }
        getInputType() {
          return "texture";
        }
        getDefaultUV() {
          return iZ(this.value.channel);
        }
        updateReference() {
          return this.value;
        }
        getTransformedUV(e) {
          return (
            null === this._matrixUniform &&
              (this._matrixUniform = tr(this.value.matrix)),
            this._matrixUniform.mul(eW(e, 1)).xy
          );
        }
        setUpdateMatrix(e) {
          return (
            (this.updateMatrix = e),
            (this.updateType = e ? M.RENDER : M.NONE),
            this
          );
        }
        setupUV(e, t) {
          let r = this.value;
          return (
            e.isFlipY() &&
              ((r.image instanceof ImageBitmap && !0 === r.flipY) ||
                !0 === r.isRenderTargetTexture ||
                !0 === r.isFramebufferTexture ||
                !0 === r.isDepthTexture) &&
              (t = this.sampler
                ? t.flipY()
                : t.setY(eD(i0(this, this.levelNode).y).sub(t.y).sub(1))),
            t
          );
        }
        setup(e) {
          let t = e.getNodeProperties(this);
          t.referenceNode = this.referenceNode;
          let r = this.value;
          if (!r || !0 !== r.isTexture)
            throw Error(
              "THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture()."
            );
          let i = this.uvNode;
          (null === i || !0 === e.context.forceUVContext) &&
            e.context.getUV &&
            (i = e.context.getUV(this)),
            i || (i = this.getDefaultUV()),
            !0 === this.updateMatrix && (i = this.getTransformedUV(i)),
            (i = this.setupUV(e, i));
          let s = this.levelNode;
          null === s &&
            e.context.getTextureLevel &&
            (s = e.context.getTextureLevel(this)),
            (t.uvNode = i),
            (t.levelNode = s),
            (t.biasNode = this.biasNode),
            (t.compareNode = this.compareNode),
            (t.gradNode = this.gradNode),
            (t.depthNode = this.depthNode);
        }
        generateUV(e, t) {
          return t.build(e, !0 === this.sampler ? "vec2" : "ivec2");
        }
        generateSnippet(e, t, r, i, s, n, a, o) {
          let l,
            u = this.value;
          return i
            ? e.generateTextureLevel(u, t, r, i, n)
            : s
            ? e.generateTextureBias(u, t, r, s, n)
            : o
            ? e.generateTextureGrad(u, t, r, o, n)
            : a
            ? e.generateTextureCompare(u, t, r, a, n)
            : !1 === this.sampler
            ? e.generateTextureLoad(u, t, r, n)
            : e.generateTexture(u, t, r, n);
        }
        generate(e, t) {
          let r = this.value,
            i = e.getNodeProperties(this),
            s = super.generate(e, "property");
          if ("sampler" === t) return s + "_sampler";
          {
            if (e.isReference(t)) return s;
            let n = e.getDataFromNode(this),
              a = n.propertyName;
            if (void 0 === a) {
              let {
                  uvNode: t,
                  levelNode: r,
                  biasNode: o,
                  compareNode: l,
                  depthNode: u,
                  gradNode: d,
                } = i,
                h = this.generateUV(e, t),
                c = r ? r.build(e, "float") : null,
                p = o ? o.build(e, "float") : null,
                g = u ? u.build(e, "int") : null,
                m = l ? l.build(e, "float") : null,
                f = d ? [d[0].build(e, "vec2"), d[1].build(e, "vec2")] : null,
                y = e.getVarFromNode(this);
              a = e.getPropertyName(y);
              let x = this.generateSnippet(e, s, h, c, p, g, m, f);
              e.addLineFlowCode(`${a} = ${x}`, this),
                (n.snippet = x),
                (n.propertyName = a);
            }
            let o = a,
              l = this.getNodeType(e);
            return (
              e.needsToWorkingColorSpace(r) &&
                (o = iv(iq(o, l), r.colorSpace).setup(e).build(e, l)),
              e.format(o, l, t)
            );
          }
        }
        setSampler(e) {
          return (this.sampler = e), this;
        }
        getSampler() {
          return this.sampler;
        }
        uv(e) {
          return (
            console.warn(
              "THREE.TextureNode: .uv() has been renamed. Use .sample() instead."
            ),
            this.sample(e)
          );
        }
        sample(e) {
          let t = this.clone();
          return (t.uvNode = eR(e)), (t.referenceNode = this.getSelf()), eR(t);
        }
        blur(e) {
          let t = this.clone();
          return (
            (t.biasNode = eR(e).mul(i2(t))),
            (t.referenceNode = this.getSelf()),
            eR(t)
          );
        }
        level(e) {
          let t = this.clone();
          return (
            (t.levelNode = eR(e)), (t.referenceNode = this.getSelf()), eR(t)
          );
        }
        size(e) {
          return i0(this, e);
        }
        bias(e) {
          let t = this.clone();
          return (
            (t.biasNode = eR(e)), (t.referenceNode = this.getSelf()), eR(t)
          );
        }
        compare(e) {
          let t = this.clone();
          return (
            (t.compareNode = eR(e)), (t.referenceNode = this.getSelf()), eR(t)
          );
        }
        grad(e, t) {
          let r = this.clone();
          return (
            (r.gradNode = [eR(e), eR(t)]),
            (r.referenceNode = this.getSelf()),
            eR(r)
          );
        }
        depth(e) {
          let t = this.clone();
          return (
            (t.depthNode = eR(e)), (t.referenceNode = this.getSelf()), eR(t)
          );
        }
        serialize(e) {
          super.serialize(e),
            (e.value = this.value.toJSON(e.meta).uuid),
            (e.sampler = this.sampler),
            (e.updateMatrix = this.updateMatrix),
            (e.updateType = this.updateType);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.value = e.meta.textures[e.value]),
            (this.sampler = e.sampler),
            (this.updateMatrix = e.updateMatrix),
            (this.updateType = e.updateType);
        }
        update() {
          let e = this.value,
            t = this._matrixUniform;
          null !== t && (t.value = e.matrix),
            !0 === e.matrixAutoUpdate && e.updateMatrix();
        }
        clone() {
          let e = new this.constructor(
            this.value,
            this.uvNode,
            this.levelNode,
            this.biasNode
          );
          return (e.sampler = this.sampler), e;
        }
      }
      let i4 = eE(i3),
        i6 = (...e) => i4(...e).setSampler(!1);
      class i5 extends tt {
        static get type() {
          return "BufferNode";
        }
        constructor(e, t, r = 0) {
          super(e, t),
            (this.isBufferNode = !0),
            (this.bufferType = t),
            (this.bufferCount = r);
        }
        getElementType(e) {
          return this.getNodeType(e);
        }
        getInputType() {
          return "buffer";
        }
      }
      let i8 = (e, t, r) => eR(new i5(e, t, r));
      class i9 extends O {
        static get type() {
          return "UniformArrayElementNode";
        }
        constructor(e, t) {
          super(e, t), (this.isArrayBufferElementNode = !0);
        }
        generate(e) {
          let t = super.generate(e),
            r = this.getNodeType(),
            i = this.node.getPaddedType();
          return e.format(t, i, r);
        }
      }
      class i7 extends i5 {
        static get type() {
          return "UniformArrayNode";
        }
        constructor(e, t = null) {
          super(null),
            (this.array = e),
            (this.elementType = null === t ? N(e[0]) : t),
            (this.paddedType = this.getPaddedType()),
            (this.updateType = M.RENDER),
            (this.isArrayBufferNode = !0);
        }
        getNodeType() {
          return this.paddedType;
        }
        getElementType() {
          return this.elementType;
        }
        getPaddedType() {
          let e = this.elementType,
            t = "vec4";
          return (
            "mat2" === e
              ? (t = "mat2")
              : !0 === /mat/.test(e)
              ? (t = "mat4")
              : "i" === e.charAt(0)
              ? (t = "ivec4")
              : "u" === e.charAt(0) && (t = "uvec4"),
            t
          );
        }
        update() {
          let { array: e, value: t } = this,
            r = this.elementType;
          if ("float" === r || "int" === r || "uint" === r)
            for (let r = 0; r < e.length; r++) t[4 * r] = e[r];
          else if ("color" === r)
            for (let r = 0; r < e.length; r++) {
              let i = 4 * r,
                s = e[r];
              (t[i] = s.r), (t[i + 1] = s.g), (t[i + 2] = s.b || 0);
            }
          else if ("mat2" === r)
            for (let r = 0; r < e.length; r++) {
              let i = 4 * r,
                s = e[r];
              (t[i] = s.elements[0]),
                (t[i + 1] = s.elements[1]),
                (t[i + 2] = s.elements[2]),
                (t[i + 3] = s.elements[3]);
            }
          else if ("mat3" === r)
            for (let r = 0; r < e.length; r++) {
              let i = 16 * r,
                s = e[r];
              (t[i] = s.elements[0]),
                (t[i + 1] = s.elements[1]),
                (t[i + 2] = s.elements[2]),
                (t[i + 4] = s.elements[3]),
                (t[i + 5] = s.elements[4]),
                (t[i + 6] = s.elements[5]),
                (t[i + 8] = s.elements[6]),
                (t[i + 9] = s.elements[7]),
                (t[i + 10] = s.elements[8]),
                (t[i + 15] = 1);
            }
          else if ("mat4" === r)
            for (let r = 0; r < e.length; r++) {
              let i = 16 * r,
                s = e[r];
              for (let e = 0; e < s.elements.length; e++)
                t[i + e] = s.elements[e];
            }
          else
            for (let r = 0; r < e.length; r++) {
              let i = 4 * r,
                s = e[r];
              (t[i] = s.x),
                (t[i + 1] = s.y),
                (t[i + 2] = s.z || 0),
                (t[i + 3] = s.w || 0);
            }
        }
        setup(e) {
          let t = this.array.length,
            r = this.elementType,
            i = Float32Array,
            s = this.paddedType,
            n = e.getTypeLength(s);
          return (
            "i" === r.charAt(0) && (i = Int32Array),
            "u" === r.charAt(0) && (i = Uint32Array),
            (this.value = new i(t * n)),
            (this.bufferCount = t),
            (this.bufferType = s),
            super.setup(e)
          );
        }
        element(e) {
          return eR(new i9(this, eR(e)));
        }
      }
      let se = (e, t) => eR(new i7(e, t)),
        st = tr(0, "uint")
          .setGroup(e8("cameraIndex"))
          .toVarying("v_cameraIndex"),
        sr = tr("float")
          .label("cameraNear")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }) => e.near),
        si = tr("float")
          .label("cameraFar")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }) => e.far),
        ss = eM(({ camera: e }) => {
          let t;
          if (e.isArrayCamera && e.cameras.length > 0) {
            let r = [];
            for (let t of e.cameras) r.push(t.projectionMatrix);
            t = se(r)
              .setGroup(e7)
              .label("cameraProjectionMatrices")
              .element(st)
              .toVar("cameraProjectionMatrix");
          } else
            t = tr("mat4")
              .label("cameraProjectionMatrix")
              .setGroup(e7)
              .onRenderUpdate(({ camera: e }) => e.projectionMatrix);
          return t;
        }).once()(),
        sn = tr("mat4")
          .label("cameraProjectionMatrixInverse")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }) => e.projectionMatrixInverse),
        sa = eM(({ camera: e }) => {
          let t;
          if (e.isArrayCamera && e.cameras.length > 0) {
            let r = [];
            for (let t of e.cameras) r.push(t.matrixWorldInverse);
            t = se(r)
              .setGroup(e7)
              .label("cameraViewMatrices")
              .element(st)
              .toVar("cameraViewMatrix");
          } else
            t = tr("mat4")
              .label("cameraViewMatrix")
              .setGroup(e7)
              .onRenderUpdate(({ camera: e }) => e.matrixWorldInverse);
          return t;
        }).once()(),
        so = tr("mat4")
          .label("cameraWorldMatrix")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }) => e.matrixWorld),
        sl = tr("mat3")
          .label("cameraNormalMatrix")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }) => e.normalMatrix),
        su = tr(new u.Pq0())
          .label("cameraPosition")
          .setGroup(e7)
          .onRenderUpdate(({ camera: e }, t) =>
            t.value.setFromMatrixPosition(e.matrixWorld)
          ),
        sd = new u.iyt();
      class sh extends V {
        static get type() {
          return "Object3DNode";
        }
        constructor(e, t = null) {
          super(),
            (this.scope = e),
            (this.object3d = t),
            (this.updateType = M.OBJECT),
            (this._uniformNode = new tt(null));
        }
        getNodeType() {
          let e = this.scope;
          return e === sh.WORLD_MATRIX
            ? "mat4"
            : e === sh.POSITION ||
              e === sh.VIEW_POSITION ||
              e === sh.DIRECTION ||
              e === sh.SCALE
            ? "vec3"
            : e === sh.RADIUS
            ? "float"
            : void 0;
        }
        update(e) {
          let t = this.object3d,
            r = this._uniformNode,
            i = this.scope;
          if (i === sh.WORLD_MATRIX) r.value = t.matrixWorld;
          else if (i === sh.POSITION)
            (r.value = r.value || new u.Pq0()),
              r.value.setFromMatrixPosition(t.matrixWorld);
          else if (i === sh.SCALE)
            (r.value = r.value || new u.Pq0()),
              r.value.setFromMatrixScale(t.matrixWorld);
          else if (i === sh.DIRECTION)
            (r.value = r.value || new u.Pq0()), t.getWorldDirection(r.value);
          else if (i === sh.VIEW_POSITION) {
            let i = e.camera;
            (r.value = r.value || new u.Pq0()),
              r.value.setFromMatrixPosition(t.matrixWorld),
              r.value.applyMatrix4(i.matrixWorldInverse);
          } else if (i === sh.RADIUS) {
            let i = e.object.geometry;
            null === i.boundingSphere && i.computeBoundingSphere(),
              sd.copy(i.boundingSphere).applyMatrix4(t.matrixWorld),
              (r.value = sd.radius);
          }
        }
        generate(e) {
          let t = this.scope;
          return (
            t === sh.WORLD_MATRIX
              ? (this._uniformNode.nodeType = "mat4")
              : t === sh.POSITION ||
                t === sh.VIEW_POSITION ||
                t === sh.DIRECTION ||
                t === sh.SCALE
              ? (this._uniformNode.nodeType = "vec3")
              : t === sh.RADIUS && (this._uniformNode.nodeType = "float"),
            this._uniformNode.build(e)
          );
        }
        serialize(e) {
          super.serialize(e), (e.scope = this.scope);
        }
        deserialize(e) {
          super.deserialize(e), (this.scope = e.scope);
        }
      }
      (sh.WORLD_MATRIX = "worldMatrix"),
        (sh.POSITION = "position"),
        (sh.SCALE = "scale"),
        (sh.VIEW_POSITION = "viewPosition"),
        (sh.DIRECTION = "direction"),
        (sh.RADIUS = "radius");
      let sc = eE(sh, sh.DIRECTION),
        sp = eE(sh, sh.WORLD_MATRIX),
        sg = eE(sh, sh.POSITION),
        sm = eE(sh, sh.SCALE),
        sf = eE(sh, sh.VIEW_POSITION),
        sy = eE(sh, sh.RADIUS);
      class sx extends sh {
        static get type() {
          return "ModelNode";
        }
        constructor(e) {
          super(e);
        }
        update(e) {
          (this.object3d = e.object), super.update(e);
        }
      }
      let sb = ew(sx, sx.DIRECTION),
        sT = ew(sx, sx.WORLD_MATRIX),
        s_ = ew(sx, sx.POSITION),
        sv = ew(sx, sx.SCALE),
        sN = ew(sx, sx.VIEW_POSITION),
        sS = ew(sx, sx.RADIUS),
        sR = tr(new u.dwI()).onObjectUpdate(({ object: e }, t) =>
          t.value.getNormalMatrix(e.matrixWorld)
        ),
        sA = tr(new u.kn4()).onObjectUpdate(({ object: e }, t) =>
          t.value.copy(e.matrixWorld).invert()
        ),
        sC = eM((e) => e.renderer.nodes.modelViewMatrix || sE)
          .once()()
          .toVar("modelViewMatrix"),
        sE = sa.mul(sT),
        sw = eM(
          (e) => (
            (e.context.isHighPrecisionModelViewMatrix = !0),
            tr("mat4").onObjectUpdate(({ object: e, camera: t }) =>
              e.modelViewMatrix.multiplyMatrices(
                t.matrixWorldInverse,
                e.matrixWorld
              )
            )
          )
        )
          .once()()
          .toVar("highpModelViewMatrix"),
        sM = eM((e) => {
          let t = e.context.isHighPrecisionModelViewMatrix;
          return tr("mat3").onObjectUpdate(
            ({ object: e, camera: r }) => (
              !0 !== t &&
                e.modelViewMatrix.multiplyMatrices(
                  r.matrixWorldInverse,
                  e.matrixWorld
                ),
              e.normalMatrix.getNormalMatrix(e.modelViewMatrix)
            )
          );
        })
          .once()()
          .toVar("highpModelNormalViewMatrix"),
        sB = iY("position", "vec3"),
        sF = sB.toVarying("positionLocal"),
        sU = sB.toVarying("positionPrevious"),
        sI = sT
          .mul(sF)
          .xyz.toVarying("v_positionWorld")
          .context({ needsPositionReassign: !0 }),
        sP = sF
          .transformDirection(sT)
          .toVarying("v_positionWorldDirection")
          .normalize()
          .toVar("positionWorldDirection")
          .context({ needsPositionReassign: !0 }),
        sL = eM((e) => e.context.setupPositionView(), "vec3")
          .once()()
          .toVarying("v_positionView")
          .context({ needsPositionReassign: !0 }),
        sD = sL
          .negate()
          .toVarying("v_positionViewDirection")
          .normalize()
          .toVar("positionViewDirection");
      class sV extends V {
        static get type() {
          return "FrontFacingNode";
        }
        constructor() {
          super("bool"), (this.isFrontFacingNode = !0);
        }
        generate(e) {
          let { renderer: t, material: r } = e;
          return t.coordinateSystem === u.TdN && r.side === u.hsX
            ? "false"
            : e.getFrontFacing();
        }
      }
      let sO = ew(sV),
        sG = eL(sO).mul(2).sub(1),
        sk = iY("normal", "vec3"),
        sz = eM(
          (e) =>
            !1 === e.geometry.hasAttribute("normal")
              ? (console.warn(
                  'TSL.NormalNode: Vertex attribute "normal" not found on geometry.'
                ),
                eW(0, 1, 0))
              : sk,
          "vec3"
        )
          .once()()
          .toVar("normalLocal"),
        s$ = sL.dFdx().cross(sL.dFdy()).normalize().toVar("normalFlat"),
        sW = eM((e) => {
          let t;
          return !0 === e.material.flatShading
            ? s$
            : ih(sK(sz), "v_normalView").normalize();
        }, "vec3")
          .once()()
          .toVar("normalView"),
        sH = ih(sW.transformDirection(sa), "v_normalWorld")
          .normalize()
          .toVar("normalWorld"),
        sq = eM((e) => e.context.setupNormal().context({ getUV: null }), "vec3")
          .once()()
          .mul(sG)
          .toVar("transformedNormalView"),
        sj = sq.transformDirection(sa).toVar("transformedNormalWorld"),
        sX = eM(
          (e) => e.context.setupClearcoatNormal().context({ getUV: null }),
          "vec3"
        )
          .once()()
          .mul(sG)
          .toVar("transformedClearcoatNormalView"),
        sQ = eM(([e, t = sT]) => {
          let r = eJ(t),
            i = e.div(eW(r[0].dot(r[0]), r[1].dot(r[1]), r[2].dot(r[2])));
          return r.mul(i).xyz;
        }),
        sK = eM(([e], t) => {
          let r = t.renderer.nodes.modelNormalViewMatrix;
          if (null !== r) return r.transformDirection(e);
          let i = sR.mul(e);
          return sa.transformDirection(i);
        }),
        sY = new u.O9p(),
        sZ = new u.kn4(),
        sJ = tr(0)
          .onReference(({ material: e }) => e)
          .onObjectUpdate(({ material: e }) => e.refractionRatio),
        s0 = tr(1)
          .onReference(({ material: e }) => e)
          .onObjectUpdate(function ({ material: e, scene: t }) {
            return e.envMap ? e.envMapIntensity : t.environmentIntensity;
          }),
        s1 = tr(new u.kn4())
          .onReference(function (e) {
            return e.material;
          })
          .onObjectUpdate(function ({ material: e, scene: t }) {
            let r =
              null !== t.environment && null === e.envMap
                ? t.environmentRotation
                : e.envMapRotation;
            return (
              r ? (sY.copy(r), sZ.makeRotationFromEuler(sY)) : sZ.identity(), sZ
            );
          }),
        s2 = sD.negate().reflect(sq),
        s3 = sD.negate().refract(sq, sJ),
        s4 = s2.transformDirection(sa).toVar("reflectVector"),
        s6 = s3.transformDirection(sa).toVar("reflectVector");
      class s5 extends i3 {
        static get type() {
          return "CubeTextureNode";
        }
        constructor(e, t = null, r = null, i = null) {
          super(e, t, r, i), (this.isCubeTextureNode = !0);
        }
        getInputType() {
          return "cubeTexture";
        }
        getDefaultUV() {
          let e = this.value;
          return e.mapping === u.hy7
            ? s4
            : e.mapping === u.xFO
            ? s6
            : (console.error(
                'THREE.CubeTextureNode: Mapping "%s" not supported.',
                e.mapping
              ),
              eW(0, 0, 0));
        }
        setUpdateMatrix() {}
        setupUV(e, t) {
          let r = this.value;
          return (
            (e.renderer.coordinateSystem !== u.i7u &&
              r.isRenderTargetTexture) ||
              (t = eW(t.x.negate(), t.yz)),
            s1.mul(t)
          );
        }
        generateUV(e, t) {
          return t.build(e, "vec3");
        }
      }
      let s8 = eE(s5);
      class s9 extends O {
        static get type() {
          return "ReferenceElementNode";
        }
        constructor(e, t) {
          super(e, t),
            (this.referenceNode = e),
            (this.isReferenceElementNode = !0);
        }
        getNodeType() {
          return this.referenceNode.uniformType;
        }
        generate(e) {
          let t = super.generate(e),
            r = this.referenceNode.getNodeType(),
            i = this.getNodeType();
          return e.format(t, r, i);
        }
      }
      class s7 extends V {
        static get type() {
          return "ReferenceNode";
        }
        constructor(e, t, r = null, i = null) {
          super(),
            (this.property = e),
            (this.uniformType = t),
            (this.object = r),
            (this.count = i),
            (this.properties = e.split(".")),
            (this.reference = r),
            (this.node = null),
            (this.group = null),
            (this.name = null),
            (this.updateType = M.OBJECT);
        }
        element(e) {
          return eR(new s9(this, eR(e)));
        }
        setGroup(e) {
          return (this.group = e), this;
        }
        label(e) {
          return (this.name = e), this;
        }
        setNodeType(e) {
          let t = null;
          (t =
            null !== this.count
              ? i8(null, e, this.count)
              : Array.isArray(this.getValueFromReference())
              ? se(null, e)
              : "texture" === e
              ? i4(null)
              : "cubeTexture" === e
              ? s8(null)
              : tr(null, e)),
            null !== this.group && t.setGroup(this.group),
            null !== this.name && t.label(this.name),
            (this.node = t.getSelf());
        }
        getNodeType(e) {
          return (
            null === this.node && (this.updateReference(e), this.updateValue()),
            this.node.getNodeType(e)
          );
        }
        getValueFromReference(e = this.reference) {
          let { properties: t } = this,
            r = e[t[0]];
          for (let e = 1; e < t.length; e++) r = r[t[e]];
          return r;
        }
        updateReference(e) {
          return (
            (this.reference = null !== this.object ? this.object : e.object),
            this.reference
          );
        }
        setup() {
          return this.updateValue(), this.node;
        }
        update() {
          this.updateValue();
        }
        updateValue() {
          null === this.node && this.setNodeType(this.uniformType);
          let e = this.getValueFromReference();
          Array.isArray(e) ? (this.node.array = e) : (this.node.value = e);
        }
      }
      let ne = (e, t, r) => eR(new s7(e, t, r)),
        nt = (e, t, r, i) => eR(new s7(e, t, i, r));
      class nr extends s7 {
        static get type() {
          return "MaterialReferenceNode";
        }
        constructor(e, t, r = null) {
          super(e, t, r),
            (this.material = r),
            (this.isMaterialReferenceNode = !0);
        }
        updateReference(e) {
          return (
            (this.reference =
              null !== this.material ? this.material : e.material),
            this.reference
          );
        }
      }
      let ni = (e, t, r = null) => eR(new nr(e, t, r)),
        ns = eM(
          (e) => (
            !1 === e.geometry.hasAttribute("tangent") &&
              e.geometry.computeTangents(),
            iY("tangent", "vec4")
          )
        )(),
        nn = ns.xyz.toVar("tangentLocal"),
        na = sC
          .mul(eX(nn, 0))
          .xyz.toVarying("v_tangentView")
          .normalize()
          .toVar("tangentView"),
        no = na
          .transformDirection(sa)
          .toVarying("v_tangentWorld")
          .normalize()
          .toVar("tangentWorld"),
        nl = na.toVar("transformedTangentView"),
        nu = nl
          .transformDirection(sa)
          .normalize()
          .toVar("transformedTangentWorld"),
        nd = ih(sk.cross(ns).mul(ns.w).xyz, "v_bitangentGeometry")
          .normalize()
          .toVar("bitangentGeometry"),
        nh = ih(sz.cross(nn).mul(ns.w).xyz, "v_bitangentLocal")
          .normalize()
          .toVar("bitangentLocal"),
        nc = ih(sW.cross(na).mul(ns.w).xyz, "v_bitangentView")
          .normalize()
          .toVar("bitangentView"),
        np = ih(sH.cross(no).mul(ns.w).xyz, "v_bitangentWorld")
          .normalize()
          .toVar("bitangentWorld"),
        ng = sq
          .cross(nl)
          .mul(ns.w)
          .xyz.normalize()
          .toVar("transformedBitangentView"),
        nm = ng
          .transformDirection(sa)
          .normalize()
          .toVar("transformedBitangentWorld"),
        nf = eJ(na, nc, sW),
        ny = sD.mul(nf),
        nx = (() => {
          let e = tT.cross(sD);
          return rZ(
            (e = e.cross(tT).normalize()),
            sq,
            tx.mul(tl.oneMinus()).oneMinus().pow2().pow2()
          ).normalize();
        })(),
        nb = eM((e) => {
          let { eye_pos: t, surf_norm: r, mapN: i, uv: s } = e,
            n = t.dFdx(),
            a = t.dFdy(),
            o = s.dFdx(),
            l = s.dFdy(),
            u = a.cross(r),
            d = r.cross(n),
            h = u.mul(o.x).add(d.mul(l.x)),
            c = u.mul(o.y).add(d.mul(l.y)),
            p = h.dot(h).max(c.dot(c)),
            g = sG.mul(p.inverseSqrt());
          return tO(h.mul(i.x, g), c.mul(i.y, g), r.mul(i.z)).normalize();
        });
      class nT extends k {
        static get type() {
          return "NormalMapNode";
        }
        constructor(e, t = null) {
          super("vec3"),
            (this.node = e),
            (this.scaleNode = t),
            (this.normalMapType = u.bI3);
        }
        setup(e) {
          let { normalMapType: t, scaleNode: r } = this,
            i = this.node.mul(2).sub(1);
          null !== r && (i = eW(i.xy.mul(r), i.z));
          let s = null;
          return (
            t === u.vyJ
              ? (s = sK(i))
              : t === u.bI3 &&
                (s =
                  !0 === e.hasGeometryAttribute("tangent")
                    ? nf.mul(i).normalize()
                    : nb({ eye_pos: sL, surf_norm: sW, mapN: i, uv: iZ() })),
            s
          );
        }
      }
      let n_ = eE(nT),
        nv = eM(({ textureNode: e, bumpScale: t }) => {
          let r = (t) =>
              e
                .cache()
                .context({
                  getUV: (e) => t(e.uvNode || iZ()),
                  forceUVContext: !0,
                }),
            i = eL(r((e) => e));
          return eG(
            eL(r((e) => e.add(e.dFdx()))).sub(i),
            eL(r((e) => e.add(e.dFdy()))).sub(i)
          ).mul(t);
        }),
        nN = eM((e) => {
          let { surf_pos: t, surf_norm: r, dHdxy: i } = e,
            s = t.dFdx().normalize(),
            n = t.dFdy().normalize().cross(r),
            a = r.cross(s),
            o = s.dot(n).mul(sG),
            l = o.sign().mul(i.x.mul(n).add(i.y.mul(a)));
          return o.abs().mul(r).sub(l).normalize();
        });
      class nS extends k {
        static get type() {
          return "BumpMapNode";
        }
        constructor(e, t = null) {
          super("vec3"), (this.textureNode = e), (this.scaleNode = t);
        }
        setup() {
          let e = null !== this.scaleNode ? this.scaleNode : 1;
          return nN({
            surf_pos: sL,
            surf_norm: sW,
            dHdxy: nv({ textureNode: this.textureNode, bumpScale: e }),
          });
        }
      }
      let nR = eE(nS),
        nA = new Map();
      class nC extends V {
        static get type() {
          return "MaterialNode";
        }
        constructor(e) {
          super(), (this.scope = e);
        }
        getCache(e, t) {
          let r = nA.get(e);
          return void 0 === r && ((r = ni(e, t)), nA.set(e, r)), r;
        }
        getFloat(e) {
          return this.getCache(e, "float");
        }
        getColor(e) {
          return this.getCache(e, "color");
        }
        getTexture(e) {
          return this.getCache("map" === e ? "map" : e + "Map", "texture");
        }
        setup(e) {
          let t = e.context.material,
            r = this.scope,
            i = null;
          if (r === nC.COLOR) {
            let e = void 0 !== t.color ? this.getColor(r) : eW();
            i =
              t.map && !0 === t.map.isTexture
                ? e.mul(this.getTexture("map"))
                : e;
          } else if (r === nC.OPACITY) {
            let e = this.getFloat(r);
            i =
              t.alphaMap && !0 === t.alphaMap.isTexture
                ? e.mul(this.getTexture("alpha"))
                : e;
          } else if (r === nC.SPECULAR_STRENGTH)
            i =
              t.specularMap && !0 === t.specularMap.isTexture
                ? this.getTexture("specular").r
                : eL(1);
          else if (r === nC.SPECULAR_INTENSITY) {
            let e = this.getFloat(r);
            i =
              t.specularIntensityMap && !0 === t.specularIntensityMap.isTexture
                ? e.mul(this.getTexture(r).a)
                : e;
          } else if (r === nC.SPECULAR_COLOR) {
            let e = this.getColor(r);
            i =
              t.specularColorMap && !0 === t.specularColorMap.isTexture
                ? e.mul(this.getTexture(r).rgb)
                : e;
          } else if (r === nC.ROUGHNESS) {
            let e = this.getFloat(r);
            i =
              t.roughnessMap && !0 === t.roughnessMap.isTexture
                ? e.mul(this.getTexture(r).g)
                : e;
          } else if (r === nC.METALNESS) {
            let e = this.getFloat(r);
            i =
              t.metalnessMap && !0 === t.metalnessMap.isTexture
                ? e.mul(this.getTexture(r).b)
                : e;
          } else if (r === nC.EMISSIVE) {
            let e = this.getFloat("emissiveIntensity"),
              s = this.getColor(r).mul(e);
            i =
              t.emissiveMap && !0 === t.emissiveMap.isTexture
                ? s.mul(this.getTexture(r))
                : s;
          } else if (r === nC.NORMAL)
            t.normalMap
              ? ((i = n_(
                  this.getTexture("normal"),
                  this.getCache("normalScale", "vec2")
                )).normalMapType = t.normalMapType)
              : (i = t.bumpMap
                  ? nR(this.getTexture("bump").r, this.getFloat("bumpScale"))
                  : sW);
          else if (r === nC.CLEARCOAT) {
            let e = this.getFloat(r);
            i =
              t.clearcoatMap && !0 === t.clearcoatMap.isTexture
                ? e.mul(this.getTexture(r).r)
                : e;
          } else if (r === nC.CLEARCOAT_ROUGHNESS) {
            let e = this.getFloat(r);
            i =
              t.clearcoatRoughnessMap &&
              !0 === t.clearcoatRoughnessMap.isTexture
                ? e.mul(this.getTexture(r).r)
                : e;
          } else if (r === nC.CLEARCOAT_NORMAL)
            i = t.clearcoatNormalMap
              ? n_(this.getTexture(r), this.getCache(r + "Scale", "vec2"))
              : sW;
          else if (r === nC.SHEEN) {
            let e = this.getColor("sheenColor").mul(this.getFloat("sheen"));
            i =
              t.sheenColorMap && !0 === t.sheenColorMap.isTexture
                ? e.mul(this.getTexture("sheenColor").rgb)
                : e;
          } else if (r === nC.SHEEN_ROUGHNESS) {
            let e = this.getFloat(r);
            i = (i =
              t.sheenRoughnessMap && !0 === t.sheenRoughnessMap.isTexture
                ? e.mul(this.getTexture(r).a)
                : e).clamp(0.07, 1);
          } else if (r === nC.ANISOTROPY)
            if (t.anisotropyMap && !0 === t.anisotropyMap.isTexture) {
              let e = this.getTexture(r);
              i = eZ(at.x, at.y, at.y.negate(), at.x).mul(
                e.rg.mul(2).sub(eG(1)).normalize().mul(e.b)
              );
            } else i = at;
          else if (r === nC.IRIDESCENCE_THICKNESS) {
            let e = ne("1", "float", t.iridescenceThicknessRange);
            if (t.iridescenceThicknessMap) {
              let s = ne("0", "float", t.iridescenceThicknessRange);
              i = e.sub(s).mul(this.getTexture(r).g).add(s);
            } else i = e;
          } else if (r === nC.TRANSMISSION) {
            let e = this.getFloat(r);
            i = t.transmissionMap ? e.mul(this.getTexture(r).r) : e;
          } else if (r === nC.THICKNESS) {
            let e = this.getFloat(r);
            i = t.thicknessMap ? e.mul(this.getTexture(r).g) : e;
          } else if (r === nC.IOR) i = this.getFloat(r);
          else if (r === nC.LIGHT_MAP)
            i = this.getTexture(r).rgb.mul(this.getFloat("lightMapIntensity"));
          else if (r === nC.AO)
            i = this.getTexture(r)
              .r.sub(1)
              .mul(this.getFloat("aoMapIntensity"))
              .add(1);
          else {
            let t = this.getNodeType(e);
            i = this.getCache(r, t);
          }
          return i;
        }
      }
      (nC.ALPHA_TEST = "alphaTest"),
        (nC.COLOR = "color"),
        (nC.OPACITY = "opacity"),
        (nC.SHININESS = "shininess"),
        (nC.SPECULAR = "specular"),
        (nC.SPECULAR_STRENGTH = "specularStrength"),
        (nC.SPECULAR_INTENSITY = "specularIntensity"),
        (nC.SPECULAR_COLOR = "specularColor"),
        (nC.REFLECTIVITY = "reflectivity"),
        (nC.ROUGHNESS = "roughness"),
        (nC.METALNESS = "metalness"),
        (nC.NORMAL = "normal"),
        (nC.CLEARCOAT = "clearcoat"),
        (nC.CLEARCOAT_ROUGHNESS = "clearcoatRoughness"),
        (nC.CLEARCOAT_NORMAL = "clearcoatNormal"),
        (nC.EMISSIVE = "emissive"),
        (nC.ROTATION = "rotation"),
        (nC.SHEEN = "sheen"),
        (nC.SHEEN_ROUGHNESS = "sheenRoughness"),
        (nC.ANISOTROPY = "anisotropy"),
        (nC.IRIDESCENCE = "iridescence"),
        (nC.IRIDESCENCE_IOR = "iridescenceIOR"),
        (nC.IRIDESCENCE_THICKNESS = "iridescenceThickness"),
        (nC.IOR = "ior"),
        (nC.TRANSMISSION = "transmission"),
        (nC.THICKNESS = "thickness"),
        (nC.ATTENUATION_DISTANCE = "attenuationDistance"),
        (nC.ATTENUATION_COLOR = "attenuationColor"),
        (nC.LINE_SCALE = "scale"),
        (nC.LINE_DASH_SIZE = "dashSize"),
        (nC.LINE_GAP_SIZE = "gapSize"),
        (nC.LINE_WIDTH = "linewidth"),
        (nC.LINE_DASH_OFFSET = "dashOffset"),
        (nC.POINT_SIZE = "size"),
        (nC.DISPERSION = "dispersion"),
        (nC.LIGHT_MAP = "light"),
        (nC.AO = "ao");
      let nE = ew(nC, nC.ALPHA_TEST),
        nw = ew(nC, nC.COLOR),
        nM = ew(nC, nC.SHININESS),
        nB = ew(nC, nC.EMISSIVE),
        nF = ew(nC, nC.OPACITY),
        nU = ew(nC, nC.SPECULAR),
        nI = ew(nC, nC.SPECULAR_INTENSITY),
        nP = ew(nC, nC.SPECULAR_COLOR),
        nL = ew(nC, nC.SPECULAR_STRENGTH),
        nD = ew(nC, nC.REFLECTIVITY),
        nV = ew(nC, nC.ROUGHNESS),
        nO = ew(nC, nC.METALNESS),
        nG = ew(nC, nC.NORMAL),
        nk = ew(nC, nC.CLEARCOAT),
        nz = ew(nC, nC.CLEARCOAT_ROUGHNESS),
        n$ = ew(nC, nC.CLEARCOAT_NORMAL),
        nW = ew(nC, nC.ROTATION),
        nH = ew(nC, nC.SHEEN),
        nq = ew(nC, nC.SHEEN_ROUGHNESS),
        nj = ew(nC, nC.ANISOTROPY),
        nX = ew(nC, nC.IRIDESCENCE),
        nQ = ew(nC, nC.IRIDESCENCE_IOR),
        nK = ew(nC, nC.IRIDESCENCE_THICKNESS),
        nY = ew(nC, nC.TRANSMISSION),
        nZ = ew(nC, nC.THICKNESS),
        nJ = ew(nC, nC.IOR),
        n0 = ew(nC, nC.ATTENUATION_DISTANCE),
        n1 = ew(nC, nC.ATTENUATION_COLOR),
        n2 = ew(nC, nC.LINE_SCALE),
        n3 = ew(nC, nC.LINE_DASH_SIZE),
        n4 = ew(nC, nC.LINE_GAP_SIZE),
        n6 = ew(nC, nC.LINE_WIDTH),
        n5 = ew(nC, nC.LINE_DASH_OFFSET),
        n8 = ew(nC, nC.POINT_SIZE),
        n9 = ew(nC, nC.DISPERSION),
        n7 = ew(nC, nC.LIGHT_MAP),
        ae = ew(nC, nC.AO),
        at = tr(new u.I9Y())
          .onReference(function (e) {
            return e.material;
          })
          .onRenderUpdate(function ({ material: e }) {
            this.value.set(
              e.anisotropy * Math.cos(e.anisotropyRotation),
              e.anisotropy * Math.sin(e.anisotropyRotation)
            );
          }),
        ar = eM((e) => e.context.setupModelViewProjection(), "vec4")
          .once()()
          .toVarying("v_modelViewProjection");
      class ai extends V {
        static get type() {
          return "IndexNode";
        }
        constructor(e) {
          super("uint"), (this.scope = e), (this.isIndexNode = !0);
        }
        generate(e) {
          let t,
            r,
            i = this.getNodeType(e),
            s = this.scope;
          if (s === ai.VERTEX) t = e.getVertexIndex();
          else if (s === ai.INSTANCE) t = e.getInstanceIndex();
          else if (s === ai.DRAW) t = e.getDrawIndex();
          else if (s === ai.INVOCATION_LOCAL) t = e.getInvocationLocalIndex();
          else if (s === ai.INVOCATION_SUBGROUP)
            t = e.getInvocationSubgroupIndex();
          else if (s === ai.SUBGROUP) t = e.getSubgroupIndex();
          else throw Error("THREE.IndexNode: Unknown scope: " + s);
          return "vertex" === e.shaderStage || "compute" === e.shaderStage
            ? t
            : ih(this).build(e, i);
        }
      }
      (ai.VERTEX = "vertex"),
        (ai.INSTANCE = "instance"),
        (ai.SUBGROUP = "subgroup"),
        (ai.INVOCATION_LOCAL = "invocationLocal"),
        (ai.INVOCATION_SUBGROUP = "invocationSubgroup"),
        (ai.DRAW = "draw");
      let as = ew(ai, ai.VERTEX),
        an = ew(ai, ai.INSTANCE),
        aa = ew(ai, ai.SUBGROUP),
        ao = ew(ai, ai.INVOCATION_SUBGROUP),
        al = ew(ai, ai.INVOCATION_LOCAL),
        au = ew(ai, ai.DRAW);
      class ad extends V {
        static get type() {
          return "InstanceNode";
        }
        constructor(e, t, r) {
          super("void"),
            (this.count = e),
            (this.instanceMatrix = t),
            (this.instanceColor = r),
            (this.instanceMatrixNode = null),
            (this.instanceColorNode = null),
            (this.updateType = M.FRAME),
            (this.buffer = null),
            (this.bufferColor = null);
        }
        setup(e) {
          let { count: t, instanceMatrix: r, instanceColor: i } = this,
            { instanceMatrixNode: s, instanceColorNode: n } = this;
          if (null === s) {
            if (t <= 1e3) s = i8(r.array, "mat4", Math.max(t, 1)).element(an);
            else {
              let e = new u.LuO(r.array, 16, 1);
              this.buffer = e;
              let t = r.usage === u.Vnu ? iP : iI;
              s = e0(
                t(e, "vec4", 16, 0),
                t(e, "vec4", 16, 4),
                t(e, "vec4", 16, 8),
                t(e, "vec4", 16, 12)
              );
            }
            this.instanceMatrixNode = s;
          }
          if (i && null === n) {
            let e = new u.uWO(i.array, 3),
              t = i.usage === u.Vnu ? iP : iI;
            (this.bufferColor = e),
              (n = eW(t(e, "vec3", 3, 0))),
              (this.instanceColorNode = n);
          }
          let a = s.mul(sF).xyz;
          if ((sF.assign(a), e.hasGeometryAttribute("normal"))) {
            let e = sQ(sz, s);
            sz.assign(e);
          }
          null !== this.instanceColorNode &&
            tn("vec3", "vInstanceColor").assign(this.instanceColorNode);
        }
        update() {
          this.instanceMatrix.usage !== u.Vnu &&
            null !== this.buffer &&
            this.instanceMatrix.version !== this.buffer.version &&
            (this.buffer.version = this.instanceMatrix.version),
            this.instanceColor &&
              this.instanceColor.usage !== u.Vnu &&
              null !== this.bufferColor &&
              this.instanceColor.version !== this.bufferColor.version &&
              (this.bufferColor.version = this.instanceColor.version);
        }
      }
      let ah = eE(ad);
      class ac extends ad {
        static get type() {
          return "InstancedMeshNode";
        }
        constructor(e) {
          let { count: t, instanceMatrix: r, instanceColor: i } = e;
          super(t, r, i), (this.instancedMesh = e);
        }
      }
      let ap = eE(ac);
      class ag extends V {
        static get type() {
          return "BatchNode";
        }
        constructor(e) {
          super("void"), (this.batchMesh = e), (this.batchingIdNode = null);
        }
        setup(e) {
          null === this.batchingIdNode &&
            (null === e.getDrawIndex()
              ? (this.batchingIdNode = an)
              : (this.batchingIdNode = au));
          let t = eM(([e]) => {
              let t = eD(i0(i6(this.batchMesh._indirectTexture), 0)),
                r = eD(e).modInt(t),
                i = eD(e).div(t);
              return i6(this.batchMesh._indirectTexture, ek(r, i)).x;
            }).setLayout({
              name: "getIndirectIndex",
              type: "uint",
              inputs: [{ name: "id", type: "int" }],
            })(eD(this.batchingIdNode)),
            r = this.batchMesh._matricesTexture,
            i = i0(i6(r), 0),
            s = eL(t).mul(4).toInt().toVar(),
            n = s.modInt(i),
            a = s.div(eD(i)),
            o = e0(
              i6(r, ek(n, a)),
              i6(r, ek(n.add(1), a)),
              i6(r, ek(n.add(2), a)),
              i6(r, ek(n.add(3), a))
            ),
            l = this.batchMesh._colorsTexture;
          if (null !== l) {
            let e = eM(([e]) => {
              let t = i0(i6(l), 0).x;
              return i6(l, ek(e.modInt(t), e.div(t))).rgb;
            }).setLayout({
              name: "getBatchingColor",
              type: "vec3",
              inputs: [{ name: "id", type: "int" }],
            })(t);
            tn("vec3", "vBatchColor").assign(e);
          }
          let u = eJ(o);
          sF.assign(o.mul(sF));
          let d = sz.div(eW(u[0].dot(u[0]), u[1].dot(u[1]), u[2].dot(u[2]))),
            h = u.mul(d).xyz;
          sz.assign(h), e.hasGeometryAttribute("tangent") && nn.mulAssign(u);
        }
      }
      let am = eE(ag),
        af = new WeakMap();
      class ay extends V {
        static get type() {
          return "SkinningNode";
        }
        constructor(e, t = !1) {
          let r, i, s;
          super("void"),
            (this.skinnedMesh = e),
            (this.useReference = t),
            (this.updateType = M.OBJECT),
            (this.skinIndexNode = iY("skinIndex", "uvec4")),
            (this.skinWeightNode = iY("skinWeight", "vec4")),
            t
              ? ((r = ne("bindMatrix", "mat4")),
                (i = ne("bindMatrixInverse", "mat4")),
                (s = nt(
                  "skeleton.boneMatrices",
                  "mat4",
                  e.skeleton.bones.length
                )))
              : ((r = tr(e.bindMatrix, "mat4")),
                (i = tr(e.bindMatrixInverse, "mat4")),
                (s = i8(
                  e.skeleton.boneMatrices,
                  "mat4",
                  e.skeleton.bones.length
                ))),
            (this.bindMatrixNode = r),
            (this.bindMatrixInverseNode = i),
            (this.boneMatricesNode = s),
            (this.previousBoneMatricesNode = null);
        }
        getSkinnedPosition(e = this.boneMatricesNode, t = sF) {
          let {
              skinIndexNode: r,
              skinWeightNode: i,
              bindMatrixNode: s,
              bindMatrixInverseNode: n,
            } = this,
            a = e.element(r.x),
            o = e.element(r.y),
            l = e.element(r.z),
            u = e.element(r.w),
            d = s.mul(t),
            h = tO(
              a.mul(i.x).mul(d),
              o.mul(i.y).mul(d),
              l.mul(i.z).mul(d),
              u.mul(i.w).mul(d)
            );
          return n.mul(h).xyz;
        }
        getSkinnedNormal(e = this.boneMatricesNode, t = sz) {
          let {
              skinIndexNode: r,
              skinWeightNode: i,
              bindMatrixNode: s,
              bindMatrixInverseNode: n,
            } = this,
            a = e.element(r.x),
            o = e.element(r.y),
            l = e.element(r.z),
            u = e.element(r.w),
            d = tO(i.x.mul(a), i.y.mul(o), i.z.mul(l), i.w.mul(u));
          return (d = n.mul(d).mul(s)).transformDirection(t).xyz;
        }
        getPreviousSkinnedPosition(e) {
          let t = e.object;
          return (
            null === this.previousBoneMatricesNode &&
              ((t.skeleton.previousBoneMatrices = new Float32Array(
                t.skeleton.boneMatrices
              )),
              (this.previousBoneMatricesNode = nt(
                "skeleton.previousBoneMatrices",
                "mat4",
                t.skeleton.bones.length
              ))),
            this.getSkinnedPosition(this.previousBoneMatricesNode, sU)
          );
        }
        needsPreviousBoneMatrices(e) {
          let t = e.renderer.getMRT();
          return (t && t.has("velocity")) || !0 === R(e.object).useVelocity;
        }
        setup(e) {
          this.needsPreviousBoneMatrices(e) &&
            sU.assign(this.getPreviousSkinnedPosition(e));
          let t = this.getSkinnedPosition();
          if ((sF.assign(t), e.hasGeometryAttribute("normal"))) {
            let t = this.getSkinnedNormal();
            sz.assign(t), e.hasGeometryAttribute("tangent") && nn.assign(t);
          }
        }
        generate(e, t) {
          if ("void" !== t) return sF.build(e, t);
        }
        update(e) {
          let t = (this.useReference ? e.object : this.skinnedMesh).skeleton;
          af.get(t) !== e.frameId &&
            (af.set(t, e.frameId),
            null !== this.previousBoneMatricesNode &&
              t.previousBoneMatrices.set(t.boneMatrices),
            t.update());
        }
      }
      let ax = (e) => eR(new ay(e, !0));
      class ab extends V {
        static get type() {
          return "LoopNode";
        }
        constructor(e = []) {
          super(), (this.params = e);
        }
        getVarName(e) {
          return String.fromCharCode(105 + e);
        }
        getProperties(e) {
          let t = e.getNodeProperties(this);
          if (void 0 !== t.stackNode) return t;
          let r = {};
          for (let e = 0, t = this.params.length - 1; e < t; e++) {
            let t = this.params[e],
              i = (!0 !== t.isNode && t.name) || this.getVarName(e),
              s = (!0 !== t.isNode && t.type) || "int";
            r[i] = iq(i, s);
          }
          let i = e.addStack();
          return (
            (t.returnsNode = this.params[this.params.length - 1](r, i, e)),
            (t.stackNode = i),
            e.removeStack(),
            t
          );
        }
        getNodeType(e) {
          let { returnsNode: t } = this.getProperties(e);
          return t ? t.getNodeType(e) : "void";
        }
        setup(e) {
          this.getProperties(e);
        }
        generate(e) {
          let t = this.getProperties(e),
            r = this.params,
            i = t.stackNode;
          for (let t = 0, i = r.length - 1; t < i; t++) {
            let i = r[t],
              s = null,
              n = null,
              a = null,
              o = null,
              l = null,
              u = null;
            i.isNode
              ? ((o = "int"),
                (a = this.getVarName(t)),
                (s = "0"),
                (n = i.build(e, o)),
                (l = "<"))
              : ((o = i.type || "int"),
                (a = i.name || this.getVarName(t)),
                (s = i.start),
                (n = i.end),
                (l = i.condition),
                (u = i.update),
                "number" == typeof s
                  ? (s = e.generateConst(o, s))
                  : s && s.isNode && (s = s.build(e, o)),
                "number" == typeof n
                  ? (n = e.generateConst(o, n))
                  : n && n.isNode && (n = n.build(e, o)),
                void 0 !== s && void 0 === n
                  ? ((s += " - 1"), (n = "0"), (l = ">="))
                  : void 0 !== n && void 0 === s && ((s = "0"), (l = "<")),
                void 0 === l && (l = Number(s) > Number(n) ? ">=" : "<"));
            let d = { start: s, end: n },
              h = d.start,
              c = d.end,
              p = "",
              g = "",
              m = "";
            u ||
              (u =
                "int" === o || "uint" === o
                  ? l.includes("<")
                    ? "++"
                    : "--"
                  : l.includes("<")
                  ? "+= 1."
                  : "-= 1."),
              (p += e.getVar(o, a) + " = " + h),
              (g += a + " " + l + " " + c),
              (m += a + " " + u);
            let f = `for ( ${p}; ${g}; ${m} )`;
            e.addFlowCode(
              (0 === t ? "\n" : "") + e.tab + f + " {\n\n"
            ).addFlowTab();
          }
          let s = i.build(e, "void"),
            n = t.returnsNode ? t.returnsNode.build(e) : "";
          e.removeFlowTab().addFlowCode("\n" + e.tab + s);
          for (let t = 0, r = this.params.length - 1; t < r; t++)
            e.addFlowCode((0 === t ? "" : e.tab) + "}\n\n").removeFlowTab();
          return e.addFlowTab(), n;
        }
      }
      let aT = (...e) => eR(new ab(eC(e, "int"))).append(),
        a_ = () => iq("break").append(),
        av = new WeakMap(),
        aN = new u.IUQ(),
        aS = eM(
          ({
            bufferMap: e,
            influence: t,
            stride: r,
            width: i,
            depth: s,
            offset: n,
          }) => {
            let a = eD(as).mul(r).add(n),
              o = a.div(i);
            return i6(e, ek(a.sub(o.mul(i)), o))
              .depth(s)
              .mul(t);
          }
        );
      class aR extends V {
        static get type() {
          return "MorphNode";
        }
        constructor(e) {
          super("void"),
            (this.mesh = e),
            (this.morphBaseInfluence = tr(1)),
            (this.updateType = M.OBJECT);
        }
        setup(e) {
          let { geometry: t } = e,
            r = void 0 !== t.morphAttributes.position,
            i = t.hasAttribute("normal") && void 0 !== t.morphAttributes.normal,
            s =
              t.morphAttributes.position ||
              t.morphAttributes.normal ||
              t.morphAttributes.color,
            n = void 0 !== s ? s.length : 0,
            {
              texture: a,
              stride: o,
              size: l,
            } = (function (e) {
              let t = void 0 !== e.morphAttributes.position,
                r = void 0 !== e.morphAttributes.normal,
                i = void 0 !== e.morphAttributes.color,
                s =
                  e.morphAttributes.position ||
                  e.morphAttributes.normal ||
                  e.morphAttributes.color,
                n = void 0 !== s ? s.length : 0,
                a = av.get(e);
              if (void 0 === a || a.count !== n) {
                void 0 !== a && a.texture.dispose();
                let s = e.morphAttributes.position || [],
                  o = e.morphAttributes.normal || [],
                  l = e.morphAttributes.color || [],
                  d = 0;
                !0 === t && (d = 1), !0 === r && (d = 2), !0 === i && (d = 3);
                let h = e.attributes.position.count * d,
                  c = 1;
                h > 4096 && ((c = Math.ceil(h / 4096)), (h = 4096));
                let p = new Float32Array(h * c * 4 * n),
                  g = new u.rFo(p, h, c, n);
                (g.type = u.RQf), (g.needsUpdate = !0);
                let m = 4 * d;
                for (let e = 0; e < n; e++) {
                  let n = s[e],
                    a = o[e],
                    u = l[e],
                    d = h * c * 4 * e;
                  for (let e = 0; e < n.count; e++) {
                    let s = e * m;
                    !0 === t &&
                      (aN.fromBufferAttribute(n, e),
                      (p[d + s + 0] = aN.x),
                      (p[d + s + 1] = aN.y),
                      (p[d + s + 2] = aN.z),
                      (p[d + s + 3] = 0)),
                      !0 === r &&
                        (aN.fromBufferAttribute(a, e),
                        (p[d + s + 4] = aN.x),
                        (p[d + s + 5] = aN.y),
                        (p[d + s + 6] = aN.z),
                        (p[d + s + 7] = 0)),
                      !0 === i &&
                        (aN.fromBufferAttribute(u, e),
                        (p[d + s + 8] = aN.x),
                        (p[d + s + 9] = aN.y),
                        (p[d + s + 10] = aN.z),
                        (p[d + s + 11] = 4 === u.itemSize ? aN.w : 1));
                  }
                }
                (a = {
                  count: n,
                  texture: g,
                  stride: d,
                  size: new u.I9Y(h, c),
                }),
                  av.set(e, a),
                  e.addEventListener("dispose", function t() {
                    g.dispose(),
                      av.delete(e),
                      e.removeEventListener("dispose", t);
                  });
              }
              return a;
            })(t);
          !0 === r && sF.mulAssign(this.morphBaseInfluence),
            !0 === i && sz.mulAssign(this.morphBaseInfluence);
          let d = eD(l.width);
          aT(n, ({ i: e }) => {
            let t = eL(0).toVar();
            this.mesh.count > 1 &&
            null !== this.mesh.morphTexture &&
            void 0 !== this.mesh.morphTexture
              ? t.assign(i6(this.mesh.morphTexture, ek(eD(e).add(1), eD(an))).r)
              : t.assign(
                  ne("morphTargetInfluences", "float").element(e).toVar()
                ),
              !0 === r &&
                sF.addAssign(
                  aS({
                    bufferMap: a,
                    influence: t,
                    stride: o,
                    width: d,
                    depth: e,
                    offset: eD(0),
                  })
                ),
              !0 === i &&
                sz.addAssign(
                  aS({
                    bufferMap: a,
                    influence: t,
                    stride: o,
                    width: d,
                    depth: e,
                    offset: eD(1),
                  })
                );
          });
        }
        update() {
          let e = this.morphBaseInfluence;
          this.mesh.geometry.morphTargetsRelative
            ? (e.value = 1)
            : (e.value =
                1 - this.mesh.morphTargetInfluences.reduce((e, t) => e + t, 0));
        }
      }
      let aA = eE(aR);
      class aC extends V {
        static get type() {
          return "LightingNode";
        }
        constructor() {
          super("vec3"), (this.isLightingNode = !0);
        }
      }
      class aE extends aC {
        static get type() {
          return "AONode";
        }
        constructor(e = null) {
          super(), (this.aoNode = e);
        }
        setup(e) {
          e.context.ambientOcclusion.mulAssign(this.aoNode);
        }
      }
      class aw extends it {
        static get type() {
          return "LightingContextNode";
        }
        constructor(e, t = null, r = null, i = null) {
          super(e),
            (this.lightingModel = t),
            (this.backdropNode = r),
            (this.backdropAlphaNode = i),
            (this._value = null);
        }
        getContext() {
          let { backdropNode: e, backdropAlphaNode: t } = this,
            r = eW().toVar("directDiffuse"),
            i = eW().toVar("directSpecular"),
            s = eW().toVar("indirectDiffuse"),
            n = eW().toVar("indirectSpecular");
          return {
            radiance: eW().toVar("radiance"),
            irradiance: eW().toVar("irradiance"),
            iblIrradiance: eW().toVar("iblIrradiance"),
            ambientOcclusion: eL(1).toVar("ambientOcclusion"),
            reflectedLight: {
              directDiffuse: r,
              directSpecular: i,
              indirectDiffuse: s,
              indirectSpecular: n,
            },
            backdrop: e,
            backdropAlpha: t,
          };
        }
        setup(e) {
          return (
            (this.value = this._value || (this._value = this.getContext())),
            (this.value.lightingModel =
              this.lightingModel || e.context.lightingModel),
            super.setup(e)
          );
        }
      }
      let aM = eE(aw);
      class aB extends aC {
        static get type() {
          return "IrradianceNode";
        }
        constructor(e) {
          super(), (this.node = e);
        }
        setup(e) {
          e.context.irradiance.addAssign(this.node);
        }
      }
      class aF extends V {
        static get type() {
          return "ScreenNode";
        }
        constructor(e) {
          super(), (this.scope = e), (this.isViewportNode = !0);
        }
        getNodeType() {
          return this.scope === aF.VIEWPORT ? "vec4" : "vec2";
        }
        getUpdateType() {
          let e = M.NONE;
          return (
            (this.scope === aF.SIZE || this.scope === aF.VIEWPORT) &&
              (e = M.RENDER),
            (this.updateType = e),
            e
          );
        }
        update({ renderer: e }) {
          let t = e.getRenderTarget();
          this.scope === aF.VIEWPORT
            ? null !== t
              ? s.copy(t.viewport)
              : (e.getViewport(s), s.multiplyScalar(e.getPixelRatio()))
            : null !== t
            ? ((i.width = t.width), (i.height = t.height))
            : e.getDrawingBufferSize(i);
        }
        setup() {
          let e = this.scope,
            t = null;
          return e === aF.SIZE
            ? tr(i || (i = new u.I9Y()))
            : e === aF.VIEWPORT
            ? tr(s || (s = new u.IUQ()))
            : eG(aP.div(aI));
        }
        generate(e) {
          if (this.scope === aF.COORDINATE) {
            let t = e.getFragCoord();
            if (e.isFlipY()) {
              let r = e.getNodeProperties(aI).outputNode.build(e);
              t = `${e.getType("vec2")}( ${t}.x, ${r}.y - ${t}.y )`;
            }
            return t;
          }
          return super.generate(e);
        }
      }
      (aF.COORDINATE = "coordinate"),
        (aF.VIEWPORT = "viewport"),
        (aF.SIZE = "size"),
        (aF.UV = "uv");
      let aU = ew(aF, aF.UV),
        aI = ew(aF, aF.SIZE),
        aP = ew(aF, aF.COORDINATE),
        aL = ew(aF, aF.VIEWPORT),
        aD = aL.zw,
        aV = aP.sub(aL.xy),
        aO = aV.div(aD),
        aG = eM(
          () => (
            console.warn(
              'TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.'
            ),
            aI
          ),
          "vec2"
        ).once()(),
        ak = eM(
          () => (
            console.warn(
              'TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.'
            ),
            aU
          ),
          "vec2"
        ).once()(),
        az = eM(
          () => (
            console.warn(
              'TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.'
            ),
            aU.flipY()
          ),
          "vec2"
        ).once()(),
        a$ = new u.I9Y();
      class aW extends i3 {
        static get type() {
          return "ViewportTextureNode";
        }
        constructor(e = aU, t = null, r = null) {
          null === r && ((r = new u.Pem()).minFilter = u.$_I),
            super(r, e, t),
            (this.generateMipmaps = !1),
            (this.isOutputTextureNode = !0),
            (this.updateBeforeType = M.FRAME);
        }
        updateBefore(e) {
          let t = e.renderer;
          t.getDrawingBufferSize(a$);
          let r = this.value;
          (r.image.width !== a$.width || r.image.height !== a$.height) &&
            ((r.image.width = a$.width),
            (r.image.height = a$.height),
            (r.needsUpdate = !0));
          let i = r.generateMipmaps;
          (r.generateMipmaps = this.generateMipmaps),
            t.copyFramebufferToTexture(r),
            (r.generateMipmaps = i);
        }
        clone() {
          let e = new this.constructor(this.uvNode, this.levelNode, this.value);
          return (e.generateMipmaps = this.generateMipmaps), e;
        }
      }
      let aH = eE(aW),
        aq = eE(aW, null, null, { generateMipmaps: !0 }),
        aj = null;
      class aX extends aW {
        static get type() {
          return "ViewportDepthTextureNode";
        }
        constructor(e = aU, t = null) {
          null === aj && (aj = new u.VCu()), super(e, t, aj);
        }
      }
      let aQ = eE(aX);
      class aK extends V {
        static get type() {
          return "ViewportDepthNode";
        }
        constructor(e, t = null) {
          super("float"),
            (this.scope = e),
            (this.valueNode = t),
            (this.isViewportDepthNode = !0);
        }
        generate(e) {
          let { scope: t } = this;
          return t === aK.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
        }
        setup({ camera: e }) {
          let { scope: t } = this,
            r = this.valueNode,
            i = null;
          return (
            t === aK.DEPTH_BASE
              ? null !== r && (i = a1().assign(r))
              : t === aK.DEPTH
              ? (i = e.isPerspectiveCamera
                  ? aZ(sL.z, sr, si)
                  : aY(sL.z, sr, si))
              : t === aK.LINEAR_DEPTH &&
                (i =
                  null !== r
                    ? e.isPerspectiveCamera
                      ? aY(aJ(r, sr, si), sr, si)
                      : r
                    : aY(sL.z, sr, si)),
            i
          );
        }
      }
      (aK.DEPTH_BASE = "depthBase"),
        (aK.DEPTH = "depth"),
        (aK.LINEAR_DEPTH = "linearDepth");
      let aY = (e, t, r) => e.add(t).div(t.sub(r)),
        aZ = (e, t, r) => t.add(e).mul(r).div(r.sub(t).mul(e)),
        aJ = (e, t, r) => t.mul(r).div(r.sub(t).mul(e).sub(r)),
        a0 = (e, t, r) => {
          t = t.max(1e-6).toVar();
          let i = ru(e.negate().div(t)),
            s = ru(r.div(t));
          return i.div(s);
        },
        a1 = eE(aK, aK.DEPTH_BASE),
        a2 = ew(aK, aK.DEPTH),
        a3 = eE(aK, aK.LINEAR_DEPTH),
        a4 = a3(aQ());
      a2.assign = (e) => a1(e);
      class a6 extends V {
        constructor(e) {
          super("float"), (this.name = e), (this.isBuiltinNode = !0);
        }
        generate() {
          return this.name;
        }
      }
      let a5 = eE(a6);
      class a8 extends V {
        static get type() {
          return "ClippingNode";
        }
        constructor(e = a8.DEFAULT) {
          super(), (this.scope = e);
        }
        setup(e) {
          super.setup(e);
          let { intersectionPlanes: t, unionPlanes: r } = e.clippingContext;
          return ((this.hardwareClipping = e.material.hardwareClipping),
          this.scope === a8.ALPHA_TO_COVERAGE)
            ? this.setupAlphaToCoverage(t, r)
            : this.scope === a8.HARDWARE
            ? this.setupHardwareClipping(r, e)
            : this.setupDefault(t, r);
        }
        setupAlphaToCoverage(e, t) {
          return eM(() => {
            let r = eL().toVar("distanceToPlane"),
              i = eL().toVar("distanceToGradient"),
              s = eL(1).toVar("clipOpacity"),
              n = t.length;
            if (!1 === this.hardwareClipping && n > 0) {
              let e = se(t);
              aT(n, ({ i: t }) => {
                let n = e.element(t);
                r.assign(sL.dot(n.xyz).negate().add(n.w)),
                  i.assign(r.fwidth().div(2)),
                  s.mulAssign(r2(i.negate(), i, r));
              });
            }
            let a = e.length;
            if (a > 0) {
              let t = se(e),
                n = eL(1).toVar("intersectionClipOpacity");
              aT(a, ({ i: e }) => {
                let s = t.element(e);
                r.assign(sL.dot(s.xyz).negate().add(s.w)),
                  i.assign(r.fwidth().div(2)),
                  n.mulAssign(r2(i.negate(), i, r).oneMinus());
              }),
                s.mulAssign(n.oneMinus());
            }
            ta.a.mulAssign(s), ta.a.equal(0).discard();
          })();
        }
        setupDefault(e, t) {
          return eM(() => {
            let r = t.length;
            if (!1 === this.hardwareClipping && r > 0) {
              let e = se(t);
              aT(r, ({ i: t }) => {
                let r = e.element(t);
                sL.dot(r.xyz).greaterThan(r.w).discard();
              });
            }
            let i = e.length;
            if (i > 0) {
              let t = se(e),
                r = eO(!0).toVar("clipped");
              aT(i, ({ i: e }) => {
                let i = t.element(e);
                r.assign(sL.dot(i.xyz).greaterThan(i.w).and(r));
              }),
                r.discard();
            }
          })();
        }
        setupHardwareClipping(e, t) {
          let r = e.length;
          return (
            t.enableHardwareClipping(r),
            eM(() => {
              let i = se(e),
                s = a5(t.getClipDistance());
              aT(r, ({ i: e }) => {
                let t = i.element(e),
                  r = sL.dot(t.xyz).sub(t.w).negate();
                s.element(e).assign(r);
              });
            })()
          );
        }
      }
      (a8.ALPHA_TO_COVERAGE = "alphaToCoverage"),
        (a8.DEFAULT = "default"),
        (a8.HARDWARE = "hardware");
      let a9 = () => eR(new a8()),
        a7 = () => eR(new a8(a8.ALPHA_TO_COVERAGE)),
        oe = () => eR(new a8(a8.HARDWARE)),
        ot = eM(([e]) =>
          rm(
            tk(1e4, rf(tk(17, e.x).add(tk(0.1, e.y)))).mul(
              tO(0.1, rv(rf(tk(13, e.y).add(e.x))))
            )
          )
        ),
        or = eM(([e]) => ot(eG(ot(e.xy), e.z))),
        oi = eM(([e]) => {
          let t = rD(rS(rC(e.xyz)), rS(rE(e.xyz))),
            r = eL(1).div(eL(0.05).mul(t)).toVar("pixScale"),
            i = eG(ro(rc(ru(r))), ro(rp(ru(r)))),
            s = eG(or(rc(i.x.mul(e.xyz))), or(rc(i.y.mul(e.xyz)))),
            n = rm(ru(r)),
            a = tO(tk(n.oneMinus(), s.x), tk(n, s.y)),
            o = rL(n, n.oneMinus()),
            l = eW(
              a.mul(a).div(tk(2, o).mul(tG(1, o))),
              a.sub(tk(0.5, o)).div(tG(1, o)),
              tG(
                1,
                tG(1, a)
                  .mul(tG(1, a))
                  .div(tk(2, o).mul(tG(1, o)))
              )
            );
          return rJ(
            a
              .lessThan(o.oneMinus())
              .select(a.lessThan(o).select(l.x, l.y), l.z),
            1e-6,
            1
          );
        }).setLayout({
          name: "getAlphaHashThreshold",
          type: "float",
          inputs: [{ name: "position", type: "vec3" }],
        });
      class os extends u.imn {
        static get type() {
          return "NodeMaterial";
        }
        get type() {
          return this.constructor.type;
        }
        set type(e) {}
        constructor() {
          super(),
            (this.isNodeMaterial = !0),
            (this.fog = !0),
            (this.lights = !1),
            (this.hardwareClipping = !1),
            (this.lightsNode = null),
            (this.envNode = null),
            (this.aoNode = null),
            (this.colorNode = null),
            (this.normalNode = null),
            (this.opacityNode = null),
            (this.backdropNode = null),
            (this.backdropAlphaNode = null),
            (this.alphaTestNode = null),
            (this.positionNode = null),
            (this.geometryNode = null),
            (this.depthNode = null),
            (this.shadowPositionNode = null),
            (this.receivedShadowNode = null),
            (this.castShadowNode = null),
            (this.outputNode = null),
            (this.mrtNode = null),
            (this.fragmentNode = null),
            (this.vertexNode = null);
        }
        customProgramCacheKey() {
          return this.type + f(this);
        }
        build(e) {
          this.setup(e);
        }
        setupObserver(e) {
          return new h(e);
        }
        setup(e) {
          let t;
          (e.context.setupNormal = () => this.setupNormal(e)),
            (e.context.setupPositionView = () => this.setupPositionView(e)),
            (e.context.setupModelViewProjection = () =>
              this.setupModelViewProjection(e));
          let r = e.renderer,
            i = r.getRenderTarget();
          e.addStack();
          let s = this.vertexNode || this.setupVertex(e);
          (e.stack.outputNode = s),
            this.setupHardwareClipping(e),
            null !== this.geometryNode &&
              (e.stack.outputNode = e.stack.outputNode.bypass(
                this.geometryNode
              )),
            e.addFlow("vertex", e.removeStack()),
            e.addStack();
          let n = this.setupClipping(e);
          if (
            ((!0 === this.depthWrite || !0 === this.depthTest) &&
              (null !== i
                ? !0 === i.depthBuffer && this.setupDepth(e)
                : !0 === r.depth && this.setupDepth(e)),
            null === this.fragmentNode)
          ) {
            this.setupDiffuseColor(e), this.setupVariants(e);
            let s = this.setupLighting(e);
            null !== n && e.stack.add(n);
            let a = eX(s, ta.a).max(0);
            if (
              ((t = this.setupOutput(e, a)),
              tS.assign(t),
              null !== this.outputNode && (t = this.outputNode),
              null !== i)
            ) {
              let e = r.getMRT(),
                i = this.mrtNode;
              null !== e
                ? ((t = e), null !== i && (t = e.merge(i)))
                : null !== i && (t = i);
            }
          } else {
            let r = this.fragmentNode;
            !0 !== r.isOutputStructNode && (r = eX(r)),
              (t = this.setupOutput(e, r));
          }
          (e.stack.outputNode = t),
            e.addFlow("fragment", e.removeStack()),
            (e.observer = this.setupObserver(e));
        }
        setupClipping(e) {
          if (null === e.clippingContext) return null;
          let { unionPlanes: t, intersectionPlanes: r } = e.clippingContext,
            i = null;
          if (t.length > 0 || r.length > 0) {
            let t = e.renderer.samples;
            this.alphaToCoverage && t > 1 ? (i = a7()) : e.stack.add(a9());
          }
          return i;
        }
        setupHardwareClipping(e) {
          if (((this.hardwareClipping = !1), null === e.clippingContext))
            return;
          let t = e.clippingContext.unionPlanes.length;
          t > 0 &&
            t <= 8 &&
            e.isAvailable("clipDistance") &&
            (e.stack.add(oe()), (this.hardwareClipping = !0));
        }
        setupDepth(e) {
          let { renderer: t, camera: r } = e,
            i = this.depthNode;
          if (null === i) {
            let e = t.getMRT();
            e && e.has("depth")
              ? (i = e.get("depth"))
              : !0 === t.logarithmicDepthBuffer &&
                (i = r.isPerspectiveCamera
                  ? a0(sL.z, sr, si)
                  : aY(sL.z, sr, si));
          }
          null !== i && a2.assign(i).append();
        }
        setupPositionView() {
          return sC.mul(sF).xyz;
        }
        setupModelViewProjection() {
          return ss.mul(sL);
        }
        setupVertex(e) {
          return (
            e.addStack(),
            this.setupPosition(e),
            (e.context.vertex = e.removeStack()),
            ar
          );
        }
        setupPosition(e) {
          let { object: t, geometry: r } = e;
          if (
            ((r.morphAttributes.position ||
              r.morphAttributes.normal ||
              r.morphAttributes.color) &&
              aA(t).append(),
            !0 === t.isSkinnedMesh && ax(t).append(),
            this.displacementMap)
          ) {
            let e = ni("displacementMap", "texture"),
              t = ni("displacementScale", "float"),
              r = ni("displacementBias", "float");
            sF.addAssign(sz.normalize().mul(e.x.mul(t).add(r)));
          }
          return (
            t.isBatchedMesh && am(t).append(),
            t.isInstancedMesh &&
              t.instanceMatrix &&
              !0 === t.instanceMatrix.isInstancedBufferAttribute &&
              ap(t).append(),
            null !== this.positionNode &&
              sF.assign(this.positionNode.context({ isPositionNodeInput: !0 })),
            sF
          );
        }
        setupDiffuseColor({ object: e, geometry: t }) {
          let r = this.colorNode ? eX(this.colorNode) : nw;
          !0 === this.vertexColors &&
            t.hasAttribute("color") &&
            (r = eX(r.xyz.mul(iY("color", "vec3")), r.a)),
            e.instanceColor && (r = tn("vec3", "vInstanceColor").mul(r)),
            e.isBatchedMesh &&
              e._colorsTexture &&
              (r = tn("vec3", "vBatchColor").mul(r)),
            ta.assign(r);
          let i = this.opacityNode ? eL(this.opacityNode) : nF;
          if (
            (ta.a.assign(ta.a.mul(i)),
            null !== this.alphaTestNode || this.alphaTest > 0)
          ) {
            let e = null !== this.alphaTestNode ? eL(this.alphaTestNode) : nE;
            ta.a.lessThanEqual(e).discard();
          }
          !0 === this.alphaHash && ta.a.lessThan(oi(sF)).discard(),
            !1 === this.transparent &&
              this.blending === u.NTi &&
              !1 === this.alphaToCoverage &&
              ta.a.assign(1);
        }
        setupVariants() {}
        setupOutgoingLight() {
          return !0 === this.lights ? eW(0) : ta.rgb;
        }
        setupNormal() {
          return this.normalNode ? eW(this.normalNode) : nG;
        }
        setupEnvironment() {
          let e = null;
          return (
            this.envNode
              ? (e = this.envNode)
              : this.envMap &&
                (e = this.envMap.isCubeTexture
                  ? ni("envMap", "cubeTexture")
                  : ni("envMap", "texture")),
            e
          );
        }
        setupLightMap(e) {
          let t = null;
          return e.material.lightMap && (t = new aB(n7)), t;
        }
        setupLights(e) {
          let t = [],
            r = this.setupEnvironment(e);
          r && r.isLightingNode && t.push(r);
          let i = this.setupLightMap(e);
          if (
            (i && i.isLightingNode && t.push(i),
            null !== this.aoNode || e.material.aoMap)
          ) {
            let e = null !== this.aoNode ? this.aoNode : ae;
            t.push(new aE(e));
          }
          let s = this.lightsNode || e.lightsNode;
          return (
            t.length > 0 &&
              (s = e.renderer.lighting.createNode([...s.getLights(), ...t])),
            s
          );
        }
        setupLightingModel() {}
        setupLighting(e) {
          let { material: t } = e,
            { backdropNode: r, backdropAlphaNode: i, emissiveNode: s } = this,
            n =
              !0 === this.lights || null !== this.lightsNode
                ? this.setupLights(e)
                : null,
            a = this.setupOutgoingLight(e);
          return (
            n && n.getScope().hasLights
              ? (a = aM(n, this.setupLightingModel(e) || null, r, i))
              : null !== r && (a = eW(null !== i ? rZ(a, r, i) : r)),
            ((s && !0 === s.isNode) ||
              (t.emissive && !0 === t.emissive.isColor)) &&
              (to.assign(eW(s || nB)), (a = a.add(to))),
            a
          );
        }
        setupFog(e, t) {
          let r = e.fogNode;
          return r && (tS.assign(t), (t = eX(r))), t;
        }
        setupOutput(e, t) {
          return !0 === this.fog && (t = this.setupFog(e, t)), t;
        }
        setDefaultValues(e) {
          for (let t in e) {
            let r = e[t];
            void 0 === this[t] &&
              ((this[t] = r), r && r.clone && (this[t] = r.clone()));
          }
          let t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
          for (let e in t)
            void 0 ===
              Object.getOwnPropertyDescriptor(this.constructor.prototype, e) &&
              void 0 !== t[e].get &&
              Object.defineProperty(this.constructor.prototype, e, t[e]);
        }
        toJSON(e) {
          let t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {}, nodes: {} });
          let r = u.imn.prototype.toJSON.call(this, e),
            i = y(this);
          for (let { property: t, childNode: s } of ((r.inputNodes = {}), i))
            r.inputNodes[t] = s.toJSON(e).uuid;
          function s(e) {
            let t = [];
            for (let r in e) {
              let i = e[r];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (t) {
            let t = s(e.textures),
              i = s(e.images),
              n = s(e.nodes);
            t.length > 0 && (r.textures = t),
              i.length > 0 && (r.images = i),
              n.length > 0 && (r.nodes = n);
          }
          return r;
        }
        copy(e) {
          return (
            (this.lightsNode = e.lightsNode),
            (this.envNode = e.envNode),
            (this.colorNode = e.colorNode),
            (this.normalNode = e.normalNode),
            (this.opacityNode = e.opacityNode),
            (this.backdropNode = e.backdropNode),
            (this.backdropAlphaNode = e.backdropAlphaNode),
            (this.alphaTestNode = e.alphaTestNode),
            (this.positionNode = e.positionNode),
            (this.geometryNode = e.geometryNode),
            (this.depthNode = e.depthNode),
            (this.shadowPositionNode = e.shadowPositionNode),
            (this.receivedShadowNode = e.receivedShadowNode),
            (this.castShadowNode = e.castShadowNode),
            (this.outputNode = e.outputNode),
            (this.mrtNode = e.mrtNode),
            (this.fragmentNode = e.fragmentNode),
            (this.vertexNode = e.vertexNode),
            super.copy(e)
          );
        }
      }
      let on = new u.mrM();
      class oa extends os {
        static get type() {
          return "LineBasicNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isLineBasicNodeMaterial = !0),
            this.setDefaultValues(on),
            this.setValues(e);
        }
      }
      let oo = new u.Fvt();
      class ol extends os {
        static get type() {
          return "LineDashedNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isLineDashedNodeMaterial = !0),
            this.setDefaultValues(oo),
            (this.dashOffset = 0),
            (this.offsetNode = null),
            (this.dashScaleNode = null),
            (this.dashSizeNode = null),
            (this.gapSizeNode = null),
            this.setValues(e);
        }
        setupVariants() {
          let e = this.offsetNode ? eL(this.offsetNode) : n5,
            t = this.dashScaleNode ? eL(this.dashScaleNode) : n2,
            r = this.dashSizeNode ? eL(this.dashSizeNode) : n3,
            i = this.gapSizeNode ? eL(this.gapSizeNode) : n4;
          tR.assign(r), tA.assign(i);
          let s = ih(iY("lineDistance").mul(t));
          (e ? s.add(e) : s).mod(tR.add(tA)).greaterThan(tR).discard();
        }
      }
      let ou = null;
      class od extends aW {
        static get type() {
          return "ViewportSharedTextureNode";
        }
        constructor(e = aU, t = null) {
          null === ou && (ou = new u.Pem()), super(e, t, ou);
        }
        updateReference() {
          return this;
        }
      }
      let oh = eE(od),
        oc = new u.Fvt();
      class op extends os {
        static get type() {
          return "Line2NodeMaterial";
        }
        constructor(e = {}) {
          super(),
            (this.isLine2NodeMaterial = !0),
            this.setDefaultValues(oc),
            (this.useColor = e.vertexColors),
            (this.dashOffset = 0),
            (this.lineWidth = 1),
            (this.lineColorNode = null),
            (this.offsetNode = null),
            (this.dashScaleNode = null),
            (this.dashSizeNode = null),
            (this.gapSizeNode = null),
            (this.blending = u.XIg),
            (this._useDash = e.dashed),
            (this._useAlphaToCoverage = !0),
            (this._useWorldUnits = !1),
            this.setValues(e);
        }
        setup(e) {
          let { renderer: t } = e,
            r = this._useAlphaToCoverage,
            i = this.useColor,
            s = this._useDash,
            n = this._useWorldUnits,
            a = eM(({ start: e, end: t }) => {
              let r = ss.element(2).element(2),
                i = ss
                  .element(3)
                  .element(2)
                  .mul(-0.5)
                  .div(r)
                  .sub(e.z)
                  .div(t.z.sub(e.z));
              return eX(rZ(e.xyz, t.xyz, i), t.w);
            }).setLayout({
              name: "trimSegment",
              type: "vec4",
              inputs: [
                { name: "start", type: "vec4" },
                { name: "end", type: "vec4" },
              ],
            });
          this.vertexNode = eM(() => {
            let e = iY("instanceStart"),
              t = iY("instanceEnd"),
              r = eX(sC.mul(eX(e, 1))).toVar("start"),
              i = eX(sC.mul(eX(t, 1))).toVar("end");
            if (s) {
              let e = this.dashScaleNode ? eL(this.dashScaleNode) : n2,
                t = this.offsetNode ? eL(this.offsetNode) : n5,
                r = iY("instanceDistanceStart"),
                i = iY("instanceDistanceEnd"),
                s = sB.y.lessThan(0.5).select(e.mul(r), e.mul(i));
              (s = s.add(t)), tn("float", "lineDistance").assign(s);
            }
            n &&
              (tn("vec3", "worldStart").assign(r.xyz),
              tn("vec3", "worldEnd").assign(i.xyz));
            let o = aL.z.div(aL.w);
            eU(ss.element(2).element(3).equal(-1), () => {
              eU(r.z.lessThan(0).and(i.z.greaterThan(0)), () => {
                i.assign(a({ start: r, end: i }));
              }).ElseIf(i.z.lessThan(0).and(r.z.greaterThanEqual(0)), () => {
                r.assign(a({ start: i, end: r }));
              });
            });
            let l = ss.mul(r),
              u = ss.mul(i),
              d = l.xyz.div(l.w),
              h = u.xyz.div(u.w),
              c = h.xy.sub(d.xy).toVar();
            c.x.assign(c.x.mul(o)), c.assign(c.normalize());
            let p = eX().toVar();
            if (n) {
              let e = i.xyz.sub(r.xyz).normalize(),
                t = rZ(r.xyz, i.xyz, 0.5).normalize(),
                n = e.cross(t).normalize(),
                a = e.cross(n),
                o = tn("vec4", "worldPos");
              o.assign(sB.y.lessThan(0.5).select(r, i));
              let l = n6.mul(0.5);
              o.addAssign(
                eX(sB.x.lessThan(0).select(n.mul(l), n.mul(l).negate()), 0)
              ),
                s ||
                  (o.addAssign(
                    eX(
                      sB.y.lessThan(0.5).select(e.mul(l).negate(), e.mul(l)),
                      0
                    )
                  ),
                  o.addAssign(eX(a.mul(l), 0)),
                  eU(sB.y.greaterThan(1).or(sB.y.lessThan(0)), () => {
                    o.subAssign(eX(a.mul(2).mul(l), 0));
                  })),
                p.assign(ss.mul(o));
              let u = eW().toVar();
              u.assign(sB.y.lessThan(0.5).select(d, h)),
                p.z.assign(u.z.mul(p.w));
            } else {
              let e = eG(c.y, c.x.negate()).toVar("offset");
              c.x.assign(c.x.div(o)),
                e.x.assign(e.x.div(o)),
                e.assign(sB.x.lessThan(0).select(e.negate(), e)),
                eU(sB.y.lessThan(0), () => {
                  e.assign(e.sub(c));
                }).ElseIf(sB.y.greaterThan(1), () => {
                  e.assign(e.add(c));
                }),
                e.assign(e.mul(n6)),
                e.assign(e.div(aL.w)),
                p.assign(sB.y.lessThan(0.5).select(l, u)),
                e.assign(e.mul(p.w)),
                p.assign(p.add(eX(e, 0, 0)));
            }
            return p;
          })();
          let o = eM(({ p1: e, p2: t, p3: r, p4: i }) => {
            let s = e.sub(r),
              n = i.sub(r),
              a = t.sub(e),
              o = s.dot(n),
              l = n.dot(a),
              u = s.dot(a),
              d = n.dot(n),
              h = a.dot(a).mul(d).sub(l.mul(l)),
              c = o.mul(l).sub(u.mul(d)).div(h).clamp(),
              p = o.add(l.mul(c)).div(d).clamp();
            return eG(c, p);
          });
          if (
            ((this.colorNode = eM(() => {
              let e,
                a = iZ();
              if (s) {
                let e = this.dashSizeNode ? eL(this.dashSizeNode) : n3,
                  t = this.gapSizeNode ? eL(this.gapSizeNode) : n4;
                tR.assign(e), tA.assign(t);
                let r = tn("float", "lineDistance");
                a.y.lessThan(-1).or(a.y.greaterThan(1)).discard(),
                  r.mod(tR.add(tA)).greaterThan(tR).discard();
              }
              let l = eL(1).toVar("alpha");
              if (n) {
                let e = tn("vec3", "worldStart"),
                  i = tn("vec3", "worldEnd"),
                  n = tn("vec4", "worldPos").xyz.normalize().mul(1e5),
                  a = i.sub(e),
                  u = o({ p1: e, p2: i, p3: eW(0, 0, 0), p4: n }),
                  d = e.add(a.mul(u.x)),
                  h = n.mul(u.y),
                  c = d.sub(h).length().div(n6);
                if (!s)
                  if (r && t.samples > 1) {
                    let e = c.fwidth();
                    l.assign(r2(e.negate().add(0.5), e.add(0.5), c).oneMinus());
                  } else c.greaterThan(0.5).discard();
              } else if (r && t.samples > 1) {
                let e = a.x,
                  t = a.y.greaterThan(0).select(a.y.sub(1), a.y.add(1)),
                  r = e.mul(e).add(t.mul(t)),
                  i = eL(r.fwidth()).toVar("dlen");
                eU(a.y.abs().greaterThan(1), () => {
                  l.assign(r2(i.oneMinus(), i.add(1), r).oneMinus());
                });
              } else
                eU(a.y.abs().greaterThan(1), () => {
                  let e = a.x,
                    t = a.y.greaterThan(0).select(a.y.sub(1), a.y.add(1));
                  e.mul(e).add(t.mul(t)).greaterThan(1).discard();
                });
              if (this.lineColorNode) e = this.lineColorNode;
              else if (i) {
                let t = iY("instanceColorStart"),
                  r = iY("instanceColorEnd");
                e = sB.y.lessThan(0.5).select(t, r).mul(nw);
              } else e = nw;
              return eX(e, l);
            })()),
            this.transparent)
          ) {
            let e = this.opacityNode ? eL(this.opacityNode) : nF;
            this.outputNode = eX(
              this.colorNode.rgb.mul(e).add(oh().rgb.mul(e.oneMinus())),
              this.colorNode.a
            );
          }
          super.setup(e);
        }
        get worldUnits() {
          return this._useWorldUnits;
        }
        set worldUnits(e) {
          this._useWorldUnits !== e &&
            ((this._useWorldUnits = e), (this.needsUpdate = !0));
        }
        get dashed() {
          return this._useDash;
        }
        set dashed(e) {
          this._useDash !== e && ((this._useDash = e), (this.needsUpdate = !0));
        }
        get alphaToCoverage() {
          return this._useAlphaToCoverage;
        }
        set alphaToCoverage(e) {
          this._useAlphaToCoverage !== e &&
            ((this._useAlphaToCoverage = e), (this.needsUpdate = !0));
        }
      }
      let og = (e) => eR(e).mul(0.5).add(0.5),
        om = new u.qBx();
      class of extends os {
        static get type() {
          return "MeshNormalNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshNormalNodeMaterial = !0),
            this.setDefaultValues(om),
            this.setValues(e);
        }
        setupDiffuseColor() {
          let e = this.opacityNode ? eL(this.opacityNode) : nF;
          ta.assign(iv(eX(og(sq), e), u.er$));
        }
      }
      class oy extends k {
        static get type() {
          return "EquirectUVNode";
        }
        constructor(e = sP) {
          super("vec2"), (this.dirNode = e);
        }
        setup() {
          let e = this.dirNode;
          return eG(
            e.z
              .atan(e.x)
              .mul(1 / (2 * Math.PI))
              .add(0.5),
            e.y
              .clamp(-1, 1)
              .asin()
              .mul(1 / Math.PI)
              .add(0.5)
          );
        }
      }
      let ox = eE(oy);
      class ob extends u.o6l {
        constructor(e = 1, t = {}) {
          super(e, t), (this.isCubeRenderTarget = !0);
        }
        fromEquirectangularTexture(e, t) {
          let r = t.minFilter,
            i = t.generateMipmaps;
          (t.generateMipmaps = !0),
            (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          let s = new u.iNn(5, 5, 5),
            n = ox(sP),
            a = new os();
          (a.colorNode = i4(t, n, 0)), (a.side = u.hsX), (a.blending = u.XIg);
          let o = new u.eaF(s, a),
            l = new u.Z58();
          l.add(o), t.minFilter === u.$_I && (t.minFilter = u.k6q);
          let d = new u.F1T(1, 10, this),
            h = e.getMRT();
          return (
            e.setMRT(null),
            d.update(e, l),
            e.setMRT(h),
            (t.minFilter = r),
            (t.currentGenerateMipmaps = i),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
      }
      let oT = new WeakMap();
      class o_ extends k {
        static get type() {
          return "CubeMapNode";
        }
        constructor(e) {
          super("vec3"),
            (this.envNode = e),
            (this._cubeTexture = null),
            (this._cubeTextureNode = s8());
          let t = new u.b4q();
          (t.isRenderTargetTexture = !0),
            (this._defaultTexture = t),
            (this.updateBeforeType = M.RENDER);
        }
        updateBefore(e) {
          let { renderer: t, material: r } = e,
            i = this.envNode;
          if (i.isTextureNode || i.isMaterialReferenceNode) {
            let e = i.isTextureNode ? i.value : r[i.property];
            if (e && e.isTexture) {
              let r = e.mapping;
              if (r === u.wfO || r === u.uV5) {
                if (oT.has(e)) {
                  let t = oT.get(e);
                  oN(t, e.mapping), (this._cubeTexture = t);
                } else {
                  var s;
                  let r = e.image;
                  if (null != (s = r) && s.height > 0) {
                    let i = new ob(r.height);
                    i.fromEquirectangularTexture(t, e),
                      oN(i.texture, e.mapping),
                      (this._cubeTexture = i.texture),
                      oT.set(e, i.texture),
                      e.addEventListener("dispose", ov);
                  } else this._cubeTexture = this._defaultTexture;
                }
                this._cubeTextureNode.value = this._cubeTexture;
              } else this._cubeTextureNode = this.envNode;
            }
          }
        }
        setup(e) {
          return this.updateBefore(e), this._cubeTextureNode;
        }
      }
      function ov(e) {
        let t = e.target;
        t.removeEventListener("dispose", ov);
        let r = oT.get(t);
        void 0 !== r && (oT.delete(t), r.dispose());
      }
      function oN(e, t) {
        t === u.wfO ? (e.mapping = u.hy7) : t === u.uV5 && (e.mapping = u.xFO);
      }
      let oS = eE(o_);
      class oR extends aC {
        static get type() {
          return "BasicEnvironmentNode";
        }
        constructor(e = null) {
          super(), (this.envNode = e);
        }
        setup(e) {
          e.context.environment = oS(this.envNode);
        }
      }
      class oA extends aC {
        static get type() {
          return "BasicLightMapNode";
        }
        constructor(e = null) {
          super(), (this.lightMapNode = e);
        }
        setup(e) {
          let t = eL(1 / Math.PI);
          e.context.irradianceLightMap = this.lightMapNode.mul(t);
        }
      }
      class oC {
        start(e) {
          e.lightsNode.setupLights(e, e.lightsNode.getLightNodes(e)),
            this.indirect(e);
        }
        finish() {}
        direct() {}
        directRectArea() {}
        indirect() {}
        ambientOcclusion() {}
      }
      class oE extends oC {
        constructor() {
          super();
        }
        indirect({ context: e }) {
          let t = e.ambientOcclusion,
            r = e.reflectedLight,
            i = e.irradianceLightMap;
          r.indirectDiffuse.assign(eX(0)),
            i
              ? r.indirectDiffuse.addAssign(i)
              : r.indirectDiffuse.addAssign(eX(1, 1, 1, 0)),
            r.indirectDiffuse.mulAssign(t),
            r.indirectDiffuse.mulAssign(ta.rgb);
        }
        finish(e) {
          let { material: t, context: r } = e,
            i = r.outgoingLight,
            s = e.context.environment;
          if (s)
            switch (t.combine) {
              case u.caT:
                i.rgb.assign(rZ(i.rgb, i.rgb.mul(s.rgb), nL.mul(nD)));
                break;
              case u.KRh:
                i.rgb.assign(rZ(i.rgb, s.rgb, nL.mul(nD)));
                break;
              case u.XrR:
                i.rgb.addAssign(s.rgb.mul(nL.mul(nD)));
                break;
              default:
                console.warn(
                  "THREE.BasicLightingModel: Unsupported .combine value:",
                  t.combine
                );
            }
        }
      }
      let ow = new u.V9B();
      class oM extends os {
        static get type() {
          return "MeshBasicNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshBasicNodeMaterial = !0),
            (this.lights = !0),
            this.setDefaultValues(ow),
            this.setValues(e);
        }
        setupNormal() {
          return sW;
        }
        setupEnvironment(e) {
          let t = super.setupEnvironment(e);
          return t ? new oR(t) : null;
        }
        setupLightMap(e) {
          let t = null;
          return e.material.lightMap && (t = new oA(n7)), t;
        }
        setupOutgoingLight() {
          return ta.rgb;
        }
        setupLightingModel() {
          return new oE();
        }
      }
      let oB = eM(({ f0: e, f90: t, dotVH: r }) => {
          let i = r.mul(-5.55473).sub(6.98316).mul(r).exp2();
          return e.mul(i.oneMinus()).add(t.mul(i));
        }),
        oF = eM((e) => e.diffuseColor.mul(1 / Math.PI)),
        oU = () => eL(0.25),
        oI = eM(({ dotNH: e }) =>
          tN
            .mul(eL(0.5))
            .add(1)
            .mul(eL(1 / Math.PI))
            .mul(e.pow(tN))
        ),
        oP = eM(({ lightDirection: e }) => {
          let t = e.add(sD).normalize(),
            r = sq.dot(t).clamp(),
            i = oB({ f0: t_, f90: 1, dotVH: sD.dot(t).clamp() }),
            s = oU(),
            n = oI({ dotNH: r });
          return i.mul(s).mul(n);
        });
      class oL extends oE {
        constructor(e = !0) {
          super(), (this.specular = e);
        }
        direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
          let i = sq.dot(e).clamp().mul(t);
          r.directDiffuse.addAssign(i.mul(oF({ diffuseColor: ta.rgb }))),
            !0 === this.specular &&
              r.directSpecular.addAssign(
                i.mul(oP({ lightDirection: e })).mul(nL)
              );
        }
        indirect(e) {
          let {
            ambientOcclusion: t,
            irradiance: r,
            reflectedLight: i,
          } = e.context;
          i.indirectDiffuse.addAssign(r.mul(oF({ diffuseColor: ta }))),
            i.indirectDiffuse.mulAssign(t);
        }
      }
      let oD = new u.G_z();
      class oV extends os {
        static get type() {
          return "MeshLambertNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshLambertNodeMaterial = !0),
            (this.lights = !0),
            this.setDefaultValues(oD),
            this.setValues(e);
        }
        setupEnvironment(e) {
          let t = super.setupEnvironment(e);
          return t ? new oR(t) : null;
        }
        setupLightingModel() {
          return new oL(!1);
        }
      }
      let oO = new u.tXL();
      class oG extends os {
        static get type() {
          return "MeshPhongNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhongNodeMaterial = !0),
            (this.lights = !0),
            (this.shininessNode = null),
            (this.specularNode = null),
            this.setDefaultValues(oO),
            this.setValues(e);
        }
        setupEnvironment(e) {
          let t = super.setupEnvironment(e);
          return t ? new oR(t) : null;
        }
        setupLightingModel() {
          return new oL();
        }
        setupVariants() {
          let e = (this.shininessNode ? eL(this.shininessNode) : nM).max(1e-4);
          tN.assign(e);
          let t = this.specularNode || nU;
          t_.assign(t);
        }
        copy(e) {
          return (
            (this.shininessNode = e.shininessNode),
            (this.specularNode = e.specularNode),
            super.copy(e)
          );
        }
      }
      let ok = eM((e) => {
          if (!1 === e.geometry.hasAttribute("normal")) return eL(0);
          let t = sW.dFdx().abs().max(sW.dFdy().abs());
          return t.x.max(t.y).max(t.z);
        }),
        oz = eM((e) => {
          let { roughness: t } = e,
            r = ok(),
            i = t.max(0.0525);
          return (i = i.add(r)).min(1);
        }),
        o$ = eM(({ alpha: e, dotNL: t, dotNV: r }) => {
          let i = e.pow2(),
            s = t.mul(i.add(i.oneMinus().mul(r.pow2())).sqrt()),
            n = r.mul(i.add(i.oneMinus().mul(t.pow2())).sqrt());
          return tz(0.5, s.add(n).max(t9));
        }).setLayout({
          name: "V_GGX_SmithCorrelated",
          type: "float",
          inputs: [
            { name: "alpha", type: "float" },
            { name: "dotNL", type: "float" },
            { name: "dotNV", type: "float" },
          ],
        }),
        oW = eM(
          ({
            alphaT: e,
            alphaB: t,
            dotTV: r,
            dotBV: i,
            dotTL: s,
            dotBL: n,
            dotNV: a,
            dotNL: o,
          }) => {
            let l = o.mul(eW(e.mul(r), t.mul(i), a).length()),
              u = a.mul(eW(e.mul(s), t.mul(n), o).length());
            return tz(0.5, l.add(u)).saturate();
          }
        ).setLayout({
          name: "V_GGX_SmithCorrelated_Anisotropic",
          type: "float",
          inputs: [
            { name: "alphaT", type: "float", qualifier: "in" },
            { name: "alphaB", type: "float", qualifier: "in" },
            { name: "dotTV", type: "float", qualifier: "in" },
            { name: "dotBV", type: "float", qualifier: "in" },
            { name: "dotTL", type: "float", qualifier: "in" },
            { name: "dotBL", type: "float", qualifier: "in" },
            { name: "dotNV", type: "float", qualifier: "in" },
            { name: "dotNL", type: "float", qualifier: "in" },
          ],
        }),
        oH = eM(({ alpha: e, dotNH: t }) => {
          let r = e.pow2(),
            i = t.pow2().mul(r.oneMinus()).oneMinus();
          return r.div(i.pow2()).mul(1 / Math.PI);
        }).setLayout({
          name: "D_GGX",
          type: "float",
          inputs: [
            { name: "alpha", type: "float" },
            { name: "dotNH", type: "float" },
          ],
        }),
        oq = eL(1 / Math.PI),
        oj = eM(({ alphaT: e, alphaB: t, dotNH: r, dotTH: i, dotBH: s }) => {
          let n = e.mul(t),
            a = eW(t.mul(i), e.mul(s), n.mul(r)),
            o = a.dot(a),
            l = n.div(o);
          return oq.mul(n.mul(l.pow2()));
        }).setLayout({
          name: "D_GGX_Anisotropic",
          type: "float",
          inputs: [
            { name: "alphaT", type: "float", qualifier: "in" },
            { name: "alphaB", type: "float", qualifier: "in" },
            { name: "dotNH", type: "float", qualifier: "in" },
            { name: "dotTH", type: "float", qualifier: "in" },
            { name: "dotBH", type: "float", qualifier: "in" },
          ],
        }),
        oX = eM((e) => {
          let t,
            r,
            {
              lightDirection: i,
              f0: s,
              f90: n,
              roughness: a,
              f: o,
              USE_IRIDESCENCE: l,
              USE_ANISOTROPY: u,
            } = e,
            d = e.normalView || sq,
            h = a.pow2(),
            c = i.add(sD).normalize(),
            p = d.dot(i).clamp(),
            g = d.dot(sD).clamp(),
            m = d.dot(c).clamp(),
            f = oB({ f0: s, f90: n, dotVH: sD.dot(c).clamp() });
          if ((ev(l) && (f = tg.mix(f, o)), ev(u))) {
            let e = tb.dot(i),
              s = tb.dot(sD),
              n = tb.dot(c),
              a = tT.dot(i),
              o = tT.dot(sD),
              l = tT.dot(c);
            (t = oW({
              alphaT: ty,
              alphaB: h,
              dotTV: s,
              dotBV: o,
              dotTL: e,
              dotBL: a,
              dotNV: g,
              dotNL: p,
            })),
              (r = oj({ alphaT: ty, alphaB: h, dotNH: m, dotTH: n, dotBH: l }));
          } else
            (t = o$({ alpha: h, dotNL: p, dotNV: g })),
              (r = oH({ alpha: h, dotNH: m }));
          return f.mul(t).mul(r);
        }),
        oQ = eM(({ roughness: e, dotNV: t }) => {
          let r = eX(-1, -0.0275, -0.572, 0.022),
            i = eX(1, 0.0425, 1.04, -0.04),
            s = e.mul(r).add(i),
            n = s.x.mul(s.x).min(t.mul(-9.28).exp2()).mul(s.x).add(s.y);
          return eG(-1.04, 1.04).mul(n).add(s.zw);
        }).setLayout({
          name: "DFGApprox",
          type: "vec2",
          inputs: [
            { name: "roughness", type: "float" },
            { name: "dotNV", type: "vec3" },
          ],
        }),
        oK = eM((e) => {
          let { dotNV: t, specularColor: r, specularF90: i, roughness: s } = e,
            n = oQ({ dotNV: t, roughness: s });
          return r.mul(n.x).add(i.mul(n.y));
        }),
        oY = eM(({ f: e, f90: t, dotVH: r }) => {
          let i = r.oneMinus().saturate(),
            s = i.mul(i),
            n = i.mul(s, s).clamp(0, 0.9999);
          return e.sub(eW(t).mul(n)).div(n.oneMinus());
        }).setLayout({
          name: "Schlick_to_F0",
          type: "vec3",
          inputs: [
            { name: "f", type: "vec3" },
            { name: "f90", type: "float" },
            { name: "dotVH", type: "float" },
          ],
        }),
        oZ = eM(({ roughness: e, dotNH: t }) => {
          let r = e.pow2(),
            i = eL(1).div(r),
            s = t.pow2().oneMinus().max(0.0078125);
          return eL(2)
            .add(i)
            .mul(s.pow(i.mul(0.5)))
            .div(2 * Math.PI);
        }).setLayout({
          name: "D_Charlie",
          type: "float",
          inputs: [
            { name: "roughness", type: "float" },
            { name: "dotNH", type: "float" },
          ],
        }),
        oJ = eM(({ dotNV: e, dotNL: t }) =>
          eL(1).div(eL(4).mul(t.add(e).sub(t.mul(e))))
        ).setLayout({
          name: "V_Neubelt",
          type: "float",
          inputs: [
            { name: "dotNV", type: "float" },
            { name: "dotNL", type: "float" },
          ],
        }),
        o0 = eM(({ lightDirection: e }) => {
          let t = e.add(sD).normalize(),
            r = sq.dot(e).clamp(),
            i = sq.dot(sD).clamp(),
            s = oZ({ roughness: tp, dotNH: sq.dot(t).clamp() }),
            n = oJ({ dotNV: i, dotNL: r });
          return tc.mul(s).mul(n);
        }),
        o1 = eM(({ N: e, V: t, roughness: r }) => {
          let i = eG(r, e.dot(t).saturate().oneMinus().sqrt());
          return i.assign(i.mul(0.984375).add(0.0078125)), i;
        }).setLayout({
          name: "LTC_Uv",
          type: "vec2",
          inputs: [
            { name: "N", type: "vec3" },
            { name: "V", type: "vec3" },
            { name: "roughness", type: "float" },
          ],
        }),
        o2 = eM(({ f: e }) => {
          let t = e.length();
          return rD(t.mul(t).add(e.z).div(t.add(1)), 0);
        }).setLayout({
          name: "LTC_ClippedSphereFormFactor",
          type: "float",
          inputs: [{ name: "f", type: "vec3" }],
        }),
        o3 = eM(({ v1: e, v2: t }) => {
          let r = e.dot(t),
            i = r.abs().toVar(),
            s = i.mul(0.0145206).add(0.4965155).mul(i).add(0.8543985).toVar(),
            n = i.add(4.1616724).mul(i).add(3.417594).toVar(),
            a = s.div(n),
            o = r
              .greaterThan(0)
              .select(
                a,
                rD(r.mul(r).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(a)
              );
          return e.cross(t).mul(o);
        }).setLayout({
          name: "LTC_EdgeVectorFormFactor",
          type: "vec3",
          inputs: [
            { name: "v1", type: "vec3" },
            { name: "v2", type: "vec3" },
          ],
        }),
        o4 = eM(({ N: e, V: t, P: r, mInv: i, p0: s, p1: n, p2: a, p3: o }) => {
          let l = n.sub(s).toVar(),
            u = o.sub(s).toVar(),
            d = l.cross(u),
            h = eW().toVar();
          return (
            eU(d.dot(r.sub(s)).greaterThanEqual(0), () => {
              let l = t.sub(e.mul(t.dot(e))).normalize(),
                u = e.cross(l).negate(),
                d = i.mul(eJ(l, u, e).transpose()).toVar(),
                c = d.mul(s.sub(r)).normalize().toVar(),
                p = d.mul(n.sub(r)).normalize().toVar(),
                g = d.mul(a.sub(r)).normalize().toVar(),
                m = d.mul(o.sub(r)).normalize().toVar(),
                f = eW(0).toVar();
              f.addAssign(o3({ v1: c, v2: p })),
                f.addAssign(o3({ v1: p, v2: g })),
                f.addAssign(o3({ v1: g, v2: m })),
                f.addAssign(o3({ v1: m, v2: c })),
                h.assign(eW(o2({ f: f })));
            }),
            h
          );
        }).setLayout({
          name: "LTC_Evaluate",
          type: "vec3",
          inputs: [
            { name: "N", type: "vec3" },
            { name: "V", type: "vec3" },
            { name: "P", type: "vec3" },
            { name: "mInv", type: "mat3" },
            { name: "p0", type: "vec3" },
            { name: "p1", type: "vec3" },
            { name: "p2", type: "vec3" },
            { name: "p3", type: "vec3" },
          ],
        }),
        o6 = eM(({ P: e, p0: t, p1: r, p2: i, p3: s }) => {
          let n = r.sub(t).toVar(),
            a = s.sub(t).toVar(),
            o = n.cross(a),
            l = eW().toVar();
          return (
            eU(o.dot(e.sub(t)).greaterThanEqual(0), () => {
              let n = t.sub(e).normalize().toVar(),
                a = r.sub(e).normalize().toVar(),
                o = i.sub(e).normalize().toVar(),
                u = s.sub(e).normalize().toVar(),
                d = eW(0).toVar();
              d.addAssign(o3({ v1: n, v2: a })),
                d.addAssign(o3({ v1: a, v2: o })),
                d.addAssign(o3({ v1: o, v2: u })),
                d.addAssign(o3({ v1: u, v2: n })),
                l.assign(eW(o2({ f: d.abs() })));
            }),
            l
          );
        }).setLayout({
          name: "LTC_Evaluate",
          type: "vec3",
          inputs: [
            { name: "P", type: "vec3" },
            { name: "p0", type: "vec3" },
            { name: "p1", type: "vec3" },
            { name: "p2", type: "vec3" },
            { name: "p3", type: "vec3" },
          ],
        }),
        o5 = 1 / 6,
        o8 = (e) => tk(o5, tk(e, tk(e, e.negate().add(3)).sub(3)).add(1)),
        o9 = (e) => tk(o5, tk(e, tk(e, tk(3, e).sub(6))).add(4)),
        o7 = (e) => tk(o5, tk(e, tk(e, tk(-3, e).add(3)).add(3)).add(1)),
        le = (e) => tk(o5, rH(e, 3)),
        lt = (e) => o8(e).add(o9(e)),
        lr = (e) => o7(e).add(le(e)),
        li = (e) => tO(-1, o9(e).div(o8(e).add(o9(e)))),
        ls = (e) => tO(1, le(e).div(o7(e).add(le(e)))),
        ln = (e, t, r) => {
          let i = tk(e.uvNode, t.zw).add(0.5),
            s = rc(i),
            n = rm(i),
            a = lt(n.x),
            o = lr(n.x),
            l = li(n.x),
            u = ls(n.x),
            d = li(n.y),
            h = ls(n.y),
            c = eG(s.x.add(l), s.y.add(d)).sub(0.5).mul(t.xy),
            p = eG(s.x.add(u), s.y.add(d)).sub(0.5).mul(t.xy),
            g = eG(s.x.add(l), s.y.add(h)).sub(0.5).mul(t.xy),
            m = eG(s.x.add(u), s.y.add(h)).sub(0.5).mul(t.xy),
            f = lt(n.y).mul(
              tO(a.mul(e.sample(c).level(r)), o.mul(e.sample(p).level(r)))
            ),
            y = lr(n.y).mul(
              tO(a.mul(e.sample(g).level(r)), o.mul(e.sample(m).level(r)))
            );
          return f.add(y);
        },
        la = eM(([e, t = eL(3)]) => {
          let r = eG(e.size(eD(t))),
            i = eG(e.size(eD(t.add(1)))),
            s = tz(1, r),
            n = tz(1, i),
            a = ln(e, eX(s, r), rc(t)),
            o = ln(e, eX(n, i), rp(t));
          return rm(t).mix(a, o);
        }),
        lo = eM(([e, t, r, i, s]) => {
          let n = eW(r1(t.negate(), rg(e), tz(1, i))),
            a = eW(rS(s[0].xyz), rS(s[1].xyz), rS(s[2].xyz));
          return rg(n).mul(r.mul(a));
        }).setLayout({
          name: "getVolumeTransmissionRay",
          type: "vec3",
          inputs: [
            { name: "n", type: "vec3" },
            { name: "v", type: "vec3" },
            { name: "thickness", type: "float" },
            { name: "ior", type: "float" },
            { name: "modelMatrix", type: "mat4" },
          ],
        }),
        ll = eM(([e, t]) => e.mul(rJ(t.mul(2).sub(2), 0, 1))).setLayout({
          name: "applyIorToRoughness",
          type: "float",
          inputs: [
            { name: "roughness", type: "float" },
            { name: "ior", type: "float" },
          ],
        }),
        lu = aq(),
        ld = aq(),
        lh = eM(([e, t, r], { material: i }) =>
          la((i.side === u.hsX ? lu : ld).sample(e), ru(aI.x).mul(ll(t, r)))
        ),
        lc = eM(
          ([e, t, r]) => (
            eU(r.notEqual(0), () => ra(rl(t).negate().div(r).negate().mul(e))),
            eW(1)
          )
        ).setLayout({
          name: "volumeAttenuation",
          type: "vec3",
          inputs: [
            { name: "transmissionDistance", type: "float" },
            { name: "attenuationColor", type: "vec3" },
            { name: "attenuationDistance", type: "float" },
          ],
        }),
        lp = eM(([e, t, r, i, s, n, a, o, l, u, d, h, c, p, g]) => {
          let m, f;
          if (g) {
            (m = eX().toVar()), (f = eW().toVar());
            let s = d.sub(1).mul(g.mul(0.025)),
              n = eW(d.sub(s), d, d.add(s));
            aT({ start: 0, end: 3 }, ({ i: s }) => {
              let d = n.element(s),
                g = lo(e, t, h, d, o),
                y = a.add(g),
                x = u.mul(l.mul(eX(y, 1))),
                b = eG(x.xy.div(x.w)).toVar();
              b.addAssign(1), b.divAssign(2), b.assign(eG(b.x, b.y.oneMinus()));
              let T = lh(b, r, d);
              m.element(s).assign(T.element(s)),
                m.a.addAssign(T.a),
                f
                  .element(s)
                  .assign(i.element(s).mul(lc(rS(g), c, p).element(s)));
            }),
              m.a.divAssign(3);
          } else {
            let s = lo(e, t, h, d, o),
              n = a.add(s),
              g = u.mul(l.mul(eX(n, 1))),
              y = eG(g.xy.div(g.w)).toVar();
            y.addAssign(1),
              y.divAssign(2),
              y.assign(eG(y.x, y.y.oneMinus())),
              (m = lh(y, r, d)),
              (f = i.mul(lc(rS(s), c, p)));
          }
          let y = f.rgb.mul(m.rgb),
            x = eW(
              oK({
                dotNV: e.dot(t).clamp(),
                specularColor: s,
                specularF90: n,
                roughness: r,
              })
            ),
            b = f.r.add(f.g, f.b).div(3);
          return eX(x.oneMinus().mul(y), m.a.oneMinus().mul(b).oneMinus());
        }),
        lg = eJ(
          3.2404542,
          -0.969266,
          0.0556434,
          -1.5371385,
          1.8760108,
          -0.2040259,
          -0.4985314,
          0.041556,
          1.0572252
        ),
        lm = (e) => {
          let t = e.sqrt();
          return eW(1).add(t).div(eW(1).sub(t));
        },
        lf = (e, t) => e.sub(t).div(e.add(t)).pow2(),
        ly = (e, t) => {
          let r = e.mul(2 * Math.PI * 1e-9),
            i = eW(54856e-17, 44201e-17, 52481e-17),
            s = eW(1681e3, 1795300, 2208400),
            n = eW(43278e5, 93046e5, 66121e5),
            a = eL(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5))
              .mul(r.mul(2239900).add(t.x).cos())
              .mul(r.pow2().mul(-45282e5).exp()),
            o = i
              .mul(n.mul(2 * Math.PI).sqrt())
              .mul(s.mul(r).add(t).cos())
              .mul(r.pow2().negate().mul(n).exp());
          return (o = eW(o.x.add(a), o.y, o.z).div(10685e-11)), lg.mul(o);
        },
        lx = eM(
          ({
            outsideIOR: e,
            eta2: t,
            cosTheta1: r,
            thinFilmThickness: i,
            baseF0: s,
          }) => {
            let n = rZ(e, t, r2(0, 0.03, i)),
              a = e.div(n).pow2().mul(r.pow2().oneMinus()).oneMinus();
            eU(a.lessThan(0), () => eW(1));
            let o = a.sqrt(),
              l = oB({ f0: lf(n, e), f90: 1, dotVH: r }),
              u = l.oneMinus(),
              d = n.lessThan(e).select(Math.PI, 0),
              h = eL(Math.PI).sub(d),
              c = lm(s.clamp(0, 0.9999)),
              p = oB({ f0: lf(c, n.toVec3()), f90: 1, dotVH: o }),
              g = eW(
                c.x.lessThan(n).select(Math.PI, 0),
                c.y.lessThan(n).select(Math.PI, 0),
                c.z.lessThan(n).select(Math.PI, 0)
              ),
              m = n.mul(i, o, 2),
              f = eW(h).add(g),
              y = l.mul(p).clamp(1e-5, 0.9999),
              x = y.sqrt(),
              b = u.pow2().mul(p).div(eW(1).sub(y)),
              T = l.add(b).toVar(),
              _ = b.sub(u).toVar();
            return (
              aT(
                { start: 1, end: 2, condition: "<=", name: "m" },
                ({ m: e }) => {
                  _.mulAssign(x);
                  let t = ly(eL(e).mul(m), eL(e).mul(f)).mul(2);
                  T.addAssign(_.mul(t));
                }
              ),
              T.max(eW(0))
            );
          }
        ).setLayout({
          name: "evalIridescence",
          type: "vec3",
          inputs: [
            { name: "outsideIOR", type: "float" },
            { name: "eta2", type: "float" },
            { name: "cosTheta1", type: "float" },
            { name: "thinFilmThickness", type: "float" },
            { name: "baseF0", type: "vec3" },
          ],
        }),
        lb = eM(({ normal: e, viewDir: t, roughness: r }) => {
          let i = e.dot(t).saturate(),
            s = r.pow2(),
            n = r7(
              r.lessThan(0.25),
              eL(-339.2).mul(s).add(eL(161.4).mul(r)).sub(25.9),
              eL(-8.48).mul(s).add(eL(14.3).mul(r)).sub(9.95)
            ),
            a = r7(
              r.lessThan(0.25),
              eL(44).mul(s).sub(eL(23.7).mul(r)).add(3.26),
              eL(1.97).mul(s).sub(eL(3.27).mul(r)).add(0.72)
            );
          return r7(r.lessThan(0.25), 0, eL(0.1).mul(r).sub(0.025))
            .add(n.mul(i).add(a).exp())
            .mul(1 / Math.PI)
            .saturate();
        }),
        lT = eW(0.04),
        l_ = eL(1);
      class lv extends oC {
        constructor(e = !1, t = !1, r = !1, i = !1, s = !1, n = !1) {
          super(),
            (this.clearcoat = e),
            (this.sheen = t),
            (this.iridescence = r),
            (this.anisotropy = i),
            (this.transmission = s),
            (this.dispersion = n),
            (this.clearcoatRadiance = null),
            (this.clearcoatSpecularDirect = null),
            (this.clearcoatSpecularIndirect = null),
            (this.sheenSpecularDirect = null),
            (this.sheenSpecularIndirect = null),
            (this.iridescenceFresnel = null),
            (this.iridescenceF0 = null);
        }
        start(e) {
          if (
            (!0 === this.clearcoat &&
              ((this.clearcoatRadiance = eW().toVar("clearcoatRadiance")),
              (this.clearcoatSpecularDirect = eW().toVar(
                "clearcoatSpecularDirect"
              )),
              (this.clearcoatSpecularIndirect = eW().toVar(
                "clearcoatSpecularIndirect"
              ))),
            !0 === this.sheen &&
              ((this.sheenSpecularDirect = eW().toVar("sheenSpecularDirect")),
              (this.sheenSpecularIndirect = eW().toVar(
                "sheenSpecularIndirect"
              ))),
            !0 === this.iridescence)
          ) {
            let e = sq.dot(sD).clamp();
            (this.iridescenceFresnel = lx({
              outsideIOR: eL(1),
              eta2: tm,
              cosTheta1: e,
              thinFilmThickness: tf,
              baseF0: t_,
            })),
              (this.iridescenceF0 = oY({
                f: this.iridescenceFresnel,
                f90: 1,
                dotVH: e,
              }));
          }
          if (!0 === this.transmission) {
            let t = su.sub(sI).normalize(),
              r = e.context;
            (r.backdrop = lp(
              sj,
              t,
              tl,
              ta,
              t_,
              tv,
              sI,
              sT,
              sa,
              ss,
              tE,
              tM,
              tF,
              tB,
              this.dispersion ? tU : null
            )),
              (r.backdropAlpha = tw),
              ta.a.mulAssign(rZ(1, r.backdrop.a, tw));
          }
          super.start(e);
        }
        computeMultiscattering(e, t, r) {
          let i = oQ({ roughness: tl, dotNV: sq.dot(sD).clamp() }),
            s = (this.iridescenceF0 ? tg.mix(t_, this.iridescenceF0) : t_)
              .mul(i.x)
              .add(r.mul(i.y)),
            n = i.x.add(i.y).oneMinus(),
            a = t_.add(t_.oneMinus().mul(0.047619)),
            o = s.mul(a).div(n.mul(a).oneMinus());
          e.addAssign(s), t.addAssign(o.mul(n));
        }
        direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
          let i = sq.dot(e).clamp().mul(t);
          if (
            (!0 === this.sheen &&
              this.sheenSpecularDirect.addAssign(
                i.mul(o0({ lightDirection: e }))
              ),
            !0 === this.clearcoat)
          ) {
            let r = sX.dot(e).clamp().mul(t);
            this.clearcoatSpecularDirect.addAssign(
              r.mul(
                oX({
                  lightDirection: e,
                  f0: lT,
                  f90: l_,
                  roughness: th,
                  normalView: sX,
                })
              )
            );
          }
          r.directDiffuse.addAssign(i.mul(oF({ diffuseColor: ta.rgb }))),
            r.directSpecular.addAssign(
              i.mul(
                oX({
                  lightDirection: e,
                  f0: t_,
                  f90: 1,
                  roughness: tl,
                  iridescence: this.iridescence,
                  f: this.iridescenceFresnel,
                  USE_IRIDESCENCE: this.iridescence,
                  USE_ANISOTROPY: this.anisotropy,
                })
              )
            );
        }
        directRectArea({
          lightColor: e,
          lightPosition: t,
          halfWidth: r,
          halfHeight: i,
          reflectedLight: s,
          ltc_1: n,
          ltc_2: a,
        }) {
          let o = t.add(r).sub(i),
            l = t.sub(r).sub(i),
            u = t.sub(r).add(i),
            d = t.add(r).add(i),
            h = sL.toVar(),
            c = o1({ N: sq, V: sD, roughness: tl }),
            p = n.sample(c).toVar(),
            g = a.sample(c).toVar(),
            m = eJ(eW(p.x, 0, p.y), eW(0, 1, 0), eW(p.z, 0, p.w)).toVar(),
            f = t_.mul(g.x).add(t_.oneMinus().mul(g.y)).toVar();
          s.directSpecular.addAssign(
            e
              .mul(f)
              .mul(
                o4({ N: sq, V: sD, P: h, mInv: m, p0: o, p1: l, p2: u, p3: d })
              )
          ),
            s.directDiffuse.addAssign(
              e
                .mul(ta)
                .mul(
                  o4({
                    N: sq,
                    V: sD,
                    P: h,
                    mInv: eJ(1, 0, 0, 0, 1, 0, 0, 0, 1),
                    p0: o,
                    p1: l,
                    p2: u,
                    p3: d,
                  })
                )
            );
        }
        indirect(e) {
          this.indirectDiffuse(e),
            this.indirectSpecular(e),
            this.ambientOcclusion(e);
        }
        indirectDiffuse(e) {
          let { irradiance: t, reflectedLight: r } = e.context;
          r.indirectDiffuse.addAssign(t.mul(oF({ diffuseColor: ta })));
        }
        indirectSpecular(e) {
          let { radiance: t, iblIrradiance: r, reflectedLight: i } = e.context;
          if (
            (!0 === this.sheen &&
              this.sheenSpecularIndirect.addAssign(
                r.mul(tc, lb({ normal: sq, viewDir: sD, roughness: tp }))
              ),
            !0 === this.clearcoat)
          ) {
            let e = oK({
              dotNV: sX.dot(sD).clamp(),
              specularColor: lT,
              specularF90: l_,
              roughness: th,
            });
            this.clearcoatSpecularIndirect.addAssign(
              this.clearcoatRadiance.mul(e)
            );
          }
          let s = eW().toVar("singleScattering"),
            n = eW().toVar("multiScattering"),
            a = r.mul(1 / Math.PI);
          this.computeMultiscattering(s, n, tv);
          let o = s.add(n),
            l = ta.mul(o.r.max(o.g).max(o.b).oneMinus());
          i.indirectSpecular.addAssign(t.mul(s)),
            i.indirectSpecular.addAssign(n.mul(a)),
            i.indirectDiffuse.addAssign(l.mul(a));
        }
        ambientOcclusion(e) {
          let { ambientOcclusion: t, reflectedLight: r } = e.context,
            i = sq.dot(sD).clamp().add(t),
            s = tl.mul(-16).oneMinus().negate().exp2(),
            n = t.sub(i.pow(s).oneMinus()).clamp();
          !0 === this.clearcoat && this.clearcoatSpecularIndirect.mulAssign(t),
            !0 === this.sheen && this.sheenSpecularIndirect.mulAssign(t),
            r.indirectDiffuse.mulAssign(t),
            r.indirectSpecular.mulAssign(n);
        }
        finish({ context: e }) {
          let { outgoingLight: t } = e;
          if (!0 === this.clearcoat) {
            let e = oB({ dotVH: sX.dot(sD).clamp(), f0: lT, f90: l_ }),
              r = t
                .mul(td.mul(e).oneMinus())
                .add(
                  this.clearcoatSpecularDirect
                    .add(this.clearcoatSpecularIndirect)
                    .mul(td)
                );
            t.assign(r);
          }
          if (!0 === this.sheen) {
            let e = tc.r.max(tc.g).max(tc.b).mul(0.157).oneMinus(),
              r = t
                .mul(e)
                .add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
            t.assign(r);
          }
        }
      }
      let lN = eL(1),
        lS = eL(-2),
        lR = eL(0.8),
        lA = eL(-1),
        lC = eL(0.4),
        lE = eL(2),
        lw = eL(0.305),
        lM = eL(3),
        lB = eL(0.21),
        lF = eL(4),
        lU = eL(4),
        lI = eL(16),
        lP = eM(([e]) => {
          let t = eW(rv(e)).toVar(),
            r = eL(-1).toVar();
          return (
            eU(t.x.greaterThan(t.z), () => {
              eU(t.x.greaterThan(t.y), () => {
                r.assign(r7(e.x.greaterThan(0), 0, 3));
              }).Else(() => {
                r.assign(r7(e.y.greaterThan(0), 1, 4));
              });
            }).Else(() => {
              eU(t.z.greaterThan(t.y), () => {
                r.assign(r7(e.z.greaterThan(0), 2, 5));
              }).Else(() => {
                r.assign(r7(e.y.greaterThan(0), 1, 4));
              });
            }),
            r
          );
        }).setLayout({
          name: "getFace",
          type: "float",
          inputs: [{ name: "direction", type: "vec3" }],
        }),
        lL = eM(([e, t]) => {
          let r = eG().toVar();
          return (
            eU(t.equal(0), () => {
              r.assign(eG(e.z, e.y).div(rv(e.x)));
            })
              .ElseIf(t.equal(1), () => {
                r.assign(eG(e.x.negate(), e.z.negate()).div(rv(e.y)));
              })
              .ElseIf(t.equal(2), () => {
                r.assign(eG(e.x.negate(), e.y).div(rv(e.z)));
              })
              .ElseIf(t.equal(3), () => {
                r.assign(eG(e.z.negate(), e.y).div(rv(e.x)));
              })
              .ElseIf(t.equal(4), () => {
                r.assign(eG(e.x.negate(), e.z).div(rv(e.y)));
              })
              .Else(() => {
                r.assign(eG(e.x, e.y).div(rv(e.z)));
              }),
            tk(0.5, r.add(1))
          );
        }).setLayout({
          name: "getUV",
          type: "vec2",
          inputs: [
            { name: "direction", type: "vec3" },
            { name: "face", type: "float" },
          ],
        }),
        lD = eM(([e]) => {
          let t = eL(0).toVar();
          return (
            eU(e.greaterThanEqual(lR), () => {
              t.assign(lN.sub(e).mul(lA.sub(lS)).div(lN.sub(lR)).add(lS));
            })
              .ElseIf(e.greaterThanEqual(lC), () => {
                t.assign(lR.sub(e).mul(lE.sub(lA)).div(lR.sub(lC)).add(lA));
              })
              .ElseIf(e.greaterThanEqual(lw), () => {
                t.assign(lC.sub(e).mul(lM.sub(lE)).div(lC.sub(lw)).add(lE));
              })
              .ElseIf(e.greaterThanEqual(lB), () => {
                t.assign(lw.sub(e).mul(lF.sub(lM)).div(lw.sub(lB)).add(lM));
              })
              .Else(() => {
                t.assign(eL(-2).mul(ru(tk(1.16, e))));
              }),
            t
          );
        }).setLayout({
          name: "roughnessToMip",
          type: "float",
          inputs: [{ name: "roughness", type: "float" }],
        }),
        lV = eM(([e, t]) => {
          let r = e.toVar();
          r.assign(tk(2, r).sub(1));
          let i = eW(r, 1).toVar();
          return (
            eU(t.equal(0), () => {
              i.assign(i.zyx);
            })
              .ElseIf(t.equal(1), () => {
                i.assign(i.xzy), i.xz.mulAssign(-1);
              })
              .ElseIf(t.equal(2), () => {
                i.x.mulAssign(-1);
              })
              .ElseIf(t.equal(3), () => {
                i.assign(i.zyx), i.xz.mulAssign(-1);
              })
              .ElseIf(t.equal(4), () => {
                i.assign(i.xzy), i.xy.mulAssign(-1);
              })
              .ElseIf(t.equal(5), () => {
                i.z.mulAssign(-1);
              }),
            i
          );
        }).setLayout({
          name: "getDirection",
          type: "vec3",
          inputs: [
            { name: "uv", type: "vec2" },
            { name: "face", type: "float" },
          ],
        }),
        lO = eM(([e, t, r, i, s, n]) => {
          let a = eL(r),
            o = eW(t),
            l = rJ(lD(a), lS, n),
            u = rm(l),
            d = rc(l),
            h = eW(lG(e, o, d, i, s, n)).toVar();
          return (
            eU(u.notEqual(0), () => {
              let t = eW(lG(e, o, d.add(1), i, s, n)).toVar();
              h.assign(rZ(h, t, u));
            }),
            h
          );
        }),
        lG = eM(([e, t, r, i, s, n]) => {
          let a = eL(r).toVar(),
            o = eW(t),
            l = eL(lP(o)).toVar(),
            u = eL(rD(lU.sub(a), 0)).toVar();
          a.assign(rD(a, lU));
          let d = eL(ro(a)).toVar(),
            h = eG(lL(o, l).mul(d.sub(2)).add(1)).toVar();
          return (
            eU(l.greaterThan(2), () => {
              h.y.addAssign(d), l.subAssign(3);
            }),
            h.x.addAssign(l.mul(d)),
            h.x.addAssign(u.mul(tk(3, lI))),
            h.y.addAssign(tk(4, ro(n).sub(d))),
            h.x.mulAssign(i),
            h.y.mulAssign(s),
            e.sample(h).grad(eG(), eG())
          );
        }),
        lk = eM(
          ({
            envMap: e,
            mipInt: t,
            outputDirection: r,
            theta: i,
            axis: s,
            CUBEUV_TEXEL_WIDTH: n,
            CUBEUV_TEXEL_HEIGHT: a,
            CUBEUV_MAX_MIP: o,
          }) => {
            let l = ry(i);
            return lG(
              e,
              r
                .mul(l)
                .add(s.cross(r).mul(rf(i)))
                .add(s.mul(s.dot(r).mul(l.oneMinus()))),
              t,
              n,
              a,
              o
            );
          }
        ),
        lz = eM(
          ({
            n: e,
            latitudinal: t,
            poleAxis: r,
            outputDirection: i,
            weights: s,
            samples: n,
            dTheta: a,
            mipInt: o,
            envMap: l,
            CUBEUV_TEXEL_WIDTH: u,
            CUBEUV_TEXEL_HEIGHT: d,
            CUBEUV_MAX_MIP: h,
          }) => {
            let c = eW(r7(t, r, rW(r, i))).toVar();
            eU(rr(c.equals(eW(0))), () => {
              c.assign(eW(i.z, 0, i.x.negate()));
            }),
              c.assign(rg(c));
            let p = eW().toVar();
            return (
              p.addAssign(
                s
                  .element(0)
                  .mul(
                    lk({
                      theta: 0,
                      axis: c,
                      outputDirection: i,
                      mipInt: o,
                      envMap: l,
                      CUBEUV_TEXEL_WIDTH: u,
                      CUBEUV_TEXEL_HEIGHT: d,
                      CUBEUV_MAX_MIP: h,
                    })
                  )
              ),
              aT({ start: eD(1), end: e }, ({ i: e }) => {
                eU(e.greaterThanEqual(n), () => {
                  a_();
                });
                let t = eL(a.mul(eL(e))).toVar();
                p.addAssign(
                  s
                    .element(e)
                    .mul(
                      lk({
                        theta: t.mul(-1),
                        axis: c,
                        outputDirection: i,
                        mipInt: o,
                        envMap: l,
                        CUBEUV_TEXEL_WIDTH: u,
                        CUBEUV_TEXEL_HEIGHT: d,
                        CUBEUV_MAX_MIP: h,
                      })
                    )
                ),
                  p.addAssign(
                    s
                      .element(e)
                      .mul(
                        lk({
                          theta: t,
                          axis: c,
                          outputDirection: i,
                          mipInt: o,
                          envMap: l,
                          CUBEUV_TEXEL_WIDTH: u,
                          CUBEUV_TEXEL_HEIGHT: d,
                          CUBEUV_MAX_MIP: h,
                        })
                      )
                  );
              }),
              eX(p, 1)
            );
          }
        ),
        l$ = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        lW = new u.qUd(-1, 1, 1, -1, 0, 1),
        lH = new u.ubm(90, 1),
        lq = new u.Q1f(),
        lj = null,
        lX = 0,
        lQ = 0,
        lK = (1 + Math.sqrt(5)) / 2,
        lY = 1 / lK,
        lZ = [
          new u.Pq0(-lK, lY, 0),
          new u.Pq0(lK, lY, 0),
          new u.Pq0(-lY, 0, lK),
          new u.Pq0(lY, 0, lK),
          new u.Pq0(0, lK, -lY),
          new u.Pq0(0, lK, lY),
          new u.Pq0(-1, 1, -1),
          new u.Pq0(1, 1, -1),
          new u.Pq0(-1, 1, 1),
          new u.Pq0(1, 1, 1),
        ],
        lJ = new u.Pq0(),
        l0 = new WeakMap(),
        l1 = [3, 1, 5, 0, 4, 2],
        l2 = lV(iZ(), iY("faceIndex")).normalize(),
        l3 = eW(l2.x, l2.y, l2.z);
      class l4 {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._lodMeshes = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            (this._backgroundBox = null);
        }
        get _hasInitialized() {
          return this._renderer.hasInitialized();
        }
        fromScene(e, t = 0, r = 0.1, i = 100, s = {}) {
          let { size: n = 256, position: a = lJ, renderTarget: o = null } = s;
          if ((this._setSize(n), !1 === this._hasInitialized)) {
            console.warn(
              "THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead."
            );
            let n = o || this._allocateTargets();
            return (s.renderTarget = n), this.fromSceneAsync(e, t, r, i, s), n;
          }
          (lj = this._renderer.getRenderTarget()),
            (lX = this._renderer.getActiveCubeFace()),
            (lQ = this._renderer.getActiveMipmapLevel());
          let l = o || this._allocateTargets();
          return (
            (l.depthBuffer = !0),
            this._sceneToCubeUV(e, r, i, l, a),
            t > 0 && this._blur(l, 0, 0, t),
            this._applyPMREM(l),
            this._cleanup(l),
            l
          );
        }
        async fromSceneAsync(e, t = 0, r = 0.1, i = 100, s = {}) {
          return (
            !1 === this._hasInitialized && (await this._renderer.init()),
            this.fromScene(e, t, r, i, s)
          );
        }
        fromEquirectangular(e, t = null) {
          if (!1 === this._hasInitialized) {
            console.warn(
              "THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."
            ),
              this._setSizeFromTexture(e);
            let r = t || this._allocateTargets();
            return this.fromEquirectangularAsync(e, r), r;
          }
          return this._fromTexture(e, t);
        }
        async fromEquirectangularAsync(e, t = null) {
          return (
            !1 === this._hasInitialized && (await this._renderer.init()),
            this._fromTexture(e, t)
          );
        }
        fromCubemap(e, t = null) {
          if (!1 === this._hasInitialized) {
            console.warn(
              "THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."
            ),
              this._setSizeFromTexture(e);
            let r = t || this._allocateTargets();
            return this.fromCubemapAsync(e, t), r;
          }
          return this._fromTexture(e, t);
        }
        async fromCubemapAsync(e, t = null) {
          return (
            !1 === this._hasInitialized && (await this._renderer.init()),
            this._fromTexture(e, t)
          );
        }
        async compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = l9()),
            await this._compileMaterial(this._cubemapMaterial));
        }
        async compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = l7()),
            await this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose(),
            null !== this._backgroundBox &&
              (this._backgroundBox.geometry.dispose(),
              this._backgroundBox.material.dispose());
        }
        _setSizeFromTexture(e) {
          e.mapping === u.hy7 || e.mapping === u.xFO
            ? this._setSize(
                0 === e.image.length
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4);
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(lj, lX, lQ),
            (e.scissorTest = !1),
            l5(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          this._setSizeFromTexture(e),
            (lj = this._renderer.getRenderTarget()),
            (lX = this._renderer.getActiveCubeFace()),
            (lQ = this._renderer.getActiveMipmapLevel());
          let r = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, r),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        _allocateTargets() {
          let e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            r = {
              magFilter: u.k6q,
              minFilter: u.k6q,
              generateMipmaps: !1,
              type: u.ix0,
              format: u.GWd,
              colorSpace: u.Zr2,
            },
            i = l6(e, t, r);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = l6(e, t, r));
            let { _lodMax: i } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
              lodMeshes: this._lodMeshes,
            } = (function (e) {
              let t = [],
                r = [],
                i = [],
                s = [],
                n = e,
                a = e - 4 + 1 + l$.length;
              for (let o = 0; o < a; o++) {
                let a = Math.pow(2, n);
                r.push(a);
                let l = 1 / a;
                o > e - 4 ? (l = l$[o - e + 4 - 1]) : 0 === o && (l = 0),
                  i.push(l);
                let d = 1 / (a - 2),
                  h = -d,
                  c = 1 + d,
                  p = [h, h, c, h, c, c, h, h, c, c, h, c],
                  g = new Float32Array(108),
                  m = new Float32Array(72),
                  f = new Float32Array(36);
                for (let e = 0; e < 6; e++) {
                  let t = ((e % 3) * 2) / 3 - 1,
                    r = e > 2 ? 0 : -1,
                    i = [
                      t,
                      r,
                      0,
                      t + 2 / 3,
                      r,
                      0,
                      t + 2 / 3,
                      r + 1,
                      0,
                      t,
                      r,
                      0,
                      t + 2 / 3,
                      r + 1,
                      0,
                      t,
                      r + 1,
                      0,
                    ],
                    s = l1[e];
                  g.set(i, 18 * s), m.set(p, 12 * s);
                  let n = [s, s, s, s, s, s];
                  f.set(n, 6 * s);
                }
                let y = new u.LoY();
                y.setAttribute("position", new u.THS(g, 3)),
                  y.setAttribute("uv", new u.THS(m, 2)),
                  y.setAttribute("faceIndex", new u.THS(f, 1)),
                  t.push(y),
                  s.push(new u.eaF(y, null)),
                  n > 4 && n--;
              }
              return { lodPlanes: t, sizeLods: r, sigmas: i, lodMeshes: s };
            })(i)),
              (this._blurMaterial = (function (e, t, r) {
                let i = se(Array(20).fill(0)),
                  s = tr(new u.Pq0(0, 1, 0)),
                  n = tr(0),
                  a = eL(20),
                  o = tr(0),
                  l = tr(1),
                  d = i4(null),
                  h = tr(0),
                  c = eL(1 / t),
                  p = {
                    n: a,
                    latitudinal: o,
                    weights: i,
                    poleAxis: s,
                    outputDirection: l3,
                    dTheta: n,
                    samples: l,
                    envMap: d,
                    mipInt: h,
                    CUBEUV_TEXEL_WIDTH: c,
                    CUBEUV_TEXEL_HEIGHT: eL(1 / r),
                    CUBEUV_MAX_MIP: eL(e),
                  },
                  g = l8("blur");
                return (
                  (g.fragmentNode = lz({ ...p, latitudinal: o.equal(1) })),
                  l0.set(g, p),
                  g
                );
              })(i, e, t));
          }
          return i;
        }
        async _compileMaterial(e) {
          let t = new u.eaF(this._lodPlanes[0], e);
          await this._renderer.compile(t, lW);
        }
        _sceneToCubeUV(e, t, r, i, s) {
          (lH.near = t), (lH.far = r);
          let n = [1, 1, 1, 1, -1, 1],
            a = [1, -1, 1, -1, 1, -1],
            o = this._renderer,
            l = o.autoClear;
          o.getClearColor(lq), (o.autoClear = !1);
          let d = this._backgroundBox;
          if (null === d) {
            let e = new u.V9B({
              name: "PMREM.Background",
              side: u.hsX,
              depthWrite: !1,
              depthTest: !1,
            });
            d = new u.eaF(new u.iNn(), e);
          }
          let h = !1,
            c = e.background;
          c
            ? c.isColor &&
              (d.material.color.copy(c), (e.background = null), (h = !0))
            : (d.material.color.copy(lq), (h = !0)),
            o.setRenderTarget(i),
            o.clear(),
            h && o.render(d, lH);
          for (let t = 0; t < 6; t++) {
            let r = t % 3;
            0 === r
              ? (lH.up.set(0, n[t], 0),
                lH.position.set(s.x, s.y, s.z),
                lH.lookAt(s.x + a[t], s.y, s.z))
              : 1 === r
              ? (lH.up.set(0, 0, n[t]),
                lH.position.set(s.x, s.y, s.z),
                lH.lookAt(s.x, s.y + a[t], s.z))
              : (lH.up.set(0, n[t], 0),
                lH.position.set(s.x, s.y, s.z),
                lH.lookAt(s.x, s.y, s.z + a[t]));
            let l = this._cubeSize;
            l5(i, r * l, t > 2 ? l : 0, l, l), o.render(e, lH);
          }
          (o.autoClear = l), (e.background = c);
        }
        _textureToCubeUV(e, t) {
          let r = this._renderer,
            i = e.mapping === u.hy7 || e.mapping === u.xFO;
          i
            ? null === this._cubemapMaterial && (this._cubemapMaterial = l9(e))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = l7(e));
          let s = i ? this._cubemapMaterial : this._equirectMaterial;
          s.fragmentNode.value = e;
          let n = this._lodMeshes[0];
          n.material = s;
          let a = this._cubeSize;
          l5(t, 0, 0, 3 * a, 2 * a), r.setRenderTarget(t), r.render(n, lW);
        }
        _applyPMREM(e) {
          let t = this._renderer,
            r = t.autoClear;
          t.autoClear = !1;
          let i = this._lodPlanes.length;
          for (let t = 1; t < i; t++) {
            let r = Math.sqrt(
                this._sigmas[t] * this._sigmas[t] -
                  this._sigmas[t - 1] * this._sigmas[t - 1]
              ),
              s = lZ[(i - t - 1) % lZ.length];
            this._blur(e, t - 1, t, r, s);
          }
          t.autoClear = r;
        }
        _blur(e, t, r, i, s) {
          let n = this._pingPongRenderTarget;
          this._halfBlur(e, n, t, r, i, "latitudinal", s),
            this._halfBlur(n, e, r, r, i, "longitudinal", s);
        }
        _halfBlur(e, t, r, i, s, n, a) {
          let o = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== n &&
            "longitudinal" !== n &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          let u = this._lodMeshes[i];
          u.material = l;
          let d = l0.get(l),
            h = this._sizeLods[r] - 1,
            c = isFinite(s) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = s / c,
            g = isFinite(s) ? 1 + Math.floor(3 * p) : 20;
          g > 20 &&
            console.warn(
              `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to 20`
            );
          let m = [],
            f = 0;
          for (let e = 0; e < 20; ++e) {
            let t = e / p,
              r = Math.exp((-t * t) / 2);
            m.push(r), 0 === e ? (f += r) : e < g && (f += 2 * r);
          }
          for (let e = 0; e < m.length; e++) m[e] = m[e] / f;
          (e.texture.frame = (e.texture.frame || 0) + 1),
            (d.envMap.value = e.texture),
            (d.samples.value = g),
            (d.weights.array = m),
            (d.latitudinal.value = +("latitudinal" === n)),
            a && (d.poleAxis.value = a);
          let { _lodMax: y } = this;
          (d.dTheta.value = c), (d.mipInt.value = y - r);
          let x = this._sizeLods[i],
            b = 4 * (this._cubeSize - x);
          l5(t, 3 * x * (i > y - 4 ? i - y + 4 : 0), b, 3 * x, 2 * x),
            o.setRenderTarget(t),
            o.render(u, lW);
        }
      }
      function l6(e, t, r) {
        let i = new u.O0B(e, t, r);
        return (
          (i.texture.mapping = u.Om),
          (i.texture.name = "PMREM.cubeUv"),
          (i.texture.isPMREMTexture = !0),
          (i.scissorTest = !0),
          i
        );
      }
      function l5(e, t, r, i, s) {
        e.viewport.set(t, r, i, s), e.scissor.set(t, r, i, s);
      }
      function l8(e) {
        let t = new os();
        return (
          (t.depthTest = !1),
          (t.depthWrite = !1),
          (t.blending = u.XIg),
          (t.name = `PMREM_${e}`),
          t
        );
      }
      function l9(e) {
        let t = l8("cubemap");
        return (t.fragmentNode = s8(e, l3)), t;
      }
      function l7(e) {
        let t = l8("equirect");
        return (t.fragmentNode = i4(e, ox(l3), 0)), t;
      }
      let ue = new WeakMap();
      class ut extends k {
        static get type() {
          return "PMREMNode";
        }
        constructor(e, t = null, r = null) {
          super("vec3"),
            (this._value = e),
            (this._pmrem = null),
            (this.uvNode = t),
            (this.levelNode = r),
            (this._generator = null);
          let i = new u.gPd();
          (i.isRenderTargetTexture = !0),
            (this._texture = i4(i)),
            (this._width = tr(0)),
            (this._height = tr(0)),
            (this._maxMip = tr(0)),
            (this.updateBeforeType = M.RENDER);
        }
        set value(e) {
          (this._value = e), (this._pmrem = null);
        }
        get value() {
          return this._value;
        }
        updateFromTexture(e) {
          let t = (function (e) {
            let t = Math.log2(e) - 2;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
              texelHeight: 1 / e,
              maxMip: t,
            };
          })(e.image.height);
          (this._texture.value = e),
            (this._width.value = t.texelWidth),
            (this._height.value = t.texelHeight),
            (this._maxMip.value = t.maxMip);
        }
        updateBefore(e) {
          let t = this._pmrem,
            r = t ? t.pmremVersion : -1,
            i = this._value;
          r !== i.pmremVersion &&
            null !==
              (t =
                !0 === i.isPMREMTexture
                  ? i
                  : (function (e, t, r) {
                      var i, s;
                      let n,
                        a =
                          ((i = t),
                          void 0 === (n = ue.get(i)) &&
                            ((n = new WeakMap()), ue.set(i, n)),
                          n),
                        o = a.get(e);
                      if (
                        (void 0 !== o ? o.pmremVersion : -1) !== e.pmremVersion
                      ) {
                        let t = e.image;
                        if (e.isCubeTexture)
                          if (
                            !(function (e) {
                              if (null == e) return !1;
                              let t = 0;
                              for (let r = 0; r < 6; r++)
                                void 0 !== e[r] && t++;
                              return 6 === t;
                            })(t)
                          )
                            return null;
                          else o = r.fromCubemap(e, o);
                        else {
                          if (!(null != (s = t) && s.height > 0)) return null;
                          o = r.fromEquirectangular(e, o);
                        }
                        (o.pmremVersion = e.pmremVersion), a.set(e, o);
                      }
                      return o.texture;
                    })(i, e.renderer, this._generator)) &&
            ((this._pmrem = t), this.updateFromTexture(t));
        }
        setup(e) {
          null === this._generator && (this._generator = new l4(e.renderer)),
            this.updateBefore(e);
          let t = this.uvNode;
          null === t && e.context.getUV && (t = e.context.getUV(this)),
            (t = s1.mul(eW(t.x, t.y.negate(), t.z)));
          let r = this.levelNode;
          return (
            null === r &&
              e.context.getTextureLevel &&
              (r = e.context.getTextureLevel(this)),
            lO(this._texture, t, r, this._width, this._height, this._maxMip)
          );
        }
        dispose() {
          super.dispose(),
            null !== this._generator && this._generator.dispose();
        }
      }
      let ur = eE(ut),
        ui = new WeakMap();
      class us extends aC {
        static get type() {
          return "EnvironmentNode";
        }
        constructor(e = null) {
          super(), (this.envNode = e);
        }
        setup(e) {
          let { material: t } = e,
            r = this.envNode;
          if (r.isTextureNode || r.isMaterialReferenceNode) {
            let e = r.isTextureNode ? r.value : t[r.property],
              i = ui.get(e);
            void 0 === i && ((i = ur(e)), ui.set(e, i)), (r = i);
          }
          let i = !0 === t.useAnisotropy || t.anisotropy > 0 ? nx : sq,
            s = r.context(un(tl, i)).mul(s0),
            n = r.context(ua(sj)).mul(Math.PI).mul(s0),
            a = iO(s),
            o = iO(n);
          e.context.radiance.addAssign(a), e.context.iblIrradiance.addAssign(o);
          let l = e.context.lightingModel.clearcoatRadiance;
          if (l) {
            let e = iO(r.context(un(th, sX)).mul(s0));
            l.addAssign(e);
          }
        }
      }
      let un = (e, t) => {
          let r = null;
          return {
            getUV: () => (
              null === r &&
                ((r = sD.negate().reflect(t)),
                (r = (r = e.mul(e).mix(r, t).normalize()).transformDirection(
                  sa
                ))),
              r
            ),
            getTextureLevel: () => e,
          };
        },
        ua = (e) => ({ getUV: () => e, getTextureLevel: () => eL(1) }),
        uo = new u._4j();
      class ul extends os {
        static get type() {
          return "MeshStandardNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshStandardNodeMaterial = !0),
            (this.lights = !0),
            (this.emissiveNode = null),
            (this.metalnessNode = null),
            (this.roughnessNode = null),
            this.setDefaultValues(uo),
            this.setValues(e);
        }
        setupEnvironment(e) {
          let t = super.setupEnvironment(e);
          return (
            null === t && e.environmentNode && (t = e.environmentNode),
            t ? new us(t) : null
          );
        }
        setupLightingModel() {
          return new lv();
        }
        setupSpecular() {
          let e = rZ(eW(0.04), ta.rgb, tu);
          t_.assign(e), tv.assign(1);
        }
        setupVariants() {
          let e = this.metalnessNode ? eL(this.metalnessNode) : nO;
          tu.assign(e);
          let t = this.roughnessNode ? eL(this.roughnessNode) : nV;
          (t = oz({ roughness: t })),
            tl.assign(t),
            this.setupSpecular(),
            ta.assign(eX(ta.rgb.mul(e.oneMinus()), ta.a));
        }
        copy(e) {
          return (
            (this.emissiveNode = e.emissiveNode),
            (this.metalnessNode = e.metalnessNode),
            (this.roughnessNode = e.roughnessNode),
            super.copy(e)
          );
        }
      }
      let uu = new u.uSd();
      class ud extends ul {
        static get type() {
          return "MeshPhysicalNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhysicalNodeMaterial = !0),
            (this.clearcoatNode = null),
            (this.clearcoatRoughnessNode = null),
            (this.clearcoatNormalNode = null),
            (this.sheenNode = null),
            (this.sheenRoughnessNode = null),
            (this.iridescenceNode = null),
            (this.iridescenceIORNode = null),
            (this.iridescenceThicknessNode = null),
            (this.specularIntensityNode = null),
            (this.specularColorNode = null),
            (this.iorNode = null),
            (this.transmissionNode = null),
            (this.thicknessNode = null),
            (this.attenuationDistanceNode = null),
            (this.attenuationColorNode = null),
            (this.dispersionNode = null),
            (this.anisotropyNode = null),
            this.setDefaultValues(uu),
            this.setValues(e);
        }
        get useClearcoat() {
          return this.clearcoat > 0 || null !== this.clearcoatNode;
        }
        get useIridescence() {
          return this.iridescence > 0 || null !== this.iridescenceNode;
        }
        get useSheen() {
          return this.sheen > 0 || null !== this.sheenNode;
        }
        get useAnisotropy() {
          return this.anisotropy > 0 || null !== this.anisotropyNode;
        }
        get useTransmission() {
          return this.transmission > 0 || null !== this.transmissionNode;
        }
        get useDispersion() {
          return this.dispersion > 0 || null !== this.dispersionNode;
        }
        setupSpecular() {
          let e = this.iorNode ? eL(this.iorNode) : nJ;
          tE.assign(e),
            t_.assign(
              rZ(
                rL(rq(tE.sub(1).div(tE.add(1))).mul(nP), eW(1)).mul(nI),
                ta.rgb,
                tu
              )
            ),
            tv.assign(rZ(nI, 1, tu));
        }
        setupLightingModel() {
          return new lv(
            this.useClearcoat,
            this.useSheen,
            this.useIridescence,
            this.useAnisotropy,
            this.useTransmission,
            this.useDispersion
          );
        }
        setupVariants(e) {
          if ((super.setupVariants(e), this.useClearcoat)) {
            let e = this.clearcoatNode ? eL(this.clearcoatNode) : nk,
              t = this.clearcoatRoughnessNode
                ? eL(this.clearcoatRoughnessNode)
                : nz;
            td.assign(e), th.assign(oz({ roughness: t }));
          }
          if (this.useSheen) {
            let e = this.sheenNode ? eW(this.sheenNode) : nH,
              t = this.sheenRoughnessNode ? eL(this.sheenRoughnessNode) : nq;
            tc.assign(e), tp.assign(t);
          }
          if (this.useIridescence) {
            let e = this.iridescenceNode ? eL(this.iridescenceNode) : nX,
              t = this.iridescenceIORNode ? eL(this.iridescenceIORNode) : nQ,
              r = this.iridescenceThicknessNode
                ? eL(this.iridescenceThicknessNode)
                : nK;
            tg.assign(e), tm.assign(t), tf.assign(r);
          }
          if (this.useAnisotropy) {
            let e = (
              this.anisotropyNode ? eG(this.anisotropyNode) : nj
            ).toVar();
            tx.assign(e.length()),
              eU(tx.equal(0), () => {
                e.assign(eG(1, 0));
              }).Else(() => {
                e.divAssign(eG(tx)), tx.assign(tx.saturate());
              }),
              ty.assign(tx.pow2().mix(tl.pow2(), 1)),
              tb.assign(nf[0].mul(e.x).add(nf[1].mul(e.y))),
              tT.assign(nf[1].mul(e.x).sub(nf[0].mul(e.y)));
          }
          if (this.useTransmission) {
            let e = this.transmissionNode ? eL(this.transmissionNode) : nY,
              t = this.thicknessNode ? eL(this.thicknessNode) : nZ,
              r = this.attenuationDistanceNode
                ? eL(this.attenuationDistanceNode)
                : n0,
              i = this.attenuationColorNode
                ? eW(this.attenuationColorNode)
                : n1;
            if (
              (tw.assign(e),
              tM.assign(t),
              tB.assign(r),
              tF.assign(i),
              this.useDispersion)
            ) {
              let e = this.dispersionNode ? eL(this.dispersionNode) : n9;
              tU.assign(e);
            }
          }
        }
        setupClearcoatNormal() {
          return this.clearcoatNormalNode ? eW(this.clearcoatNormalNode) : n$;
        }
        setup(e) {
          (e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e)),
            super.setup(e);
        }
        copy(e) {
          return (
            (this.clearcoatNode = e.clearcoatNode),
            (this.clearcoatRoughnessNode = e.clearcoatRoughnessNode),
            (this.clearcoatNormalNode = e.clearcoatNormalNode),
            (this.sheenNode = e.sheenNode),
            (this.sheenRoughnessNode = e.sheenRoughnessNode),
            (this.iridescenceNode = e.iridescenceNode),
            (this.iridescenceIORNode = e.iridescenceIORNode),
            (this.iridescenceThicknessNode = e.iridescenceThicknessNode),
            (this.specularIntensityNode = e.specularIntensityNode),
            (this.specularColorNode = e.specularColorNode),
            (this.transmissionNode = e.transmissionNode),
            (this.thicknessNode = e.thicknessNode),
            (this.attenuationDistanceNode = e.attenuationDistanceNode),
            (this.attenuationColorNode = e.attenuationColorNode),
            (this.dispersionNode = e.dispersionNode),
            (this.anisotropyNode = e.anisotropyNode),
            super.copy(e)
          );
        }
      }
      class uh extends lv {
        constructor(e = !1, t = !1, r = !1, i = !1, s = !1, n = !1, a = !1) {
          super(e, t, r, i, s, n), (this.useSSS = a);
        }
        direct({ lightDirection: e, lightColor: t, reflectedLight: r }, i) {
          if (!0 === this.useSSS) {
            let {
                thicknessColorNode: s,
                thicknessDistortionNode: n,
                thicknessAmbientNode: a,
                thicknessAttenuationNode: o,
                thicknessPowerNode: l,
                thicknessScaleNode: u,
              } = i.material,
              d = e.add(sq.mul(n)).normalize(),
              h = eW(
                eL(sD.dot(d.negate()).saturate().pow(l).mul(u)).add(a).mul(s)
              );
            r.directDiffuse.addAssign(h.mul(o.mul(t)));
          }
          super.direct(
            { lightDirection: e, lightColor: t, reflectedLight: r },
            i
          );
        }
      }
      class uc extends ud {
        static get type() {
          return "MeshSSSNodeMaterial";
        }
        constructor(e) {
          super(e),
            (this.thicknessColorNode = null),
            (this.thicknessDistortionNode = eL(0.1)),
            (this.thicknessAmbientNode = eL(0)),
            (this.thicknessAttenuationNode = eL(0.1)),
            (this.thicknessPowerNode = eL(2)),
            (this.thicknessScaleNode = eL(10));
        }
        get useSSS() {
          return null !== this.thicknessColorNode;
        }
        setupLightingModel() {
          return new uh(
            this.useClearcoat,
            this.useSheen,
            this.useIridescence,
            this.useAnisotropy,
            this.useTransmission,
            this.useDispersion,
            this.useSSS
          );
        }
        copy(e) {
          return (
            (this.thicknessColorNode = e.thicknessColorNode),
            (this.thicknessDistortionNode = e.thicknessDistortionNode),
            (this.thicknessAmbientNode = e.thicknessAmbientNode),
            (this.thicknessAttenuationNode = e.thicknessAttenuationNode),
            (this.thicknessPowerNode = e.thicknessPowerNode),
            (this.thicknessScaleNode = e.thicknessScaleNode),
            super.copy(e)
          );
        }
      }
      let up = eM(({ normal: e, lightDirection: t, builder: r }) => {
        let i = eG(e.dot(t).mul(0.5).add(0.5), 0);
        if (r.material.gradientMap)
          return eW(ni("gradientMap", "texture").context({ getUV: () => i }).r);
        {
          let e = i.fwidth().mul(0.5);
          return rZ(
            eW(0.7),
            eW(1),
            r2(eL(0.7).sub(e.x), eL(0.7).add(e.x), i.x)
          );
        }
      });
      class ug extends oC {
        direct({ lightDirection: e, lightColor: t, reflectedLight: r }, i) {
          let s = up({ normal: sk, lightDirection: e, builder: i }).mul(t);
          r.directDiffuse.addAssign(s.mul(oF({ diffuseColor: ta.rgb })));
        }
        indirect(e) {
          let {
            ambientOcclusion: t,
            irradiance: r,
            reflectedLight: i,
          } = e.context;
          i.indirectDiffuse.addAssign(r.mul(oF({ diffuseColor: ta }))),
            i.indirectDiffuse.mulAssign(t);
        }
      }
      let um = new u.Df();
      class uf extends os {
        static get type() {
          return "MeshToonNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshToonNodeMaterial = !0),
            (this.lights = !0),
            this.setDefaultValues(um),
            this.setValues(e);
        }
        setupLightingModel() {
          return new ug();
        }
      }
      class uy extends k {
        static get type() {
          return "MatcapUVNode";
        }
        constructor() {
          super("vec2");
        }
        setup() {
          let e = eW(sD.z, 0, sD.x.negate()).normalize(),
            t = sD.cross(e);
          return eG(e.dot(sq), t.dot(sq)).mul(0.495).add(0.5);
        }
      }
      let ux = ew(uy),
        ub = new u.FNr();
      class uT extends os {
        static get type() {
          return "MeshMatcapNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshMatcapNodeMaterial = !0),
            this.setDefaultValues(ub),
            this.setValues(e);
        }
        setupVariants(e) {
          let t;
          (t = e.material.matcap
            ? ni("matcap", "texture").context({ getUV: () => ux })
            : eW(rZ(0.2, 0.8, ux.y))),
            ta.rgb.mulAssign(t.rgb);
        }
      }
      class u_ extends k {
        static get type() {
          return "RotateNode";
        }
        constructor(e, t) {
          super(), (this.positionNode = e), (this.rotationNode = t);
        }
        getNodeType(e) {
          return this.positionNode.getNodeType(e);
        }
        setup(e) {
          let { rotationNode: t, positionNode: r } = this;
          if ("vec2" === this.getNodeType(e)) {
            let e = t.cos(),
              i = t.sin();
            return eZ(e, i, i.negate(), e).mul(r);
          }
          {
            let e = e0(
                eX(1, 0, 0, 0),
                eX(0, ry(t.x), rf(t.x).negate(), 0),
                eX(0, rf(t.x), ry(t.x), 0),
                eX(0, 0, 0, 1)
              ),
              i = e0(
                eX(ry(t.y), 0, rf(t.y), 0),
                eX(0, 1, 0, 0),
                eX(rf(t.y).negate(), 0, ry(t.y), 0),
                eX(0, 0, 0, 1)
              ),
              s = e0(
                eX(ry(t.z), rf(t.z).negate(), 0, 0),
                eX(rf(t.z), ry(t.z), 0, 0),
                eX(0, 0, 1, 0),
                eX(0, 0, 0, 1)
              );
            return e.mul(i).mul(s).mul(eX(r, 1)).xyz;
          }
        }
      }
      let uv = eE(u_),
        uN = new u.RoJ();
      class uS extends os {
        static get type() {
          return "SpriteNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isSpriteNodeMaterial = !0),
            (this._useSizeAttenuation = !0),
            (this.positionNode = null),
            (this.rotationNode = null),
            (this.scaleNode = null),
            (this.transparent = !0),
            this.setDefaultValues(uN),
            this.setValues(e);
        }
        setupPositionView(e) {
          let { object: t, camera: r } = e,
            i = this.sizeAttenuation,
            { positionNode: s, rotationNode: n, scaleNode: a } = this,
            o = sC.mul(eW(s || 0)),
            l = eG(sT[0].xyz.length(), sT[1].xyz.length());
          if ((null !== a && (l = l.mul(eG(a))), !1 === i))
            if (r.isPerspectiveCamera) l = l.mul(o.z.negate());
            else {
              let e = eL(2).div(ss.element(1).element(1));
              l = l.mul(e.mul(2));
            }
          let u = sB.xy;
          if (t.center && !0 === t.center.isVector2) {
            let e = iR("center", "vec2", t);
            u = u.sub(e.sub(0.5));
          }
          let d = uv((u = u.mul(l)), eL(n || nW));
          return eX(o.xy.add(d), o.zw);
        }
        copy(e) {
          return (
            (this.positionNode = e.positionNode),
            (this.rotationNode = e.rotationNode),
            (this.scaleNode = e.scaleNode),
            super.copy(e)
          );
        }
        get sizeAttenuation() {
          return this._useSizeAttenuation;
        }
        set sizeAttenuation(e) {
          this._useSizeAttenuation !== e &&
            ((this._useSizeAttenuation = e), (this.needsUpdate = !0));
        }
      }
      let uR = new u.BH$();
      class uA extends uS {
        static get type() {
          return "PointsNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.sizeNode = null),
            (this.isPointsNodeMaterial = !0),
            this.setDefaultValues(uR),
            this.setValues(e);
        }
        setupPositionView() {
          let { positionNode: e } = this;
          return sC.mul(eW(e || sF)).xyz;
        }
        setupVertex(e) {
          let t = super.setupVertex(e);
          if (!0 !== e.material.isNodeMaterial) return t;
          let { rotationNode: r, scaleNode: i, sizeNode: s } = this,
            n = sB.xy.toVar(),
            a = aL.z.div(aL.w);
          if (r && r.isNode) {
            let e = eL(r);
            n.assign(uv(n, e));
          }
          let o = null !== s ? eG(s) : n8;
          return (
            !0 === this.sizeAttenuation && (o = o.mul(o.div(sL.z.negate()))),
            i && i.isNode && (o = o.mul(eG(i))),
            n.mulAssign(o.mul(2)),
            n.assign(n.div(aL.z)),
            n.y.assign(n.y.mul(a)),
            n.assign(n.mul(t.w)),
            t.addAssign(eX(n, 0, 0)),
            t
          );
        }
        get alphaToCoverage() {
          return this._useAlphaToCoverage;
        }
        set alphaToCoverage(e) {
          this._useAlphaToCoverage !== e &&
            ((this._useAlphaToCoverage = e), (this.needsUpdate = !0));
        }
      }
      class uC extends oC {
        constructor() {
          super(), (this.shadowNode = eL(1).toVar("shadowMask"));
        }
        direct({ shadowMask: e }) {
          this.shadowNode.mulAssign(e);
        }
        finish(e) {
          ta.a.mulAssign(this.shadowNode.oneMinus()),
            e.outgoingLight.rgb.assign(ta.rgb);
        }
      }
      let uE = new u.q2();
      class uw extends os {
        static get type() {
          return "ShadowNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isShadowNodeMaterial = !0),
            (this.lights = !0),
            this.setDefaultValues(uE),
            this.setValues(e);
        }
        setupLightingModel() {
          return new uC();
        }
      }
      let uM = ts("vec3"),
        uB = ts("vec3"),
        uF = ts("vec3");
      class uU extends oC {
        constructor() {
          super();
        }
        start(e) {
          let { material: t, context: r } = e,
            i = ts("vec3"),
            s = ts("vec3");
          eU(su.sub(sI).length().greaterThan(sS.mul(2)), () => {
            i.assign(su), s.assign(sI);
          }).Else(() => {
            i.assign(sI), s.assign(su);
          });
          let n = s.sub(i),
            a = tr("int").onRenderUpdate(({ material: e }) => e.steps),
            o = n.length().div(a).toVar(),
            l = n.normalize().toVar(),
            u = eL(0).toVar(),
            d = eW(1).toVar();
          t.offsetNode && u.addAssign(t.offsetNode.mul(o)),
            aT(a, () => {
              let s,
                n = i.add(l.mul(u)),
                a = sa.mul(eX(n, 1)).xyz;
              null !== t.depthNode &&
                (uB.assign(a3(aZ(a.z, sr, si))),
                (r.sceneDepthNode = a3(t.depthNode).toVar())),
                (r.positionWorld = n),
                (r.shadowPositionWorld = n),
                (r.positionView = a),
                uM.assign(0),
                t.scatteringNode && (s = t.scatteringNode({ positionRay: n })),
                super.start(e),
                s && uM.mulAssign(s);
              let h = uM.mul(0.01).negate().mul(o).exp();
              d.mulAssign(h), u.addAssign(o);
            }),
            uF.addAssign(d.saturate().oneMinus());
        }
        scatteringLight(e, t) {
          let r = t.context.sceneDepthNode;
          r
            ? eU(r.greaterThanEqual(uB), () => {
                uM.addAssign(e);
              })
            : uM.addAssign(e);
        }
        direct({ lightNode: e, lightColor: t }, r) {
          if (void 0 === e.light.distance) return;
          let i = t.xyz.toVar();
          i.mulAssign(e.shadowNode), this.scatteringLight(i, r);
        }
        directRectArea(
          { lightColor: e, lightPosition: t, halfWidth: r, halfHeight: i },
          s
        ) {
          let n = t.add(r).sub(i),
            a = t.sub(r).sub(i),
            o = t.sub(r).add(i),
            l = t.add(r).add(i),
            u = s.context.positionView,
            d = e.xyz.mul(o6({ P: u, p0: n, p1: a, p2: o, p3: l })).pow(1.5);
          this.scatteringLight(d, s);
        }
        finish(e) {
          e.context.outgoingLight.assign(uF);
        }
      }
      class uI extends os {
        static get type() {
          return "VolumeNodeMaterial";
        }
        constructor(e) {
          super(),
            (this.isVolumeNodeMaterial = !0),
            (this.steps = 25),
            (this.scatteringNode = null),
            (this.lights = !0),
            (this.transparent = !0),
            (this.side = u.hsX),
            (this.depthTest = !1),
            (this.depthWrite = !1),
            this.setValues(e);
        }
        setupLightingModel() {
          return new uU();
        }
      }
      class uP {
        constructor(e, t) {
          (this.nodes = e),
            (this.info = t),
            (this._context = self),
            (this._animationLoop = null),
            (this._requestId = null);
        }
        start() {
          let e = (t, r) => {
            (this._requestId = this._context.requestAnimationFrame(e)),
              !0 === this.info.autoReset && this.info.reset(),
              this.nodes.nodeFrame.update(),
              (this.info.frame = this.nodes.nodeFrame.frameId),
              null !== this._animationLoop && this._animationLoop(t, r);
          };
          e();
        }
        stop() {
          this._context.cancelAnimationFrame(this._requestId),
            (this._requestId = null);
        }
        getAnimationLoop() {
          return this._animationLoop;
        }
        setAnimationLoop(e) {
          this._animationLoop = e;
        }
        getContext() {
          return this._context;
        }
        setContext(e) {
          this._context = e;
        }
        dispose() {
          this.stop();
        }
      }
      class uL {
        constructor() {
          this.weakMap = new WeakMap();
        }
        get(e) {
          let t = this.weakMap;
          for (let r = 0; r < e.length - 1; r++)
            if (void 0 === (t = t.get(e[r]))) return;
          return t.get(e[e.length - 1]);
        }
        set(e, t) {
          let r = this.weakMap;
          for (let t = 0; t < e.length - 1; t++) {
            let i = e[t];
            !1 === r.has(i) && r.set(i, new WeakMap()), (r = r.get(i));
          }
          return r.set(e[e.length - 1], t), this;
        }
        delete(e) {
          let t = this.weakMap;
          for (let r = 0; r < e.length - 1; r++)
            if (void 0 === (t = t.get(e[r]))) return !1;
          return t.delete(e[e.length - 1]);
        }
      }
      let uD = 0;
      class uV {
        constructor(e, t, r, i, s, n, a, o, l, u) {
          (this.id = uD++),
            (this._nodes = e),
            (this._geometries = t),
            (this.renderer = r),
            (this.object = i),
            (this.material = s),
            (this.scene = n),
            (this.camera = a),
            (this.lightsNode = o),
            (this.context = l),
            (this.geometry = i.geometry),
            (this.version = s.version),
            (this.drawRange = null),
            (this.attributes = null),
            (this.pipeline = null),
            (this.group = null),
            (this.vertexBuffers = null),
            (this.drawParams = null),
            (this.bundle = null),
            (this.clippingContext = u),
            (this.clippingContextCacheKey = null !== u ? u.cacheKey : ""),
            (this.initialNodesCacheKey = this.getDynamicCacheKey()),
            (this.initialCacheKey = this.getCacheKey()),
            (this._nodeBuilderState = null),
            (this._bindings = null),
            (this._monitor = null),
            (this.onDispose = null),
            (this.isRenderObject = !0),
            (this.onMaterialDispose = () => {
              this.dispose();
            }),
            this.material.addEventListener("dispose", this.onMaterialDispose);
        }
        updateClipping(e) {
          this.clippingContext = e;
        }
        get clippingNeedsUpdate() {
          return (
            null !== this.clippingContext &&
            this.clippingContext.cacheKey !== this.clippingContextCacheKey &&
            ((this.clippingContextCacheKey = this.clippingContext.cacheKey), !0)
          );
        }
        get hardwareClippingPlanes() {
          return !0 === this.material.hardwareClipping
            ? this.clippingContext.unionClippingCount
            : 0;
        }
        getNodeBuilderState() {
          return (
            this._nodeBuilderState ||
            (this._nodeBuilderState = this._nodes.getForRender(this))
          );
        }
        getMonitor() {
          return (
            this._monitor ||
            (this._monitor = this.getNodeBuilderState().observer)
          );
        }
        getBindings() {
          return (
            this._bindings ||
            (this._bindings = this.getNodeBuilderState().createBindings())
          );
        }
        getBindingGroup(e) {
          for (let t of this.getBindings()) if (t.name === e) return t;
        }
        getIndex() {
          return this._geometries.getIndex(this);
        }
        getIndirect() {
          return this._geometries.getIndirect(this);
        }
        getChainArray() {
          return [this.object, this.material, this.context, this.lightsNode];
        }
        setGeometry(e) {
          (this.geometry = e), (this.attributes = null);
        }
        getAttributes() {
          if (null !== this.attributes) return this.attributes;
          let e = this.getNodeBuilderState().nodeAttributes,
            t = this.geometry,
            r = [],
            i = new Set();
          for (let s of e) {
            let e =
              s.node && s.node.attribute
                ? s.node.attribute
                : t.getAttribute(s.name);
            if (void 0 === e) continue;
            r.push(e);
            let n = e.isInterleavedBufferAttribute ? e.data : e;
            i.add(n);
          }
          return (
            (this.attributes = r),
            (this.vertexBuffers = Array.from(i.values())),
            r
          );
        }
        getVertexBuffers() {
          return (
            null === this.vertexBuffers && this.getAttributes(),
            this.vertexBuffers
          );
        }
        getDrawParameters() {
          let {
              object: e,
              material: t,
              geometry: r,
              group: i,
              drawRange: s,
            } = this,
            n =
              this.drawParams ||
              (this.drawParams = {
                vertexCount: 0,
                firstVertex: 0,
                instanceCount: 0,
                firstInstance: 0,
              }),
            a = this.getIndex(),
            o = null !== a,
            l = r.isInstancedBufferGeometry
              ? r.instanceCount
              : e.count > 1
              ? e.count
              : 1;
          if (0 === l) return null;
          if (((n.instanceCount = l), !0 === e.isBatchedMesh)) return n;
          let u = 1;
          !0 !== t.wireframe ||
            e.isPoints ||
            e.isLineSegments ||
            e.isLine ||
            e.isLineLoop ||
            (u = 2);
          let d = s.start * u,
            h = (s.start + s.count) * u;
          null !== i &&
            ((d = Math.max(d, i.start * u)),
            (h = Math.min(h, (i.start + i.count) * u)));
          let c = r.attributes.position,
            p = 1 / 0;
          o ? (p = a.count) : null != c && (p = c.count), (d = Math.max(d, 0));
          let g = (h = Math.min(h, p)) - d;
          return g < 0 || g === 1 / 0
            ? null
            : ((n.vertexCount = g), (n.firstVertex = d), n);
        }
        getGeometryCacheKey() {
          let { geometry: e } = this,
            t = "";
          for (let r of Object.keys(e.attributes).sort()) {
            let i = e.attributes[r];
            (t += r + ","),
              i.data && (t += i.data.stride + ","),
              i.offset && (t += i.offset + ","),
              i.itemSize && (t += i.itemSize + ","),
              i.normalized && (t += "n,");
          }
          for (let r of Object.keys(e.morphAttributes).sort()) {
            let i = e.morphAttributes[r];
            t += "morph-" + r + ",";
            for (let e = 0, r = i.length; e < r; e++) t += i[e].id + ",";
          }
          return e.index && (t += "index,"), t;
        }
        getMaterialCacheKey() {
          let { object: e, material: t } = this,
            r = t.customProgramCacheKey();
          for (let e of (function (e) {
            let t = Object.keys(e),
              r = Object.getPrototypeOf(e);
            for (; r; ) {
              let e = Object.getOwnPropertyDescriptors(r);
              for (let r in e)
                if (void 0 !== e[r]) {
                  let i = e[r];
                  i && "function" == typeof i.get && t.push(r);
                }
              r = Object.getPrototypeOf(r);
            }
            return t;
          })(t)) {
            let i;
            if (
              /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(
                e
              )
            )
              continue;
            let s = t[e];
            if (null !== s) {
              let e = typeof s;
              "number" === e
                ? (i = 0 !== s ? "1" : "0")
                : "object" === e
                ? ((i = "{"), s.isTexture && (i += s.mapping), (i += "}"))
                : (i = String(s));
            } else i = String(s);
            r += i + ",";
          }
          return (
            (r += this.clippingContextCacheKey + ","),
            e.geometry && (r += this.getGeometryCacheKey()),
            e.skeleton && (r += e.skeleton.bones.length + ","),
            e.isBatchedMesh &&
              ((r += e._matricesTexture.uuid + ","),
              null !== e._colorsTexture && (r += e._colorsTexture.uuid + ",")),
            e.count > 1 && (r += e.uuid + ","),
            p((r += e.receiveShadow + ","))
          );
        }
        get needsGeometryUpdate() {
          return this.geometry.id !== this.object.geometry.id;
        }
        get needsUpdate() {
          return (
            this.initialNodesCacheKey !== this.getDynamicCacheKey() ||
            this.clippingNeedsUpdate
          );
        }
        getDynamicCacheKey() {
          let e = 0;
          return (
            !0 !== this.material.isShadowPassMaterial &&
              (e = this._nodes.getCacheKey(this.scene, this.lightsNode)),
            this.camera.isArrayCamera && (e = m(e, this.camera.cameras.length)),
            this.object.receiveShadow && (e = m(e, 1)),
            e
          );
        }
        getCacheKey() {
          return this.getMaterialCacheKey() + this.getDynamicCacheKey();
        }
        dispose() {
          this.material.removeEventListener("dispose", this.onMaterialDispose),
            this.onDispose();
        }
      }
      let uO = [];
      class uG {
        constructor(e, t, r, i, s, n) {
          (this.renderer = e),
            (this.nodes = t),
            (this.geometries = r),
            (this.pipelines = i),
            (this.bindings = s),
            (this.info = n),
            (this.chainMaps = {});
        }
        get(e, t, r, i, s, n, a, o) {
          let l = this.getChainMap(o);
          (uO[0] = e), (uO[1] = t), (uO[2] = n), (uO[3] = s);
          let u = l.get(uO);
          return (
            void 0 === u
              ? ((u = this.createRenderObject(
                  this.nodes,
                  this.geometries,
                  this.renderer,
                  e,
                  t,
                  r,
                  i,
                  s,
                  n,
                  a,
                  o
                )),
                l.set(uO, u))
              : (u.updateClipping(a),
                u.needsGeometryUpdate && u.setGeometry(e.geometry),
                (u.version !== t.version || u.needsUpdate) &&
                  (u.initialCacheKey !== u.getCacheKey()
                    ? (u.dispose(), (u = this.get(e, t, r, i, s, n, a, o)))
                    : (u.version = t.version))),
            (uO.length = 0),
            u
          );
        }
        getChainMap(e = "default") {
          return this.chainMaps[e] || (this.chainMaps[e] = new uL());
        }
        dispose() {
          this.chainMaps = {};
        }
        createRenderObject(e, t, r, i, s, n, a, o, l, u, d) {
          let h = this.getChainMap(d),
            c = new uV(e, t, r, i, s, n, a, o, l, u);
          return (
            (c.onDispose = () => {
              this.pipelines.delete(c),
                this.bindings.delete(c),
                this.nodes.delete(c),
                h.delete(c.getChainArray());
            }),
            c
          );
        }
      }
      class uk {
        constructor() {
          this.data = new WeakMap();
        }
        get(e) {
          let t = this.data.get(e);
          return void 0 === t && ((t = {}), this.data.set(e, t)), t;
        }
        delete(e) {
          let t = null;
          return (
            this.data.has(e) && ((t = this.data.get(e)), this.data.delete(e)), t
          );
        }
        has(e) {
          return this.data.has(e);
        }
        dispose() {
          this.data = new WeakMap();
        }
      }
      let uz = { VERTEX: 1, INDEX: 2, STORAGE: 3, INDIRECT: 4 };
      class u$ extends uk {
        constructor(e) {
          super(), (this.backend = e);
        }
        delete(e) {
          let t = super.delete(e);
          return void 0 !== t && this.backend.destroyAttribute(e), t;
        }
        update(e, t) {
          let r = this.get(e);
          if (void 0 === r.version)
            t === uz.VERTEX
              ? this.backend.createAttribute(e)
              : t === uz.INDEX
              ? this.backend.createIndexAttribute(e)
              : t === uz.STORAGE
              ? this.backend.createStorageAttribute(e)
              : t === uz.INDIRECT &&
                this.backend.createIndirectStorageAttribute(e),
              (r.version = this._getBufferAttribute(e).version);
          else {
            let t = this._getBufferAttribute(e);
            (r.version < t.version || t.usage === u.Vnu) &&
              (this.backend.updateAttribute(e), (r.version = t.version));
          }
        }
        _getBufferAttribute(e) {
          return e.isInterleavedBufferAttribute && (e = e.data), e;
        }
      }
      function uW(e) {
        return null !== e.index
          ? e.index.version
          : e.attributes.position.version;
      }
      function uH(e) {
        let t = [],
          r = e.index,
          i = e.attributes.position;
        if (null !== r) {
          let e = r.array;
          for (let r = 0, i = e.length; r < i; r += 3) {
            let i = e[r + 0],
              s = e[r + 1],
              n = e[r + 2];
            t.push(i, s, s, n, n, i);
          }
        } else {
          let e = i.array;
          for (let r = 0, i = e.length / 3 - 1; r < i; r += 3) {
            let e = r + 0,
              i = r + 1,
              s = r + 2;
            t.push(e, i, i, s, s, e);
          }
        }
        let s = new ((0, u.AQS)(t) ? u.MW4 : u.A$4)(t, 1);
        return (s.version = uW(e)), s;
      }
      class uq extends uk {
        constructor(e, t) {
          super(),
            (this.attributes = e),
            (this.info = t),
            (this.wireframes = new WeakMap()),
            (this.attributeCall = new WeakMap());
        }
        has(e) {
          let t = e.geometry;
          return super.has(t) && !0 === this.get(t).initialized;
        }
        updateForRender(e) {
          !1 === this.has(e) && this.initGeometry(e), this.updateAttributes(e);
        }
        initGeometry(e) {
          let t = e.geometry;
          (this.get(t).initialized = !0), this.info.memory.geometries++;
          let r = () => {
            this.info.memory.geometries--;
            let i = t.index,
              s = e.getAttributes();
            for (let e of (null !== i && this.attributes.delete(i), s))
              this.attributes.delete(e);
            let n = this.wireframes.get(t);
            void 0 !== n && this.attributes.delete(n),
              t.removeEventListener("dispose", r);
          };
          t.addEventListener("dispose", r);
        }
        updateAttributes(e) {
          for (let t of e.getAttributes())
            t.isStorageBufferAttribute || t.isStorageInstancedBufferAttribute
              ? this.updateAttribute(t, uz.STORAGE)
              : this.updateAttribute(t, uz.VERTEX);
          let t = this.getIndex(e);
          null !== t && this.updateAttribute(t, uz.INDEX);
          let r = e.geometry.indirect;
          null !== r && this.updateAttribute(r, uz.INDIRECT);
        }
        updateAttribute(e, t) {
          let r = this.info.render.calls;
          e.isInterleavedBufferAttribute
            ? void 0 === this.attributeCall.get(e)
              ? (this.attributes.update(e, t), this.attributeCall.set(e, r))
              : this.attributeCall.get(e.data) !== r &&
                (this.attributes.update(e, t),
                this.attributeCall.set(e.data, r),
                this.attributeCall.set(e, r))
            : this.attributeCall.get(e) !== r &&
              (this.attributes.update(e, t), this.attributeCall.set(e, r));
        }
        getIndirect(e) {
          return e.geometry.indirect;
        }
        getIndex(e) {
          let { geometry: t, material: r } = e,
            i = t.index;
          if (!0 === r.wireframe) {
            let e = this.wireframes,
              r = e.get(t);
            void 0 === r
              ? ((r = uH(t)), e.set(t, r))
              : r.version !== uW(t) &&
                (this.attributes.delete(r), (r = uH(t)), e.set(t, r)),
              (i = r);
          }
          return i;
        }
      }
      class uj {
        constructor() {
          (this.autoReset = !0),
            (this.frame = 0),
            (this.calls = 0),
            (this.render = {
              calls: 0,
              frameCalls: 0,
              drawCalls: 0,
              triangles: 0,
              points: 0,
              lines: 0,
              timestamp: 0,
            }),
            (this.compute = { calls: 0, frameCalls: 0, timestamp: 0 }),
            (this.memory = { geometries: 0, textures: 0 });
        }
        update(e, t, r) {
          this.render.drawCalls++,
            e.isMesh || e.isSprite
              ? (this.render.triangles += (t / 3) * r)
              : e.isPoints
              ? (this.render.points += r * t)
              : e.isLineSegments
              ? (this.render.lines += (t / 2) * r)
              : e.isLine
              ? (this.render.lines += r * (t - 1))
              : console.error("THREE.WebGPUInfo: Unknown object type.");
        }
        reset() {
          (this.render.drawCalls = 0),
            (this.render.frameCalls = 0),
            (this.compute.frameCalls = 0),
            (this.render.triangles = 0),
            (this.render.points = 0),
            (this.render.lines = 0);
        }
        dispose() {
          this.reset(),
            (this.calls = 0),
            (this.render.calls = 0),
            (this.compute.calls = 0),
            (this.render.timestamp = 0),
            (this.compute.timestamp = 0),
            (this.memory.geometries = 0),
            (this.memory.textures = 0);
        }
      }
      class uX {
        constructor(e) {
          (this.cacheKey = e), (this.usedTimes = 0);
        }
      }
      class uQ extends uX {
        constructor(e, t, r) {
          super(e), (this.vertexProgram = t), (this.fragmentProgram = r);
        }
      }
      class uK extends uX {
        constructor(e, t) {
          super(e), (this.computeProgram = t), (this.isComputePipeline = !0);
        }
      }
      let uY = 0;
      class uZ {
        constructor(e, t, r, i = null, s = null) {
          (this.id = uY++),
            (this.code = e),
            (this.stage = t),
            (this.name = r),
            (this.transforms = i),
            (this.attributes = s),
            (this.usedTimes = 0);
        }
      }
      class uJ extends uk {
        constructor(e, t) {
          super(),
            (this.backend = e),
            (this.nodes = t),
            (this.bindings = null),
            (this.caches = new Map()),
            (this.programs = {
              vertex: new Map(),
              fragment: new Map(),
              compute: new Map(),
            });
        }
        getForCompute(e, t) {
          let { backend: r } = this,
            i = this.get(e);
          if (this._needsComputeUpdate(e)) {
            let s = i.pipeline;
            s && (s.usedTimes--, s.computeProgram.usedTimes--);
            let n = this.nodes.getForCompute(e),
              a = this.programs.compute.get(n.computeShader);
            void 0 === a &&
              (s &&
                0 === s.computeProgram.usedTimes &&
                this._releaseProgram(s.computeProgram),
              (a = new uZ(
                n.computeShader,
                "compute",
                e.name,
                n.transforms,
                n.nodeAttributes
              )),
              this.programs.compute.set(n.computeShader, a),
              r.createProgram(a));
            let o = this._getComputeCacheKey(e, a),
              l = this.caches.get(o);
            void 0 === l &&
              (s && 0 === s.usedTimes && this._releasePipeline(s),
              (l = this._getComputePipeline(e, a, o, t))),
              l.usedTimes++,
              a.usedTimes++,
              (i.version = e.version),
              (i.pipeline = l);
          }
          return i.pipeline;
        }
        getForRender(e, t = null) {
          let { backend: r } = this,
            i = this.get(e);
          if (this._needsRenderUpdate(e)) {
            let s = i.pipeline;
            s &&
              (s.usedTimes--,
              s.vertexProgram.usedTimes--,
              s.fragmentProgram.usedTimes--);
            let n = e.getNodeBuilderState(),
              a = e.material ? e.material.name : "",
              o = this.programs.vertex.get(n.vertexShader);
            void 0 === o &&
              (s &&
                0 === s.vertexProgram.usedTimes &&
                this._releaseProgram(s.vertexProgram),
              (o = new uZ(n.vertexShader, "vertex", a)),
              this.programs.vertex.set(n.vertexShader, o),
              r.createProgram(o));
            let l = this.programs.fragment.get(n.fragmentShader);
            void 0 === l &&
              (s &&
                0 === s.fragmentProgram.usedTimes &&
                this._releaseProgram(s.fragmentProgram),
              (l = new uZ(n.fragmentShader, "fragment", a)),
              this.programs.fragment.set(n.fragmentShader, l),
              r.createProgram(l));
            let u = this._getRenderCacheKey(e, o, l),
              d = this.caches.get(u);
            void 0 === d
              ? (s && 0 === s.usedTimes && this._releasePipeline(s),
                (d = this._getRenderPipeline(e, o, l, u, t)))
              : (e.pipeline = d),
              d.usedTimes++,
              o.usedTimes++,
              l.usedTimes++,
              (i.pipeline = d);
          }
          return i.pipeline;
        }
        delete(e) {
          let t = this.get(e).pipeline;
          return (
            t &&
              (t.usedTimes--,
              0 === t.usedTimes && this._releasePipeline(t),
              t.isComputePipeline
                ? (t.computeProgram.usedTimes--,
                  0 === t.computeProgram.usedTimes &&
                    this._releaseProgram(t.computeProgram))
                : (t.fragmentProgram.usedTimes--,
                  t.vertexProgram.usedTimes--,
                  0 === t.vertexProgram.usedTimes &&
                    this._releaseProgram(t.vertexProgram),
                  0 === t.fragmentProgram.usedTimes &&
                    this._releaseProgram(t.fragmentProgram))),
            super.delete(e)
          );
        }
        dispose() {
          super.dispose(),
            (this.caches = new Map()),
            (this.programs = {
              vertex: new Map(),
              fragment: new Map(),
              compute: new Map(),
            });
        }
        updateForRender(e) {
          this.getForRender(e);
        }
        _getComputePipeline(e, t, r, i) {
          r = r || this._getComputeCacheKey(e, t);
          let s = this.caches.get(r);
          return (
            void 0 === s &&
              ((s = new uK(r, t)),
              this.caches.set(r, s),
              this.backend.createComputePipeline(s, i)),
            s
          );
        }
        _getRenderPipeline(e, t, r, i, s) {
          i = i || this._getRenderCacheKey(e, t, r);
          let n = this.caches.get(i);
          return (
            void 0 === n &&
              ((n = new uQ(i, t, r)),
              this.caches.set(i, n),
              (e.pipeline = n),
              this.backend.createRenderPipeline(e, s)),
            n
          );
        }
        _getComputeCacheKey(e, t) {
          return e.id + "," + t.id;
        }
        _getRenderCacheKey(e, t, r) {
          return t.id + "," + r.id + "," + this.backend.getRenderCacheKey(e);
        }
        _releasePipeline(e) {
          this.caches.delete(e.cacheKey);
        }
        _releaseProgram(e) {
          let t = e.code,
            r = e.stage;
          this.programs[r].delete(t);
        }
        _needsComputeUpdate(e) {
          let t = this.get(e);
          return void 0 === t.pipeline || t.version !== e.version;
        }
        _needsRenderUpdate(e) {
          return (
            void 0 === this.get(e).pipeline || this.backend.needsRenderUpdate(e)
          );
        }
      }
      class u0 extends uk {
        constructor(e, t, r, i, s, n) {
          super(),
            (this.backend = e),
            (this.textures = r),
            (this.pipelines = s),
            (this.attributes = i),
            (this.nodes = t),
            (this.info = n),
            (this.pipelines.bindings = this);
        }
        getForRender(e) {
          let t = e.getBindings();
          for (let e of t) {
            let r = this.get(e);
            void 0 === r.bindGroup &&
              (this._init(e),
              this.backend.createBindings(e, t, 0),
              (r.bindGroup = e));
          }
          return t;
        }
        getForCompute(e) {
          let t = this.nodes.getForCompute(e).bindings;
          for (let e of t) {
            let r = this.get(e);
            void 0 === r.bindGroup &&
              (this._init(e),
              this.backend.createBindings(e, t, 0),
              (r.bindGroup = e));
          }
          return t;
        }
        updateForCompute(e) {
          this._updateBindings(this.getForCompute(e));
        }
        updateForRender(e) {
          this._updateBindings(this.getForRender(e));
        }
        _updateBindings(e) {
          for (let t of e) this._update(t, e);
        }
        _init(e) {
          for (let t of e.bindings)
            if (t.isSampledTexture) this.textures.updateTexture(t.texture);
            else if (t.isStorageBuffer) {
              let e = t.attribute,
                r = e.isIndirectStorageBufferAttribute
                  ? uz.INDIRECT
                  : uz.STORAGE;
              this.attributes.update(e, r);
            }
        }
        _update(e, t) {
          let { backend: r } = this,
            i = !1,
            s = !0,
            n = 0,
            a = 0;
          for (let t of e.bindings)
            if (!t.isNodeUniformsGroup || !1 !== this.nodes.updateGroup(t)) {
              if (t.isStorageBuffer) {
                let e = t.attribute,
                  r = e.isIndirectStorageBufferAttribute
                    ? uz.INDIRECT
                    : uz.STORAGE;
                this.attributes.update(e, r);
              }
              if (t.isUniformBuffer) t.update() && r.updateBinding(t);
              else if (t.isSampler) t.update();
              else if (t.isSampledTexture) {
                let e = this.textures.get(t.texture);
                t.needsBindingsUpdate(e.generation) && (i = !0);
                let o = t.update(),
                  l = t.texture;
                o && this.textures.updateTexture(l);
                let u = r.get(l);
                if (
                  (void 0 !== u.externalTexture || e.isDefaultTexture
                    ? (s = !1)
                    : ((n = 10 * n + l.id), (a += l.version)),
                  !0 === r.isWebGPUBackend &&
                    void 0 === u.texture &&
                    void 0 === u.externalTexture &&
                    (console.error(
                      "Bindings._update: binding should be available:",
                      t,
                      o,
                      l,
                      t.textureNode.value,
                      i
                    ),
                    this.textures.updateTexture(l),
                    (i = !0)),
                  !0 === l.isStorageTexture)
                ) {
                  let e = this.get(l);
                  !0 === t.store
                    ? (e.needsMipmap = !0)
                    : this.textures.needsMipmaps(l) &&
                      !0 === e.needsMipmap &&
                      (this.backend.generateMipmaps(l), (e.needsMipmap = !1));
                }
              }
            }
          !0 === i && this.backend.updateBindings(e, t, s ? n : 0, a);
        }
      }
      function u1(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function u2(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function u3(e) {
        return (
          (e.transmission > 0 || e.transmissionNode) &&
          e.side === u.$EB &&
          !1 === e.forceSinglePass
        );
      }
      class u4 {
        constructor(e, t, r) {
          (this.renderItems = []),
            (this.renderItemsIndex = 0),
            (this.opaque = []),
            (this.transparentDoublePass = []),
            (this.transparent = []),
            (this.bundles = []),
            (this.lightsNode = e.getNode(t, r)),
            (this.lightsArray = []),
            (this.scene = t),
            (this.camera = r),
            (this.occlusionQueryCount = 0);
        }
        begin() {
          return (
            (this.renderItemsIndex = 0),
            (this.opaque.length = 0),
            (this.transparentDoublePass.length = 0),
            (this.transparent.length = 0),
            (this.bundles.length = 0),
            (this.lightsArray.length = 0),
            (this.occlusionQueryCount = 0),
            this
          );
        }
        getNextRenderItem(e, t, r, i, s, n, a) {
          let o = this.renderItems[this.renderItemsIndex];
          return (
            void 0 === o
              ? ((o = {
                  id: e.id,
                  object: e,
                  geometry: t,
                  material: r,
                  groupOrder: i,
                  renderOrder: e.renderOrder,
                  z: s,
                  group: n,
                  clippingContext: a,
                }),
                (this.renderItems[this.renderItemsIndex] = o))
              : ((o.id = e.id),
                (o.object = e),
                (o.geometry = t),
                (o.material = r),
                (o.groupOrder = i),
                (o.renderOrder = e.renderOrder),
                (o.z = s),
                (o.group = n),
                (o.clippingContext = a)),
            this.renderItemsIndex++,
            o
          );
        }
        push(e, t, r, i, s, n, a) {
          let o = this.getNextRenderItem(e, t, r, i, s, n, a);
          !0 === e.occlusionTest && this.occlusionQueryCount++,
            !0 === r.transparent || r.transmission > 0
              ? (u3(r) && this.transparentDoublePass.push(o),
                this.transparent.push(o))
              : this.opaque.push(o);
        }
        unshift(e, t, r, i, s, n, a) {
          let o = this.getNextRenderItem(e, t, r, i, s, n, a);
          !0 === r.transparent || r.transmission > 0
            ? (u3(r) && this.transparentDoublePass.unshift(o),
              this.transparent.unshift(o))
            : this.opaque.unshift(o);
        }
        pushBundle(e) {
          this.bundles.push(e);
        }
        pushLight(e) {
          this.lightsArray.push(e);
        }
        sort(e, t) {
          this.opaque.length > 1 && this.opaque.sort(e || u1),
            this.transparentDoublePass.length > 1 &&
              this.transparentDoublePass.sort(t || u2),
            this.transparent.length > 1 && this.transparent.sort(t || u2);
        }
        finish() {
          this.lightsNode.setLights(this.lightsArray);
          for (
            let e = this.renderItemsIndex, t = this.renderItems.length;
            e < t;
            e++
          ) {
            let t = this.renderItems[e];
            if (null === t.id) break;
            (t.id = null),
              (t.object = null),
              (t.geometry = null),
              (t.material = null),
              (t.groupOrder = null),
              (t.renderOrder = null),
              (t.z = null),
              (t.group = null),
              (t.clippingContext = null);
          }
        }
      }
      let u6 = [];
      class u5 {
        constructor(e) {
          (this.lighting = e), (this.lists = new uL());
        }
        get(e, t) {
          let r = this.lists;
          (u6[0] = e), (u6[1] = t);
          let i = r.get(u6);
          return (
            void 0 === i && ((i = new u4(this.lighting, e, t)), r.set(u6, i)),
            (u6.length = 0),
            i
          );
        }
        dispose() {
          this.lists = new uL();
        }
      }
      let u8 = 0;
      class u9 {
        constructor() {
          (this.id = u8++),
            (this.color = !0),
            (this.clearColor = !0),
            (this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }),
            (this.depth = !0),
            (this.clearDepth = !0),
            (this.clearDepthValue = 1),
            (this.stencil = !1),
            (this.clearStencil = !0),
            (this.clearStencilValue = 1),
            (this.viewport = !1),
            (this.viewportValue = new u.IUQ()),
            (this.scissor = !1),
            (this.scissorValue = new u.IUQ()),
            (this.renderTarget = null),
            (this.textures = null),
            (this.depthTexture = null),
            (this.activeCubeFace = 0),
            (this.activeMipmapLevel = 0),
            (this.sampleCount = 1),
            (this.width = 0),
            (this.height = 0),
            (this.occlusionQueryCount = 0),
            (this.clippingContext = null),
            (this.isRenderContext = !0);
        }
        getCacheKey() {
          return u7(this);
        }
      }
      function u7(e) {
        let { textures: t, activeCubeFace: r } = e,
          i = [r];
        for (let e of t) i.push(e.id);
        return g(i);
      }
      let de = [],
        dt = new u.Z58(),
        dr = new u.i7d();
      class di {
        constructor() {
          this.chainMaps = {};
        }
        get(e, t, r = null) {
          let i;
          if (((de[0] = e), (de[1] = t), null === r)) i = "default";
          else {
            let e = r.texture.format,
              t = r.textures.length;
            i = `${t}:${e}:${r.samples}:${r.depthBuffer}:${r.stencilBuffer}`;
          }
          let s = this._getChainMap(i),
            n = s.get(de);
          return (
            void 0 === n && ((n = new u9()), s.set(de, n)),
            (de.length = 0),
            null !== r && (n.sampleCount = 0 === r.samples ? 1 : r.samples),
            n
          );
        }
        getForClear(e = null) {
          return this.get(dt, dr, e);
        }
        _getChainMap(e) {
          return this.chainMaps[e] || (this.chainMaps[e] = new uL());
        }
        dispose() {
          this.chainMaps = {};
        }
      }
      let ds = new u.Pq0();
      class dn extends uk {
        constructor(e, t, r) {
          super(), (this.renderer = e), (this.backend = t), (this.info = r);
        }
        updateRenderTarget(e, t = 0) {
          let r = this.get(e),
            i = 0 === e.samples ? 1 : e.samples,
            s = r.depthTextureMips || (r.depthTextureMips = {}),
            n = e.textures,
            a = this.getSize(n[0]),
            o = a.width >> t,
            l = a.height >> t,
            d = e.depthTexture || s[t],
            h = !0 === e.depthBuffer || !0 === e.stencilBuffer,
            c = !1;
          void 0 === d &&
            h &&
            (((d = new u.VCu()).format = e.stencilBuffer ? u.dcC : u.zdS),
            (d.type = e.stencilBuffer ? u.V3x : u.bkx),
            (d.image.width = o),
            (d.image.height = l),
            (s[t] = d)),
            (r.width !== a.width || a.height !== r.height) &&
              ((c = !0),
              d &&
                ((d.needsUpdate = !0),
                (d.image.width = o),
                (d.image.height = l))),
            (r.width = a.width),
            (r.height = a.height),
            (r.textures = n),
            (r.depthTexture = d || null),
            (r.depth = e.depthBuffer),
            (r.stencil = e.stencilBuffer),
            (r.renderTarget = e),
            r.sampleCount !== i &&
              ((c = !0), d && (d.needsUpdate = !0), (r.sampleCount = i));
          let p = { sampleCount: i };
          if (!0 !== e.isXRRenderTarget) {
            for (let e = 0; e < n.length; e++) {
              let t = n[e];
              c && (t.needsUpdate = !0), this.updateTexture(t, p);
            }
            d && this.updateTexture(d, p);
          }
          if (!0 !== r.initialized) {
            r.initialized = !0;
            let t = () => {
              e.removeEventListener("dispose", t);
              for (let e = 0; e < n.length; e++) this._destroyTexture(n[e]);
              d && this._destroyTexture(d), this.delete(e);
            };
            e.addEventListener("dispose", t);
          }
        }
        updateTexture(e, t = {}) {
          let r = this.get(e);
          if (!0 === r.initialized && r.version === e.version) return;
          let i =
              e.isRenderTargetTexture ||
              e.isDepthTexture ||
              e.isFramebufferTexture,
            s = this.backend;
          if (
            (i &&
              !0 === r.initialized &&
              (s.destroySampler(e), s.destroyTexture(e)),
            e.isFramebufferTexture)
          ) {
            let t = this.renderer.getRenderTarget();
            t ? (e.type = t.texture.type) : (e.type = u.OUM);
          }
          let { width: n, height: a, depth: o } = this.getSize(e);
          if (
            ((t.width = n),
            (t.height = a),
            (t.depth = o),
            (t.needsMipmaps = this.needsMipmaps(e)),
            (t.levels = t.needsMipmaps ? this.getMipLevels(e, n, a) : 1),
            i || !0 === e.isStorageTexture)
          )
            s.createSampler(e),
              s.createTexture(e, t),
              (r.generation = e.version);
          else if (
            (!0 !== r.initialized && s.createSampler(e), e.version > 0)
          ) {
            let i = e.image;
            if (void 0 === i)
              console.warn(
                "THREE.Renderer: Texture marked for update but image is undefined."
              );
            else if (!1 === i.complete)
              console.warn(
                "THREE.Renderer: Texture marked for update but image is incomplete."
              );
            else {
              if (e.images) {
                let r = [];
                for (let t of e.images) r.push(t);
                t.images = r;
              } else t.image = i;
              (void 0 === r.isDefaultTexture || !0 === r.isDefaultTexture) &&
                (s.createTexture(e, t),
                (r.isDefaultTexture = !1),
                (r.generation = e.version)),
                !0 === e.source.dataReady && s.updateTexture(e, t),
                t.needsMipmaps &&
                  0 === e.mipmaps.length &&
                  s.generateMipmaps(e);
            }
          } else
            s.createDefaultTexture(e),
              (r.isDefaultTexture = !0),
              (r.generation = e.version);
          if (!0 !== r.initialized) {
            (r.initialized = !0),
              (r.generation = e.version),
              this.info.memory.textures++;
            let t = () => {
              e.removeEventListener("dispose", t),
                this._destroyTexture(e),
                this.info.memory.textures--;
            };
            e.addEventListener("dispose", t);
          }
          r.version = e.version;
        }
        getSize(e, t = ds) {
          let r = e.images ? e.images[0] : e.image;
          return (
            r
              ? (void 0 !== r.image && (r = r.image),
                (t.width = r.width || 1),
                (t.height = r.height || 1),
                (t.depth = e.isCubeTexture ? 6 : r.depth || 1))
              : (t.width = t.height = t.depth = 1),
            t
          );
        }
        getMipLevels(e, t, r) {
          let i;
          return e.isCompressedTexture
            ? e.mipmaps
              ? e.mipmaps.length
              : 1
            : Math.floor(Math.log2(Math.max(t, r))) + 1;
        }
        needsMipmaps(e) {
          return (
            this.isEnvironmentTexture(e) ||
            !0 === e.isCompressedTexture ||
            e.generateMipmaps
          );
        }
        isEnvironmentTexture(e) {
          let t = e.mapping;
          return t === u.wfO || t === u.uV5 || t === u.hy7 || t === u.xFO;
        }
        _destroyTexture(e) {
          this.backend.destroySampler(e),
            this.backend.destroyTexture(e),
            this.delete(e);
        }
      }
      class da extends u.Q1f {
        constructor(e, t, r, i = 1) {
          super(e, t, r), (this.a = i);
        }
        set(e, t, r, i = 1) {
          return (this.a = i), super.set(e, t, r);
        }
        copy(e) {
          return void 0 !== e.a && (this.a = e.a), super.copy(e);
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b, this.a);
        }
      }
      class dl extends ti {
        static get type() {
          return "ParameterNode";
        }
        constructor(e, t = null) {
          super(e, t), (this.isParameterNode = !0);
        }
        getHash() {
          return this.uuid;
        }
        generate() {
          return this.name;
        }
      }
      class du extends V {
        static get type() {
          return "StackNode";
        }
        constructor(e = null) {
          super(),
            (this.nodes = []),
            (this.outputNode = null),
            (this.parent = e),
            (this._currentCond = null),
            (this.isStackNode = !0);
        }
        getNodeType(e) {
          return this.outputNode ? this.outputNode.getNodeType(e) : "void";
        }
        getMemberType(e, t) {
          return this.outputNode ? this.outputNode.getMemberType(e, t) : "void";
        }
        add(e) {
          return this.nodes.push(e), this;
        }
        If(e, t) {
          let r = new eS(t);
          return (this._currentCond = r7(e, r)), this.add(this._currentCond);
        }
        ElseIf(e, t) {
          let r = r7(e, new eS(t));
          return (
            (this._currentCond.elseNode = r), (this._currentCond = r), this
          );
        }
        Else(e) {
          return (this._currentCond.elseNode = new eS(e)), this;
        }
        build(e, ...t) {
          let r = eF();
          for (let t of (eB(this), this.nodes)) t.build(e, "void");
          return (
            eB(r),
            this.outputNode
              ? this.outputNode.build(e, ...t)
              : super.build(e, ...t)
          );
        }
        else(...e) {
          return (
            console.warn("TSL.StackNode: .else() has been renamed to .Else()."),
            this.Else(...e)
          );
        }
        elseif(...e) {
          return (
            console.warn(
              "TSL.StackNode: .elseif() has been renamed to .ElseIf()."
            ),
            this.ElseIf(...e)
          );
        }
      }
      let dd = eE(du);
      class dh extends V {
        static get type() {
          return "StructTypeNode";
        }
        constructor(e, t = null) {
          super("struct"),
            (this.membersLayout = Object.entries(e).map(([e, t]) =>
              "string" == typeof t
                ? { name: e, type: t, atomic: !1 }
                : { name: e, type: t.type, atomic: t.atomic || !1 }
            )),
            (this.name = t),
            (this.isStructLayoutNode = !0);
        }
        getLength() {
          let e = 0;
          for (let t of this.membersLayout) e += v(t.type);
          return e;
        }
        getMemberType(e, t) {
          let r = this.membersLayout.find((e) => e.name === t);
          return r ? r.type : "void";
        }
        getNodeType(e) {
          return e.getStructTypeFromNode(this, this.membersLayout, this.name)
            .name;
        }
        setup(e) {
          e.addInclude(this);
        }
        generate(e) {
          return this.getNodeType(e);
        }
      }
      class dc extends V {
        static get type() {
          return "StructNode";
        }
        constructor(e, t) {
          super("vec3"),
            (this.structLayoutNode = e),
            (this.values = t),
            (this.isStructNode = !0);
        }
        getNodeType(e) {
          return this.structLayoutNode.getNodeType(e);
        }
        getMemberType(e, t) {
          return this.structLayoutNode.getMemberType(e, t);
        }
        generate(e) {
          let t = e.getVarFromNode(this),
            r = t.type,
            i = e.getPropertyName(t);
          return (
            e.addLineFlowCode(
              `${i} = ${e.generateStruct(
                r,
                this.structLayoutNode.membersLayout,
                this.values
              )}`,
              this
            ),
            t.name
          );
        }
      }
      class dp extends V {
        static get type() {
          return "OutputStructNode";
        }
        constructor(...e) {
          super(), (this.members = e), (this.isOutputStructNode = !0);
        }
        getNodeType(e) {
          let t = e.getNodeProperties(this);
          if (void 0 === t.membersLayout) {
            let r = this.members,
              i = [];
            for (let t = 0; t < r.length; t++) {
              let s = "m" + t,
                n = r[t].getNodeType(e);
              i.push({ name: s, type: n, index: t });
            }
            (t.membersLayout = i),
              (t.structType = e.getOutputStructTypeFromNode(
                this,
                t.membersLayout
              ));
          }
          return t.structType.name;
        }
        generate(e) {
          let t = e.getOutputStructName(),
            r = this.members,
            i = "" !== t ? t + "." : "";
          for (let t = 0; t < r.length; t++) {
            let s = r[t].build(e);
            e.addLineFlowCode(`${i}m${t} = ${s}`, this);
          }
          return t;
        }
      }
      let dg = eE(dp);
      function dm(e, t) {
        for (let r = 0; r < e.length; r++) if (e[r].name === t) return r;
        return -1;
      }
      class df extends dp {
        static get type() {
          return "MRTNode";
        }
        constructor(e) {
          super(), (this.outputNodes = e), (this.isMRTNode = !0);
        }
        has(e) {
          return void 0 !== this.outputNodes[e];
        }
        get(e) {
          return this.outputNodes[e];
        }
        merge(e) {
          return dy({ ...this.outputNodes, ...e.outputNodes });
        }
        setup(e) {
          let t = this.outputNodes,
            r = e.renderer.getRenderTarget(),
            i = [],
            s = r.textures;
          for (let e in t) i[dm(s, e)] = eX(t[e]);
          return (this.members = i), super.setup(e);
        }
      }
      let dy = eE(df),
        dx = eM(([e]) => {
          let t = e.toUint().mul(0x2c9277b5).add(0xac564b05),
            r = t.shiftRight(t.shiftRight(28).add(4)).bitXor(t).mul(0x108ef2d9);
          return r
            .shiftRight(22)
            .bitXor(r)
            .toFloat()
            .mul(1 / 0x100000000);
        }),
        db = (e, t) => rH(tk(4, e.mul(tG(1, e))), t),
        dT = eM(([e]) => e.fract().sub(0.5).abs()).setLayout({
          name: "tri",
          type: "float",
          inputs: [{ name: "x", type: "float" }],
        }),
        d_ = eM(([e]) =>
          eW(
            dT(e.z.add(dT(e.y.mul(1)))),
            dT(e.z.add(dT(e.x.mul(1)))),
            dT(e.y.add(dT(e.x.mul(1))))
          )
        ).setLayout({
          name: "tri3",
          type: "vec3",
          inputs: [{ name: "p", type: "vec3" }],
        }),
        dv = eM(([e, t, r]) => {
          let i = eW(e).toVar(),
            s = eL(1.4).toVar(),
            n = eL(0).toVar(),
            a = eW(i).toVar();
          return (
            aT(
              { start: eL(0), end: eL(3), type: "float", condition: "<=" },
              () => {
                let e = eW(d_(a.mul(2))).toVar();
                i.addAssign(e.add(r.mul(eL(0.1).mul(t)))),
                  a.mulAssign(1.8),
                  s.mulAssign(1.5),
                  i.mulAssign(1.2);
                let o = eL(dT(i.z.add(dT(i.x.add(dT(i.y)))))).toVar();
                n.addAssign(o.div(s)), a.addAssign(0.14);
              }
            ),
            n
          );
        }).setLayout({
          name: "triNoise3D",
          type: "float",
          inputs: [
            { name: "position", type: "vec3" },
            { name: "speed", type: "float" },
            { name: "time", type: "float" },
          ],
        });
      class dN extends V {
        static get type() {
          return "FunctionOverloadingNode";
        }
        constructor(e = [], ...t) {
          super(),
            (this.functionNodes = e),
            (this.parametersNodes = t),
            (this._candidateFnCall = null),
            (this.global = !0);
        }
        getNodeType() {
          return this.functionNodes[0].shaderNode.layout.type;
        }
        setup(e) {
          let t = this.parametersNodes,
            r = this._candidateFnCall;
          if (null === r) {
            let i = null,
              s = -1;
            for (let r of this.functionNodes) {
              let n = r.shaderNode.layout;
              if (null === n)
                throw Error(
                  "FunctionOverloadingNode: FunctionNode must be a layout."
                );
              let a = n.inputs;
              if (t.length === a.length) {
                let n = 0;
                for (let r = 0; r < t.length; r++) {
                  let i = t[r],
                    s = a[r];
                  i.getNodeType(e) === s.type ? n++ : (n = 0);
                }
                n > s && ((i = r), (s = n));
              }
            }
            this._candidateFnCall = r = i(...t);
          }
          return r;
        }
      }
      let dS = eE(dN),
        dR =
          (e) =>
          (...t) =>
            dS(e, ...t),
        dA = tr(0)
          .setGroup(e7)
          .onRenderUpdate((e) => e.time),
        dC = tr(0)
          .setGroup(e7)
          .onRenderUpdate((e) => e.deltaTime),
        dE = tr(0, "uint")
          .setGroup(e7)
          .onRenderUpdate((e) => e.frameId),
        dw = eM(([e, t, r = eG(0.5)]) => uv(e.sub(r), t).add(r)),
        dM = eM(([e, t, r = eG(0.5)]) => {
          let i = e.sub(r),
            s = i.dot(i),
            n = s.mul(s).mul(t);
          return e.add(i.mul(n));
        }),
        dB = eM(
          ({ position: e = null, horizontal: t = !0, vertical: r = !1 }) => {
            let i;
            null !== e
              ? (((i = sT.toVar())[3][0] = e.x),
                (i[3][1] = e.y),
                (i[3][2] = e.z))
              : (i = sT);
            let s = sa.mul(i);
            return (
              ev(t) &&
                ((s[0][0] = sT[0].length()), (s[0][1] = 0), (s[0][2] = 0)),
              ev(r) &&
                ((s[1][0] = 0), (s[1][1] = sT[1].length()), (s[1][2] = 0)),
              (s[2][0] = 0),
              (s[2][1] = 0),
              (s[2][2] = 1),
              ss.mul(s).mul(sF)
            );
          }
        ),
        dF = eM(([e = null]) => {
          let t = a3();
          return a3(aQ(e)).sub(t).lessThan(0).select(aU, e);
        });
      class dU extends V {
        static get type() {
          return "SpriteSheetUVNode";
        }
        constructor(e, t = iZ(), r = eL(0)) {
          super("vec2"),
            (this.countNode = e),
            (this.uvNode = t),
            (this.frameNode = r);
        }
        setup() {
          let { frameNode: e, uvNode: t, countNode: r } = this,
            { width: i, height: s } = r,
            n = e.mod(i.mul(s)).floor(),
            a = n.mod(i),
            o = s.sub(n.add(1).div(i).ceil()),
            l = r.reciprocal(),
            u = eG(a, o);
          return t.add(u).mul(l);
        }
      }
      let dI = eE(dU);
      class dP extends V {
        static get type() {
          return "TriplanarTexturesNode";
        }
        constructor(e, t = null, r = null, i = eL(1), s = sF, n = sz) {
          super("vec4"),
            (this.textureXNode = e),
            (this.textureYNode = t),
            (this.textureZNode = r),
            (this.scaleNode = i),
            (this.positionNode = s),
            (this.normalNode = n);
        }
        setup() {
          let {
              textureXNode: e,
              textureYNode: t,
              textureZNode: r,
              scaleNode: i,
              positionNode: s,
              normalNode: n,
            } = this,
            a = n.abs().normalize();
          a = a.div(a.dot(eW(1)));
          let o = s.yz.mul(i),
            l = s.zx.mul(i),
            u = s.xy.mul(i),
            d = e.value,
            h = null !== t ? t.value : d,
            c = null !== r ? r.value : d,
            p = i4(d, o).mul(a.x);
          return tO(p, i4(h, l).mul(a.y), i4(c, u).mul(a.z));
        }
      }
      let dL = eE(dP),
        dD = new u.Zcv(),
        dV = new u.Pq0(),
        dO = new u.Pq0(),
        dG = new u.Pq0(),
        dk = new u.kn4(),
        dz = new u.Pq0(0, 0, -1),
        d$ = new u.IUQ(),
        dW = new u.Pq0(),
        dH = new u.Pq0(),
        dq = new u.IUQ(),
        dj = new u.I9Y(),
        dX = new u.O0B(),
        dQ = aU.flipX();
      dX.depthTexture = new u.VCu(1, 1);
      let dK = !1;
      class dY extends i3 {
        static get type() {
          return "ReflectorNode";
        }
        constructor(e = {}) {
          super(e.defaultTexture || dX.texture, dQ),
            (this._reflectorBaseNode = e.reflector || new dZ(this, e)),
            (this._depthNode = null),
            this.setUpdateMatrix(!1);
        }
        get reflector() {
          return this._reflectorBaseNode;
        }
        get target() {
          return this._reflectorBaseNode.target;
        }
        getDepthNode() {
          if (null === this._depthNode) {
            if (!0 !== this._reflectorBaseNode.depth)
              throw Error(
                "THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. "
              );
            this._depthNode = eR(
              new dY({
                defaultTexture: dX.depthTexture,
                reflector: this._reflectorBaseNode,
              })
            );
          }
          return this._depthNode;
        }
        setup(e) {
          return (
            e.object.isQuadMesh || this._reflectorBaseNode.build(e),
            super.setup(e)
          );
        }
        clone() {
          let e = new this.constructor(this.reflectorNode);
          return (e._reflectorBaseNode = this._reflectorBaseNode), e;
        }
      }
      class dZ extends V {
        static get type() {
          return "ReflectorBaseNode";
        }
        constructor(e, t = {}) {
          super();
          let {
            target: r = new u.B69(),
            resolution: i = 1,
            generateMipmaps: s = !1,
            bounces: n = !0,
            depth: a = !1,
          } = t;
          (this.textureNode = e),
            (this.target = r),
            (this.resolution = i),
            (this.generateMipmaps = s),
            (this.bounces = n),
            (this.depth = a),
            (this.updateBeforeType = n ? M.RENDER : M.FRAME),
            (this.virtualCameras = new WeakMap()),
            (this.renderTargets = new WeakMap()),
            (this.forceUpdate = !1);
        }
        _updateResolution(e, t) {
          let r = this.resolution;
          t.getDrawingBufferSize(dj),
            e.setSize(Math.round(dj.width * r), Math.round(dj.height * r));
        }
        setup(e) {
          return this._updateResolution(dX, e.renderer), super.setup(e);
        }
        getVirtualCamera(e) {
          let t = this.virtualCameras.get(e);
          return (
            void 0 === t && ((t = e.clone()), this.virtualCameras.set(e, t)), t
          );
        }
        getRenderTarget(e) {
          let t = this.renderTargets.get(e);
          return (
            void 0 === t &&
              ((t = new u.O0B(0, 0, { type: u.ix0 })),
              !0 === this.generateMipmaps &&
                ((t.texture.minFilter = u.NZq),
                (t.texture.generateMipmaps = !0)),
              !0 === this.depth && (t.depthTexture = new u.VCu()),
              this.renderTargets.set(e, t)),
            t
          );
        }
        updateBefore(e) {
          if (!1 === this.bounces && dK) return !1;
          dK = !0;
          let { scene: t, camera: r, renderer: i, material: s } = e,
            { target: n } = this,
            a = this.getVirtualCamera(r),
            o = this.getRenderTarget(a);
          if (
            (i.getDrawingBufferSize(dj),
            this._updateResolution(o, i),
            dO.setFromMatrixPosition(n.matrixWorld),
            dG.setFromMatrixPosition(r.matrixWorld),
            dk.extractRotation(n.matrixWorld),
            dV.set(0, 0, 1),
            dV.applyMatrix4(dk),
            dW.subVectors(dO, dG),
            !0 == dW.dot(dV) > 0 && !1 === this.forceUpdate)
          )
            return;
          dW.reflect(dV).negate(),
            dW.add(dO),
            dk.extractRotation(r.matrixWorld),
            dz.set(0, 0, -1),
            dz.applyMatrix4(dk),
            dz.add(dG),
            dH.subVectors(dO, dz),
            dH.reflect(dV).negate(),
            dH.add(dO),
            (a.coordinateSystem = r.coordinateSystem),
            a.position.copy(dW),
            a.up.set(0, 1, 0),
            a.up.applyMatrix4(dk),
            a.up.reflect(dV),
            a.lookAt(dH),
            (a.near = r.near),
            (a.far = r.far),
            a.updateMatrixWorld(),
            a.projectionMatrix.copy(r.projectionMatrix),
            dD.setFromNormalAndCoplanarPoint(dV, dO),
            dD.applyMatrix4(a.matrixWorldInverse),
            d$.set(dD.normal.x, dD.normal.y, dD.normal.z, dD.constant);
          let l = a.projectionMatrix;
          (dq.x = (Math.sign(d$.x) + l.elements[8]) / l.elements[0]),
            (dq.y = (Math.sign(d$.y) + l.elements[9]) / l.elements[5]),
            (dq.z = -1),
            (dq.w = (1 + l.elements[10]) / l.elements[14]),
            d$.multiplyScalar(1 / d$.dot(dq)),
            (l.elements[2] = d$.x),
            (l.elements[6] = d$.y),
            (l.elements[10] =
              i.coordinateSystem === u.i7u ? d$.z - 0 : d$.z + 1 - 0),
            (l.elements[14] = d$.w),
            (this.textureNode.value = o.texture),
            !0 === this.depth &&
              (this.textureNode.getDepthNode().value = o.depthTexture),
            (s.visible = !1);
          let d = i.getRenderTarget(),
            h = i.getMRT(),
            c = i.autoClear;
          i.setMRT(null),
            i.setRenderTarget(o),
            (i.autoClear = !0),
            i.render(t, a),
            i.setMRT(h),
            i.setRenderTarget(d),
            (i.autoClear = c),
            (s.visible = !0),
            (dK = !1),
            (this.forceUpdate = !1);
        }
      }
      let dJ = new u.qUd(-1, 1, 1, -1, 0, 1);
      class d0 extends u.LoY {
        constructor(e = !1) {
          super(),
            this.setAttribute(
              "position",
              new u.qtW([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
            ),
            this.setAttribute(
              "uv",
              new u.qtW(!1 === e ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0], 2)
            );
        }
      }
      let d1 = new d0();
      class d2 extends u.eaF {
        constructor(e = null) {
          super(d1, e), (this.camera = dJ), (this.isQuadMesh = !0);
        }
        async renderAsync(e) {
          return e.renderAsync(this, dJ);
        }
        render(e) {
          e.render(this, dJ);
        }
      }
      let d3 = new u.I9Y();
      class d4 extends i3 {
        static get type() {
          return "RTTNode";
        }
        constructor(e, t = null, r = null, i = { type: u.ix0 }) {
          let s = new u.O0B(t, r, i);
          super(s.texture, iZ()),
            (this.node = e),
            (this.width = t),
            (this.height = r),
            (this.pixelRatio = 1),
            (this.renderTarget = s),
            (this.textureNeedsUpdate = !0),
            (this.autoUpdate = !0),
            (this._rttNode = null),
            (this._quadMesh = new d2(new os())),
            (this.updateBeforeType = M.RENDER);
        }
        get autoSize() {
          return null === this.width;
        }
        setup(e) {
          return (
            (this._rttNode = this.node.context(e.getSharedContext())),
            (this._quadMesh.material.name = "RTT"),
            (this._quadMesh.material.needsUpdate = !0),
            super.setup(e)
          );
        }
        setSize(e, t) {
          (this.width = e), (this.height = t);
          let r = e * this.pixelRatio,
            i = t * this.pixelRatio;
          this.renderTarget.setSize(r, i), (this.textureNeedsUpdate = !0);
        }
        setPixelRatio(e) {
          (this.pixelRatio = e), this.setSize(this.width, this.height);
        }
        updateBefore({ renderer: e }) {
          if (!1 === this.textureNeedsUpdate && !1 === this.autoUpdate) return;
          if (((this.textureNeedsUpdate = !1), !0 === this.autoSize)) {
            this.pixelRatio = e.getPixelRatio();
            let t = e.getSize(d3);
            this.setSize(t.width, t.height);
          }
          this._quadMesh.material.fragmentNode = this._rttNode;
          let t = e.getRenderTarget();
          e.setRenderTarget(this.renderTarget),
            this._quadMesh.render(e),
            e.setRenderTarget(t);
        }
        clone() {
          let e = new i3(this.value, this.uvNode, this.levelNode);
          return (e.sampler = this.sampler), (e.referenceNode = this), e;
        }
      }
      let d6 = (e, ...t) => eR(new d4(eR(e), ...t)),
        d5 = eM(([e, t, r], i) => {
          let s;
          s =
            i.renderer.coordinateSystem === u.i7u
              ? eX(eW((e = eG(e.x, e.y.oneMinus()).mul(2).sub(1)), t), 1)
              : eX(eW(e.x, e.y.oneMinus(), t).mul(2).sub(1), 1);
          let n = eX(r.mul(s));
          return n.xyz.div(n.w);
        }),
        d8 = eM(([e, t]) => {
          let r = t.mul(eX(e, 1)),
            i = r.xy.div(r.w).mul(0.5).add(0.5).toVar();
          return eG(i.x, i.y.oneMinus());
        }),
        d9 = eM(([e, t, r]) => {
          let i = i0(i6(t)),
            s = ek(e.mul(i)).toVar(),
            n = i6(t, s).toVar(),
            a = i6(t, s.sub(ek(2, 0))).toVar(),
            o = i6(t, s.sub(ek(1, 0))).toVar(),
            l = i6(t, s.add(ek(1, 0))).toVar(),
            u = i6(t, s.add(ek(2, 0))).toVar(),
            d = i6(t, s.add(ek(0, 2))).toVar(),
            h = i6(t, s.add(ek(0, 1))).toVar(),
            c = i6(t, s.sub(ek(0, 1))).toVar(),
            p = i6(t, s.sub(ek(0, 2))).toVar(),
            g = rv(tG(eL(2).mul(o).sub(a), n)).toVar(),
            m = rv(tG(eL(2).mul(l).sub(u), n)).toVar(),
            f = rv(tG(eL(2).mul(h).sub(d), n)).toVar(),
            y = rv(tG(eL(2).mul(c).sub(p), n)).toVar(),
            x = d5(e, n, r).toVar();
          return rg(
            rW(
              g
                .lessThan(m)
                .select(
                  x.sub(d5(e.sub(eG(eL(1).div(i.x), 0)), o, r)),
                  x.negate().add(d5(e.add(eG(eL(1).div(i.x), 0)), l, r))
                ),
              f
                .lessThan(y)
                .select(
                  x.sub(d5(e.add(eG(0, eL(1).div(i.y))), h, r)),
                  x.negate().add(d5(e.sub(eG(0, eL(1).div(i.y))), c, r))
                )
            )
          );
        });
      class d7 extends u.uWO {
        constructor(e, t, r = Float32Array) {
          super(ArrayBuffer.isView(e) ? e : new r(e * t), t),
            (this.isStorageInstancedBufferAttribute = !0);
        }
      }
      class he extends u.THS {
        constructor(e, t, r = Float32Array) {
          super(ArrayBuffer.isView(e) ? e : new r(e * t), t),
            (this.isStorageBufferAttribute = !0);
        }
      }
      class ht extends O {
        static get type() {
          return "StorageArrayElementNode";
        }
        constructor(e, t) {
          super(e, t), (this.isStorageArrayElementNode = !0);
        }
        set storageBufferNode(e) {
          this.node = e;
        }
        get storageBufferNode() {
          return this.node;
        }
        getMemberType(e, t) {
          let r = this.storageBufferNode.structTypeNode;
          return r ? r.getMemberType(e, t) : "void";
        }
        setup(e) {
          return (
            !1 === e.isAvailable("storageBuffer") &&
              !0 === this.node.isPBO &&
              e.setupPBO(this.node),
            super.setup(e)
          );
        }
        generate(e, t) {
          let r,
            i = e.context.assign;
          if (
            ((r =
              !1 === e.isAvailable("storageBuffer")
                ? !0 === this.node.isPBO &&
                  !0 !== i &&
                  (this.node.value.isInstancedBufferAttribute ||
                    "compute" !== e.shaderStage)
                  ? e.generatePBO(this)
                  : this.node.build(e)
                : super.generate(e)),
            !0 !== i)
          ) {
            let i = this.getNodeType(e);
            r = e.format(r, i, t);
          }
          return r;
        }
      }
      let hr = eE(ht);
      class hi extends i5 {
        static get type() {
          return "StorageBufferNode";
        }
        constructor(e, t = null, r = 0) {
          let i,
            s = null;
          t && t.isStruct
            ? ((i = "struct"), (s = t.layout))
            : null === t &&
              (e.isStorageBufferAttribute ||
                e.isStorageInstancedBufferAttribute)
            ? ((i = T(e.itemSize)), (r = e.count))
            : (i = t),
            super(e, i, r),
            (this.isStorageBufferNode = !0),
            (this.structTypeNode = s),
            (this.access = F.READ_WRITE),
            (this.isAtomic = !1),
            (this.isPBO = !1),
            (this._attribute = null),
            (this._varying = null),
            (this.global = !0),
            !0 !== e.isStorageBufferAttribute &&
              !0 !== e.isStorageInstancedBufferAttribute &&
              (e.isInstancedBufferAttribute
                ? (e.isStorageInstancedBufferAttribute = !0)
                : (e.isStorageBufferAttribute = !0));
        }
        getHash(e) {
          if (0 === this.bufferCount) {
            let t = e.globalCache.getData(this.value);
            return (
              void 0 === t &&
                ((t = { node: this }), e.globalCache.setData(this.value, t)),
              t.node.uuid
            );
          }
          return this.uuid;
        }
        getInputType() {
          return this.value.isIndirectStorageBufferAttribute
            ? "indirectStorageBuffer"
            : "storageBuffer";
        }
        element(e) {
          return hr(this, e);
        }
        setPBO(e) {
          return (this.isPBO = e), this;
        }
        getPBO() {
          return this.isPBO;
        }
        setAccess(e) {
          return (this.access = e), this;
        }
        toReadOnly() {
          return this.setAccess(F.READ_ONLY);
        }
        setAtomic(e) {
          return (this.isAtomic = e), this;
        }
        toAtomic() {
          return this.setAtomic(!0);
        }
        getAttributeData() {
          return (
            null === this._attribute &&
              ((this._attribute = iF(this.value)),
              (this._varying = ih(this._attribute))),
            { attribute: this._attribute, varying: this._varying }
          );
        }
        getNodeType(e) {
          if (null !== this.structTypeNode)
            return this.structTypeNode.getNodeType(e);
          if (
            e.isAvailable("storageBuffer") ||
            e.isAvailable("indirectStorageBuffer")
          )
            return super.getNodeType(e);
          let { attribute: t } = this.getAttributeData();
          return t.getNodeType(e);
        }
        generate(e) {
          if (
            (null !== this.structTypeNode && this.structTypeNode.build(e),
            e.isAvailable("storageBuffer") ||
              e.isAvailable("indirectStorageBuffer"))
          )
            return super.generate(e);
          let { attribute: t, varying: r } = this.getAttributeData(),
            i = r.build(e);
          return e.registerTransform(i, t), i;
        }
      }
      let hs = (e, t = null, r = 0) => eR(new hi(e, t, r));
      class hn extends iK {
        static get type() {
          return "VertexColorNode";
        }
        constructor(e = 0) {
          super(null, "vec4"), (this.isVertexColorNode = !0), (this.index = e);
        }
        getAttributeName() {
          let e = this.index;
          return "color" + (e > 0 ? e : "");
        }
        generate(e) {
          let t,
            r = this.getAttributeName(e);
          return !0 === e.hasGeometryAttribute(r)
            ? super.generate(e)
            : e.generateConst(this.nodeType, new u.IUQ(1, 1, 1, 1));
        }
        serialize(e) {
          super.serialize(e), (e.index = this.index);
        }
        deserialize(e) {
          super.deserialize(e), (this.index = e.index);
        }
      }
      class ha extends V {
        static get type() {
          return "PointUVNode";
        }
        constructor() {
          super("vec2"), (this.isPointUVNode = !0);
        }
        generate() {
          return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
        }
      }
      let ho = ew(ha),
        hl = new u.O9p(),
        hu = new u.kn4();
      class hd extends V {
        static get type() {
          return "SceneNode";
        }
        constructor(e = hd.BACKGROUND_BLURRINESS, t = null) {
          super(), (this.scope = e), (this.scene = t);
        }
        setup(e) {
          let t,
            r = this.scope,
            i = null !== this.scene ? this.scene : e.scene;
          return (
            r === hd.BACKGROUND_BLURRINESS
              ? (t = ne("backgroundBlurriness", "float", i))
              : r === hd.BACKGROUND_INTENSITY
              ? (t = ne("backgroundIntensity", "float", i))
              : r === hd.BACKGROUND_ROTATION
              ? (t = tr("mat4")
                  .label("backgroundRotation")
                  .setGroup(e7)
                  .onRenderUpdate(() => {
                    let e = i.background;
                    return (
                      null !== e && e.isTexture && e.mapping !== u.UTZ
                        ? (hl.copy(i.backgroundRotation),
                          (hl.x *= -1),
                          (hl.y *= -1),
                          (hl.z *= -1),
                          hu.makeRotationFromEuler(hl))
                        : hu.identity(),
                      hu
                    );
                  }))
              : console.error("THREE.SceneNode: Unknown scope:", r),
            t
          );
        }
      }
      (hd.BACKGROUND_BLURRINESS = "backgroundBlurriness"),
        (hd.BACKGROUND_INTENSITY = "backgroundIntensity"),
        (hd.BACKGROUND_ROTATION = "backgroundRotation");
      let hh = ew(hd, hd.BACKGROUND_BLURRINESS),
        hc = ew(hd, hd.BACKGROUND_INTENSITY),
        hp = ew(hd, hd.BACKGROUND_ROTATION);
      class hg extends i3 {
        static get type() {
          return "StorageTextureNode";
        }
        constructor(e, t, r = null) {
          super(e, t),
            (this.storeNode = r),
            (this.isStorageTextureNode = !0),
            (this.access = F.WRITE_ONLY);
        }
        getInputType() {
          return "storageTexture";
        }
        setup(e) {
          super.setup(e),
            (e.getNodeProperties(this).storeNode = this.storeNode);
        }
        setAccess(e) {
          return (this.access = e), this;
        }
        generate(e, t) {
          let r;
          return null !== this.storeNode
            ? this.generateStore(e)
            : super.generate(e, t);
        }
        toReadWrite() {
          return this.setAccess(F.READ_WRITE);
        }
        toReadOnly() {
          return this.setAccess(F.READ_ONLY);
        }
        toWriteOnly() {
          return this.setAccess(F.WRITE_ONLY);
        }
        generateStore(e) {
          let { uvNode: t, storeNode: r } = e.getNodeProperties(this),
            i = super.generate(e, "property"),
            s = t.build(e, "uvec2"),
            n = r.build(e, "vec4"),
            a = e.generateTextureStore(e, i, s, n);
          e.addLineFlowCode(a, this);
        }
      }
      let hm = eE(hg),
        hf = eM(({ texture: e, uv: t }) => {
          let r = eW().toVar();
          return (
            eU(t.x.lessThan(1e-4), () => {
              r.assign(eW(1, 0, 0));
            })
              .ElseIf(t.y.lessThan(1e-4), () => {
                r.assign(eW(0, 1, 0));
              })
              .ElseIf(t.z.lessThan(1e-4), () => {
                r.assign(eW(0, 0, 1));
              })
              .ElseIf(t.x.greaterThan(0.9999), () => {
                r.assign(eW(-1, 0, 0));
              })
              .ElseIf(t.y.greaterThan(0.9999), () => {
                r.assign(eW(0, -1, 0));
              })
              .ElseIf(t.z.greaterThan(0.9999), () => {
                r.assign(eW(0, 0, -1));
              })
              .Else(() => {
                let i = e
                    .sample(t.add(eW(-0.01, 0, 0)))
                    .r.sub(e.sample(t.add(eW(0.01, 0, 0))).r),
                  s = e
                    .sample(t.add(eW(0, -0.01, 0)))
                    .r.sub(e.sample(t.add(eW(0, 0.01, 0))).r),
                  n = e
                    .sample(t.add(eW(0, 0, -0.01)))
                    .r.sub(e.sample(t.add(eW(0, 0, 0.01))).r);
                r.assign(eW(i, s, n));
              }),
            r.normalize()
          );
        });
      class hy extends i3 {
        static get type() {
          return "Texture3DNode";
        }
        constructor(e, t = null, r = null) {
          super(e, t, r), (this.isTexture3DNode = !0);
        }
        getInputType() {
          return "texture3D";
        }
        getDefaultUV() {
          return eW(0.5, 0.5, 0.5);
        }
        setUpdateMatrix() {}
        setupUV(e, t) {
          let r = this.value;
          return (
            e.isFlipY() &&
              (!0 === r.isRenderTargetTexture ||
                !0 === r.isFramebufferTexture) &&
              (t = this.sampler
                ? t.flipY()
                : t.setY(eD(i0(this, this.levelNode).y).sub(t.y).sub(1))),
            t
          );
        }
        generateUV(e, t) {
          return t.build(e, "vec3");
        }
        normal(e) {
          return hf({ texture: this, uv: e });
        }
      }
      let hx = eE(hy);
      class hb extends s7 {
        static get type() {
          return "UserDataNode";
        }
        constructor(e, t, r = null) {
          super(e, t, r), (this.userData = r);
        }
        updateReference(e) {
          return (
            (this.reference =
              null !== this.userData ? this.userData : e.object.userData),
            this.reference
          );
        }
      }
      let hT = new WeakMap();
      class h_ extends k {
        static get type() {
          return "VelocityNode";
        }
        constructor() {
          super("vec2"),
            (this.projectionMatrix = null),
            (this.updateType = M.OBJECT),
            (this.updateAfterType = M.OBJECT),
            (this.previousModelWorldMatrix = tr(new u.kn4())),
            (this.previousProjectionMatrix = tr(new u.kn4()).setGroup(e7)),
            (this.previousCameraViewMatrix = tr(new u.kn4()));
        }
        setProjectionMatrix(e) {
          this.projectionMatrix = e;
        }
        update({ frameId: e, camera: t, object: r }) {
          let i = hN(r);
          this.previousModelWorldMatrix.value.copy(i);
          let s = hv(t);
          s.frameId !== e &&
            ((s.frameId = e),
            void 0 === s.previousProjectionMatrix
              ? ((s.previousProjectionMatrix = new u.kn4()),
                (s.previousCameraViewMatrix = new u.kn4()),
                (s.currentProjectionMatrix = new u.kn4()),
                (s.currentCameraViewMatrix = new u.kn4()),
                s.previousProjectionMatrix.copy(
                  this.projectionMatrix || t.projectionMatrix
                ),
                s.previousCameraViewMatrix.copy(t.matrixWorldInverse))
              : (s.previousProjectionMatrix.copy(s.currentProjectionMatrix),
                s.previousCameraViewMatrix.copy(s.currentCameraViewMatrix)),
            s.currentProjectionMatrix.copy(
              this.projectionMatrix || t.projectionMatrix
            ),
            s.currentCameraViewMatrix.copy(t.matrixWorldInverse),
            this.previousProjectionMatrix.value.copy(
              s.previousProjectionMatrix
            ),
            this.previousCameraViewMatrix.value.copy(
              s.previousCameraViewMatrix
            ));
        }
        updateAfter({ object: e }) {
          hN(e).copy(e.matrixWorld);
        }
        setup() {
          let e =
              null === this.projectionMatrix ? ss : tr(this.projectionMatrix),
            t = this.previousCameraViewMatrix.mul(
              this.previousModelWorldMatrix
            ),
            r = e.mul(sC).mul(sF),
            i = this.previousProjectionMatrix.mul(t).mul(sU);
          return tG(r.xy.div(r.w), i.xy.div(i.w));
        }
      }
      function hv(e) {
        let t = hT.get(e);
        return void 0 === t && ((t = {}), hT.set(e, t)), t;
      }
      function hN(e, t = 0) {
        let r = hv(e),
          i = r[t];
        return void 0 === i && (r[t] = i = new u.kn4()), i;
      }
      let hS = ew(h_),
        hR = eM(([e, t]) => rL(1, e.oneMinus().div(t)).oneMinus()).setLayout({
          name: "blendBurn",
          type: "vec3",
          inputs: [
            { name: "base", type: "vec3" },
            { name: "blend", type: "vec3" },
          ],
        }),
        hA = eM(([e, t]) => rL(e.div(t.oneMinus()), 1)).setLayout({
          name: "blendDodge",
          type: "vec3",
          inputs: [
            { name: "base", type: "vec3" },
            { name: "blend", type: "vec3" },
          ],
        }),
        hC = eM(([e, t]) =>
          e.oneMinus().mul(t.oneMinus()).oneMinus()
        ).setLayout({
          name: "blendScreen",
          type: "vec3",
          inputs: [
            { name: "base", type: "vec3" },
            { name: "blend", type: "vec3" },
          ],
        }),
        hE = eM(([e, t]) =>
          rZ(
            e.mul(2).mul(t),
            e.oneMinus().mul(2).mul(t.oneMinus()).oneMinus(),
            rO(0.5, e)
          )
        ).setLayout({
          name: "blendOverlay",
          type: "vec3",
          inputs: [
            { name: "base", type: "vec3" },
            { name: "blend", type: "vec3" },
          ],
        }),
        hw = eM(([e, t]) => {
          let r = t.a.add(e.a.mul(t.a.oneMinus()));
          return eX(
            t.rgb.mul(t.a).add(e.rgb.mul(e.a).mul(t.a.oneMinus())).div(r),
            r
          );
        }).setLayout({
          name: "blendColor",
          type: "vec4",
          inputs: [
            { name: "base", type: "vec4" },
            { name: "blend", type: "vec4" },
          ],
        }),
        hM = eM(([e]) => hI(e.rgb)),
        hB = eM(([e, t = eL(1)]) => t.mix(hI(e.rgb), e.rgb)),
        hF = eM(([e, t = eL(1)]) => {
          let r = tO(e.r, e.g, e.b).div(3),
            i = e.r.max(e.g.max(e.b)),
            s = i.sub(r).mul(t).mul(-3);
          return rZ(e.rgb, i, s);
        }),
        hU = eM(([e, t = eL(1)]) => {
          let r = eW(0.57735, 0.57735, 0.57735),
            i = t.cos();
          return eW(
            e.rgb.mul(i).add(
              r
                .cross(e.rgb)
                .mul(t.sin())
                .add(r.mul(r$(r, e.rgb).mul(i.oneMinus())))
            )
          );
        }),
        hI = (e, t = eW(u.ppV.getLuminanceCoefficients(new u.Pq0()))) =>
          r$(e, t),
        hP = eM(
          ([
            e,
            t = eW(1),
            r = eW(0),
            i = eW(1),
            s = eL(1),
            n = eW(u.ppV.getLuminanceCoefficients(new u.Pq0(), u.Zr2)),
          ]) => {
            let a = e.rgb.dot(eW(n)),
              o = rD(e.rgb.mul(t).add(r), 0).toVar(),
              l = o.pow(i).toVar();
            return (
              eU(o.r.greaterThan(0), () => {
                o.r.assign(l.r);
              }),
              eU(o.g.greaterThan(0), () => {
                o.g.assign(l.g);
              }),
              eU(o.b.greaterThan(0), () => {
                o.b.assign(l.b);
              }),
              o.assign(a.add(o.sub(a).mul(s))),
              eX(o.rgb, e.a)
            );
          }
        );
      class hL extends k {
        static get type() {
          return "PosterizeNode";
        }
        constructor(e, t) {
          super(), (this.sourceNode = e), (this.stepsNode = t);
        }
        setup() {
          let { sourceNode: e, stepsNode: t } = this;
          return e.mul(t).floor().div(t);
        }
      }
      let hD = eE(hL),
        hV = new u.I9Y();
      class hO extends i3 {
        static get type() {
          return "PassTextureNode";
        }
        constructor(e, t) {
          super(t), (this.passNode = e), this.setUpdateMatrix(!1);
        }
        setup(e) {
          return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
        }
        clone() {
          return new this.constructor(this.passNode, this.value);
        }
      }
      class hG extends hO {
        static get type() {
          return "PassMultipleTextureNode";
        }
        constructor(e, t, r = !1) {
          super(e, null), (this.textureName = t), (this.previousTexture = r);
        }
        updateTexture() {
          this.value = this.previousTexture
            ? this.passNode.getPreviousTexture(this.textureName)
            : this.passNode.getTexture(this.textureName);
        }
        setup(e) {
          return this.updateTexture(), super.setup(e);
        }
        clone() {
          return new this.constructor(
            this.passNode,
            this.textureName,
            this.previousTexture
          );
        }
      }
      class hk extends k {
        static get type() {
          return "PassNode";
        }
        constructor(e, t, r, i = {}) {
          super("vec4"),
            (this.scope = e),
            (this.scene = t),
            (this.camera = r),
            (this.options = i),
            (this._pixelRatio = 1),
            (this._width = 1),
            (this._height = 1);
          let s = new u.VCu();
          (s.isRenderTargetTexture = !0), (s.name = "depth");
          let n = new u.O0B(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio,
            { type: u.ix0, ...i }
          );
          (n.texture.name = "output"),
            (n.depthTexture = s),
            (this.renderTarget = n),
            (this._textures = { output: n.texture, depth: s }),
            (this._textureNodes = {}),
            (this._linearDepthNodes = {}),
            (this._viewZNodes = {}),
            (this._previousTextures = {}),
            (this._previousTextureNodes = {}),
            (this._cameraNear = tr(0)),
            (this._cameraFar = tr(0)),
            (this._mrt = null),
            (this._layers = null),
            (this._resolution = 1),
            (this.isPassNode = !0),
            (this.updateBeforeType = M.FRAME);
        }
        setResolution(e) {
          return (this._resolution = e), this;
        }
        getResolution() {
          return this._resolution;
        }
        setLayers(e) {
          return (this._layers = e), this;
        }
        getLayers() {
          return this._layers;
        }
        setMRT(e) {
          return (this._mrt = e), this;
        }
        getMRT() {
          return this._mrt;
        }
        isGlobal() {
          return !0;
        }
        getTexture(e) {
          let t = this._textures[e];
          return (
            void 0 === t &&
              (((t = this.renderTarget.texture.clone()).name = e),
              (this._textures[e] = t),
              this.renderTarget.textures.push(t)),
            t
          );
        }
        getPreviousTexture(e) {
          let t = this._previousTextures[e];
          return (
            void 0 === t &&
              ((t = this.getTexture(e).clone()),
              (this._previousTextures[e] = t)),
            t
          );
        }
        toggleTexture(e) {
          let t = this._previousTextures[e];
          if (void 0 !== t) {
            let r = this._textures[e],
              i = this.renderTarget.textures.indexOf(r);
            (this.renderTarget.textures[i] = t),
              (this._textures[e] = t),
              (this._previousTextures[e] = r),
              this._textureNodes[e].updateTexture(),
              this._previousTextureNodes[e].updateTexture();
          }
        }
        getTextureNode(e = "output") {
          let t = this._textureNodes[e];
          return (
            void 0 === t &&
              ((t = eR(new hG(this, e))).updateTexture(),
              (this._textureNodes[e] = t)),
            t
          );
        }
        getPreviousTextureNode(e = "output") {
          let t = this._previousTextureNodes[e];
          return (
            void 0 === t &&
              (void 0 === this._textureNodes[e] && this.getTextureNode(e),
              (t = eR(new hG(this, e, !0))).updateTexture(),
              (this._previousTextureNodes[e] = t)),
            t
          );
        }
        getViewZNode(e = "depth") {
          let t = this._viewZNodes[e];
          if (void 0 === t) {
            let r = this._cameraNear,
              i = this._cameraFar;
            this._viewZNodes[e] = t = aJ(this.getTextureNode(e), r, i);
          }
          return t;
        }
        getLinearDepthNode(e = "depth") {
          let t = this._linearDepthNodes[e];
          if (void 0 === t) {
            let r = this._cameraNear,
              i = this._cameraFar,
              s = this.getViewZNode(e);
            this._linearDepthNodes[e] = t = aY(s, r, i);
          }
          return t;
        }
        setup({ renderer: e }) {
          return (
            (this.renderTarget.samples =
              void 0 === this.options.samples
                ? e.samples
                : this.options.samples),
            !0 === e.backend.isWebGLBackend && (this.renderTarget.samples = 0),
            (this.renderTarget.texture.type = e.getColorBufferType()),
            this.scope === hk.COLOR
              ? this.getTextureNode()
              : this.getLinearDepthNode()
          );
        }
        updateBefore(e) {
          let t,
            r,
            { renderer: i } = e,
            { scene: s } = this,
            n = i.getOutputRenderTarget();
          n && !0 === n.isXRRenderTarget
            ? ((r = 1),
              (t = i.xr.getCamera()),
              i.xr.updateCamera(t),
              hV.set(n.width, n.height))
            : ((t = this.camera), (r = i.getPixelRatio()), i.getSize(hV)),
            (this._pixelRatio = r),
            this.setSize(hV.width, hV.height);
          let a = i.getRenderTarget(),
            o = i.getMRT(),
            l = t.layers.mask;
          for (let e in ((this._cameraNear.value = t.near),
          (this._cameraFar.value = t.far),
          null !== this._layers && (t.layers.mask = this._layers.mask),
          this._previousTextures))
            this.toggleTexture(e);
          i.setRenderTarget(this.renderTarget),
            i.setMRT(this._mrt),
            i.render(s, t),
            i.setRenderTarget(a),
            i.setMRT(o),
            (t.layers.mask = l);
        }
        setSize(e, t) {
          (this._width = e), (this._height = t);
          let r = this._width * this._pixelRatio * this._resolution,
            i = this._height * this._pixelRatio * this._resolution;
          this.renderTarget.setSize(r, i);
        }
        setPixelRatio(e) {
          (this._pixelRatio = e), this.setSize(this._width, this._height);
        }
        dispose() {
          this.renderTarget.dispose();
        }
      }
      (hk.COLOR = "color"), (hk.DEPTH = "depth");
      class hz extends hk {
        static get type() {
          return "ToonOutlinePassNode";
        }
        constructor(e, t, r, i, s) {
          super(hk.COLOR, e, t),
            (this.colorNode = r),
            (this.thicknessNode = i),
            (this.alphaNode = s),
            (this._materialCache = new WeakMap());
        }
        updateBefore(e) {
          let { renderer: t } = e,
            r = t.getRenderObjectFunction();
          t.setRenderObjectFunction((e, r, i, s, n, a, o, l) => {
            if (
              (n.isMeshToonMaterial || n.isMeshToonNodeMaterial) &&
              !1 === n.wireframe
            ) {
              let u = this._getOutlineMaterial(n);
              t.renderObject(e, r, i, s, u, a, o, l);
            }
            t.renderObject(e, r, i, s, n, a, o, l);
          }),
            super.updateBefore(e),
            t.setRenderObjectFunction(r);
        }
        _createMaterial() {
          let e = new os();
          (e.isMeshToonOutlineMaterial = !0),
            (e.name = "Toon_Outline"),
            (e.side = u.hsX);
          let t = sz.negate(),
            r = ss.mul(sC),
            i = eL(1),
            s = r.mul(eX(sF, 1)),
            n = r.mul(eX(sF.add(t), 1)),
            a = rg(s.sub(n));
          return (
            (e.vertexNode = s.add(a.mul(this.thicknessNode).mul(s.w).mul(i))),
            (e.colorNode = eX(this.colorNode, this.alphaNode)),
            e
          );
        }
        _getOutlineMaterial(e) {
          let t = this._materialCache.get(e);
          return (
            void 0 === t &&
              ((t = this._createMaterial()), this._materialCache.set(e, t)),
            t
          );
        }
      }
      let h$ = eM(([e, t]) => e.mul(t).clamp()).setLayout({
          name: "linearToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        }),
        hW = eM(([e, t]) => (e = e.mul(t)).div(e.add(1)).clamp()).setLayout({
          name: "reinhardToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        }),
        hH = eM(([e, t]) => {
          let r = (e = (e = e.mul(t)).sub(0.004).max(0)).mul(
              e.mul(6.2).add(0.5)
            ),
            i = e.mul(e.mul(6.2).add(1.7)).add(0.06);
          return r.div(i).pow(2.2);
        }).setLayout({
          name: "cineonToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        }),
        hq = eM(([e]) => {
          let t = e.mul(e.add(0.0245786)).sub(90537e-9),
            r = e.mul(e.add(0.432951).mul(0.983729)).add(0.238081);
          return t.div(r);
        }),
        hj = eM(([e, t]) => {
          let r = eJ(
              0.59719,
              0.35458,
              0.04823,
              0.076,
              0.90834,
              0.01566,
              0.0284,
              0.13383,
              0.83777
            ),
            i = eJ(
              1.60475,
              -0.53108,
              -0.07367,
              -0.10208,
              1.10813,
              -0.00605,
              -0.00327,
              -0.07276,
              1.07602
            );
          return (
            (e = e.mul(t).div(0.6)),
            (e = hq((e = r.mul(e)))),
            (e = i.mul(e)).clamp()
          );
        }).setLayout({
          name: "acesFilmicToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        }),
        hX = eJ(
          eW(1.6605, -0.1246, -0.0182),
          eW(-0.5876, 1.1329, -0.1006),
          eW(-0.0728, -0.0083, 1.1187)
        ),
        hQ = eJ(
          eW(0.6274, 0.0691, 0.0164),
          eW(0.3293, 0.9195, 0.088),
          eW(0.0433, 0.0113, 0.8956)
        ),
        hK = eM(([e]) => {
          let t = eW(e).toVar(),
            r = eW(t.mul(t)).toVar(),
            i = eW(r.mul(r)).toVar();
          return eL(15.5)
            .mul(i.mul(r))
            .sub(tk(40.14, i.mul(t)))
            .add(
              tk(31.96, i)
                .sub(tk(6.868, r.mul(t)))
                .add(tk(0.4298, r).add(tk(0.1191, t).sub(0.00232)))
            );
        }),
        hY = eM(([e, t]) => {
          let r = eW(e).toVar(),
            i = eJ(
              eW(0.856627153315983, 0.137318972929847, 0.11189821299995),
              eW(0.0951212405381588, 0.761241990602591, 0.0767994186031903),
              eW(0.0482516061458583, 0.101439036467562, 0.811302368396859)
            ),
            s = eJ(
              eW(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),
              eW(-0.11060664309660323, 1.157823702216272, -0.11060664309660294),
              eW(
                -0.016493938717834573,
                -0.016493938717834257,
                1.2519364065950405
              )
            ),
            n = eL(-12.47393),
            a = eL(4.026069);
          return (
            r.mulAssign(t),
            r.assign(hQ.mul(r)),
            r.assign(i.mul(r)),
            r.assign(rD(r, 1e-10)),
            r.assign(ru(r)),
            r.assign(r.sub(n).div(a.sub(n))),
            r.assign(rJ(r, 0, 1)),
            r.assign(hK(r)),
            r.assign(s.mul(r)),
            r.assign(rH(rD(eW(0), r), eW(2.2))),
            r.assign(hX.mul(r)),
            r.assign(rJ(r, 0, 1)),
            r
          );
        }).setLayout({
          name: "agxToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        }),
        hZ = eM(([e, t]) => {
          let r = eL(0.76),
            i = eL(0.15),
            s = rL((e = e.mul(t)).r, rL(e.g, e.b)),
            n = r7(s.lessThan(0.08), s.sub(tk(6.25, s.mul(s))), 0.04);
          e.subAssign(n);
          let a = rD(e.r, rD(e.g, e.b));
          eU(a.lessThan(r), () => e);
          let o = tG(1, r),
            l = tG(1, o.mul(o).div(a.add(o.sub(r))));
          e.mulAssign(l.div(a));
          let u = tG(1, tz(1, i.mul(a.sub(l)).add(1)));
          return rZ(e, eW(l), u);
        }).setLayout({
          name: "neutralToneMapping",
          type: "vec3",
          inputs: [
            { name: "color", type: "vec3" },
            { name: "exposure", type: "float" },
          ],
        });
      class hJ extends V {
        static get type() {
          return "CodeNode";
        }
        constructor(e = "", t = [], r = "") {
          super("code"),
            (this.isCodeNode = !0),
            (this.code = e),
            (this.includes = t),
            (this.language = r);
        }
        isGlobal() {
          return !0;
        }
        setIncludes(e) {
          return (this.includes = e), this;
        }
        getIncludes() {
          return this.includes;
        }
        generate(e) {
          for (let t of this.getIncludes(e)) t.build(e);
          let t = e.getCodeFromNode(this, this.getNodeType(e));
          return (t.code = this.code), t.code;
        }
        serialize(e) {
          super.serialize(e),
            (e.code = this.code),
            (e.language = this.language);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.code = e.code),
            (this.language = e.language);
        }
      }
      let h0 = eE(hJ);
      class h1 extends hJ {
        static get type() {
          return "FunctionNode";
        }
        constructor(e = "", t = [], r = "") {
          super(e, t, r);
        }
        getNodeType(e) {
          return this.getNodeFunction(e).type;
        }
        getInputs(e) {
          return this.getNodeFunction(e).inputs;
        }
        getNodeFunction(e) {
          let t = e.getDataFromNode(this),
            r = t.nodeFunction;
          return (
            void 0 === r &&
              (t.nodeFunction = r = e.parser.parseFunction(this.code)),
            r
          );
        }
        generate(e, t) {
          super.generate(e);
          let r = this.getNodeFunction(e),
            i = r.name,
            s = r.type,
            n = e.getCodeFromNode(this, s);
          "" !== i && (n.name = i);
          let a = e.getPropertyName(n);
          return ((n.code = this.getNodeFunction(e).getCode(a) + "\n"),
          "property" === t)
            ? a
            : e.format(`${a}()`, s, t);
        }
      }
      let h2 = (e, t = [], r = "") => {
        for (let e = 0; e < t.length; e++) {
          let r = t[e];
          "function" == typeof r && (t[e] = r.functionNode);
        }
        let i = eR(new h1(e, t, r)),
          s = (...e) => i.call(...e);
        return (s.functionNode = i), s;
      };
      class h3 extends V {
        static get type() {
          return "ScriptableValueNode";
        }
        constructor(e = null) {
          super(),
            (this._value = e),
            (this._cache = null),
            (this.inputType = null),
            (this.outputType = null),
            (this.events = new u.Qev()),
            (this.isScriptableValueNode = !0);
        }
        get isScriptableOutputNode() {
          return null !== this.outputType;
        }
        set value(e) {
          this._value !== e &&
            (this._cache &&
              "URL" === this.inputType &&
              this.value.value instanceof ArrayBuffer &&
              (URL.revokeObjectURL(this._cache), (this._cache = null)),
            (this._value = e),
            this.events.dispatchEvent({ type: "change" }),
            this.refresh());
        }
        get value() {
          return this._value;
        }
        refresh() {
          this.events.dispatchEvent({ type: "refresh" });
        }
        getValue() {
          let e = this.value;
          if (
            e &&
            null === this._cache &&
            "URL" === this.inputType &&
            e.value instanceof ArrayBuffer
          )
            this._cache = URL.createObjectURL(new Blob([e.value]));
          else if (
            e &&
            null !== e.value &&
            void 0 !== e.value &&
            ((("URL" === this.inputType || "String" === this.inputType) &&
              "string" == typeof e.value) ||
              ("Number" === this.inputType && "number" == typeof e.value) ||
              ("Vector2" === this.inputType && e.value.isVector2) ||
              ("Vector3" === this.inputType && e.value.isVector3) ||
              ("Vector4" === this.inputType && e.value.isVector4) ||
              ("Color" === this.inputType && e.value.isColor) ||
              ("Matrix3" === this.inputType && e.value.isMatrix3) ||
              ("Matrix4" === this.inputType && e.value.isMatrix4))
          )
            return e.value;
          return this._cache || e;
        }
        getNodeType(e) {
          return this.value && this.value.isNode
            ? this.value.getNodeType(e)
            : "float";
        }
        setup() {
          return this.value && this.value.isNode ? this.value : eL();
        }
        serialize(e) {
          super.serialize(e),
            null !== this.value
              ? "ArrayBuffer" === this.inputType
                ? (e.value = A(this.value))
                : (e.value = this.value ? this.value.toJSON(e.meta).uuid : null)
              : (e.value = null),
            (e.inputType = this.inputType),
            (e.outputType = this.outputType);
        }
        deserialize(e) {
          super.deserialize(e);
          let t = null;
          null !== e.value &&
            (t =
              "ArrayBuffer" === e.inputType
                ? C(e.value)
                : "Texture" === e.inputType
                ? e.meta.textures[e.value]
                : e.meta.nodes[e.value] || null),
            (this.value = t),
            (this.inputType = e.inputType),
            (this.outputType = e.outputType);
        }
      }
      let h4 = eE(h3);
      class h6 extends Map {
        get(e, t = null, ...r) {
          if (this.has(e)) return super.get(e);
          if (null !== t) {
            let i = t(...r);
            return this.set(e, i), i;
          }
        }
      }
      class h5 {
        constructor(e) {
          this.scriptableNode = e;
        }
        get parameters() {
          return this.scriptableNode.parameters;
        }
        get layout() {
          return this.scriptableNode.getLayout();
        }
        getInputLayout(e) {
          return this.scriptableNode.getInputLayout(e);
        }
        get(e) {
          let t = this.parameters[e];
          return t ? t.getValue() : null;
        }
      }
      let h8 = new h6();
      class h9 extends V {
        static get type() {
          return "ScriptableNode";
        }
        constructor(e = null, t = {}) {
          super(),
            (this.codeNode = e),
            (this.parameters = t),
            (this._local = new h6()),
            (this._output = h4()),
            (this._outputs = {}),
            (this._source = this.source),
            (this._method = null),
            (this._object = null),
            (this._value = null),
            (this._needsOutputUpdate = !0),
            (this.onRefresh = this.onRefresh.bind(this)),
            (this.isScriptableNode = !0);
        }
        get source() {
          return this.codeNode ? this.codeNode.code : "";
        }
        setLocal(e, t) {
          return this._local.set(e, t);
        }
        getLocal(e) {
          return this._local.get(e);
        }
        onRefresh() {
          this._refresh();
        }
        getInputLayout(e) {
          for (let t of this.getLayout())
            if (t.inputType && (t.id === e || t.name === e)) return t;
        }
        getOutputLayout(e) {
          for (let t of this.getLayout())
            if (t.outputType && (t.id === e || t.name === e)) return t;
        }
        setOutput(e, t) {
          let r = this._outputs;
          return void 0 === r[e] ? (r[e] = h4(t)) : (r[e].value = t), this;
        }
        getOutput(e) {
          return this._outputs[e];
        }
        getParameter(e) {
          return this.parameters[e];
        }
        setParameter(e, t) {
          let r = this.parameters;
          return (
            t && t.isScriptableNode
              ? (this.deleteParameter(e),
                (r[e] = t),
                r[e]
                  .getDefaultOutput()
                  .events.addEventListener("refresh", this.onRefresh))
              : t && t.isScriptableValueNode
              ? (this.deleteParameter(e),
                (r[e] = t),
                r[e].events.addEventListener("refresh", this.onRefresh))
              : void 0 === r[e]
              ? ((r[e] = h4(t)),
                r[e].events.addEventListener("refresh", this.onRefresh))
              : (r[e].value = t),
            this
          );
        }
        getValue() {
          return this.getDefaultOutput().getValue();
        }
        deleteParameter(e) {
          let t = this.parameters[e];
          return (
            t &&
              (t.isScriptableNode && (t = t.getDefaultOutput()),
              t.events.removeEventListener("refresh", this.onRefresh)),
            this
          );
        }
        clearParameters() {
          for (let e of Object.keys(this.parameters)) this.deleteParameter(e);
          return (this.needsUpdate = !0), this;
        }
        call(e, ...t) {
          let r = this.getObject()[e];
          if ("function" == typeof r) return r(...t);
        }
        async callAsync(e, ...t) {
          let r = this.getObject()[e];
          if ("function" == typeof r)
            return "AsyncFunction" === r.constructor.name
              ? await r(...t)
              : r(...t);
        }
        getNodeType(e) {
          return this.getDefaultOutputNode().getNodeType(e);
        }
        refresh(e = null) {
          null !== e ? this.getOutput(e).refresh() : this._refresh();
        }
        getObject() {
          if ((this.needsUpdate && this.dispose(), null !== this._object))
            return this._object;
          let e = new h5(this),
            t = h8.get("THREE"),
            r = h8.get("TSL"),
            i = this.getMethod(),
            s = [
              e,
              this._local,
              h8,
              () => this.refresh(),
              (e, t) => this.setOutput(e, t),
              t,
              r,
            ];
          this._object = i(...s);
          let n = this._object.layout;
          if (
            n &&
            (!1 === n.cache && this._local.clear(),
            (this._output.outputType = n.outputType || null),
            Array.isArray(n.elements))
          )
            for (let e of n.elements) {
              let t = e.id || e.name;
              e.inputType &&
                (void 0 === this.getParameter(t) && this.setParameter(t, null),
                (this.getParameter(t).inputType = e.inputType)),
                e.outputType &&
                  (void 0 === this.getOutput(t) && this.setOutput(t, null),
                  (this.getOutput(t).outputType = e.outputType));
            }
          return this._object;
        }
        deserialize(e) {
          for (let t in (super.deserialize(e), this.parameters)) {
            let e = this.parameters[t];
            e.isScriptableNode && (e = e.getDefaultOutput()),
              e.events.addEventListener("refresh", this.onRefresh);
          }
        }
        getLayout() {
          return this.getObject().layout;
        }
        getDefaultOutputNode() {
          let e = this.getDefaultOutput().value;
          return e && e.isNode ? e : eL();
        }
        getDefaultOutput() {
          return this._exec()._output;
        }
        getMethod() {
          if ((this.needsUpdate && this.dispose(), null !== this._method))
            return this._method;
          let e = "layout, init, main, dispose",
            t =
              "var " +
              e +
              "; var output = {};\n" +
              this.codeNode.code +
              "\nreturn { ...output, " +
              e +
              " };";
          return (
            (this._method = Function(
              "parameters",
              "local",
              "global",
              "refresh",
              "setOutput",
              "THREE",
              "TSL",
              t
            )),
            this._method
          );
        }
        dispose() {
          null !== this._method &&
            (this._object &&
              "function" == typeof this._object.dispose &&
              this._object.dispose(),
            (this._method = null),
            (this._object = null),
            (this._source = null),
            (this._value = null),
            (this._needsOutputUpdate = !0),
            (this._output.value = null),
            (this._outputs = {}));
        }
        setup() {
          return this.getDefaultOutputNode();
        }
        getCacheKey(e) {
          let t = [p(this.source), this.getDefaultOutputNode().getCacheKey(e)];
          for (let r in this.parameters)
            t.push(this.parameters[r].getCacheKey(e));
          return g(t);
        }
        set needsUpdate(e) {
          !0 === e && this.dispose();
        }
        get needsUpdate() {
          return this.source !== this._source;
        }
        _exec() {
          return (
            null === this.codeNode ||
              (!0 === this._needsOutputUpdate &&
                ((this._value = this.call("main")),
                (this._needsOutputUpdate = !1)),
              (this._output.value = this._value)),
            this
          );
        }
        _refresh() {
          (this.needsUpdate = !0), this._exec(), this._output.refresh();
        }
      }
      let h7 = eE(h9);
      function ce(e) {
        let t,
          r = e.context.getViewZ;
        return void 0 !== r && (t = r(this)), (t || sL.z).negate();
      }
      let ct = eM(([e, t], r) => r2(e, t, ce(r))),
        cr = eM(([e], t) => {
          let r = ce(t);
          return e.mul(e, r, r).negate().exp().oneMinus();
        }),
        ci = eM(([e, t]) => eX(t.toFloat().mix(tS.rgb, e.toVec3()), tS.a)),
        cs = null,
        cn = null;
      class ca extends V {
        static get type() {
          return "RangeNode";
        }
        constructor(e = eL(), t = eL()) {
          super(), (this.minNode = e), (this.maxNode = t);
        }
        getVectorLength(e) {
          let t = e.getTypeLength(N(this.minNode.value)),
            r = e.getTypeLength(N(this.maxNode.value));
          return t > r ? t : r;
        }
        getNodeType(e) {
          return e.object.count > 1
            ? e.getTypeFromLength(this.getVectorLength(e))
            : "float";
        }
        setup(e) {
          let t = e.object,
            r = null;
          if (t.count > 1) {
            let i = this.minNode.value,
              s = this.maxNode.value,
              n = e.getTypeLength(N(i)),
              a = e.getTypeLength(N(s));
            (cs = cs || new u.IUQ()),
              (cn = cn || new u.IUQ()),
              cs.setScalar(0),
              cn.setScalar(0),
              1 === n
                ? cs.setScalar(i)
                : i.isColor
                ? cs.set(i.r, i.g, i.b, 1)
                : cs.set(i.x, i.y, i.z || 0, i.w || 0),
              1 === a
                ? cn.setScalar(s)
                : s.isColor
                ? cn.set(s.r, s.g, s.b, 1)
                : cn.set(s.x, s.y, s.z || 0, s.w || 0);
            let o = 4 * t.count,
              l = new Float32Array(o);
            for (let e = 0; e < o; e++) {
              let t = e % 4,
                r = cs.getComponent(t),
                i = cn.getComponent(t);
              l[e] = u.cj9.lerp(r, i, Math.random());
            }
            let d = this.getNodeType(e);
            if (t.count <= 4096)
              r = i8(l, "vec4", t.count).element(an).convert(d);
            else {
              let t = new u.uWO(l, 4);
              e.geometry.setAttribute("__range" + this.id, t),
                (r = iI(t).convert(d));
            }
          } else r = eL(0);
          return r;
        }
      }
      let co = eE(ca);
      class cl extends V {
        static get type() {
          return "ComputeBuiltinNode";
        }
        constructor(e, t) {
          super(t), (this._builtinName = e);
        }
        getHash(e) {
          return this.getBuiltinName(e);
        }
        getNodeType() {
          return this.nodeType;
        }
        setBuiltinName(e) {
          return (this._builtinName = e), this;
        }
        getBuiltinName() {
          return this._builtinName;
        }
        hasBuiltin(e) {
          return e.hasBuiltin(this._builtinName);
        }
        generate(e, t) {
          let r = this.getBuiltinName(e),
            i = this.getNodeType(e);
          return "compute" === e.shaderStage
            ? e.format(r, i, t)
            : (console.warn(
                `ComputeBuiltinNode: Compute built-in value ${r} can not be accessed in the ${e.shaderStage} stage`
              ),
              e.generateConst(i));
        }
        serialize(e) {
          super.serialize(e),
            (e.global = this.global),
            (e._builtinName = this._builtinName);
        }
        deserialize(e) {
          super.deserialize(e),
            (this.global = e.global),
            (this._builtinName = e._builtinName);
        }
      }
      let cu = (e, t) => eR(new cl(e, t)),
        cd = cu("numWorkgroups", "uvec3"),
        ch = cu("workgroupId", "uvec3"),
        cc = cu("globalId", "uvec3"),
        cp = cu("localId", "uvec3"),
        cg = cu("subgroupSize", "uint");
      class cm extends V {
        constructor(e) {
          super(), (this.scope = e);
        }
        generate(e) {
          let { scope: t } = this,
            { renderer: r } = e;
          !0 === r.backend.isWebGLBackend
            ? e.addFlowCode(`	// ${t}Barrier 
`)
            : e.addLineFlowCode(`${t}Barrier()`, this);
        }
      }
      let cf = eE(cm);
      class cy extends O {
        constructor(e, t) {
          super(e, t), (this.isWorkgroupInfoElementNode = !0);
        }
        generate(e, t) {
          let r,
            i = e.context.assign;
          if (((r = super.generate(e)), !0 !== i)) {
            let i = this.getNodeType(e);
            r = e.format(r, i, t);
          }
          return r;
        }
      }
      class cx extends V {
        constructor(e, t, r = 0) {
          super(t),
            (this.bufferType = t),
            (this.bufferCount = r),
            (this.isWorkgroupInfoNode = !0),
            (this.elementType = t),
            (this.scope = e);
        }
        label(e) {
          return (this.name = e), this;
        }
        setScope(e) {
          return (this.scope = e), this;
        }
        getElementType() {
          return this.elementType;
        }
        getInputType() {
          return `${this.scope}Array`;
        }
        element(e) {
          return eR(new cy(this, e));
        }
        generate(e) {
          return e.getScopedArray(
            this.name || `${this.scope}Array_${this.id}`,
            this.scope.toLowerCase(),
            this.bufferType,
            this.bufferCount
          );
        }
      }
      class cb extends k {
        static get type() {
          return "AtomicFunctionNode";
        }
        constructor(e, t, r, i = null) {
          super("uint"),
            (this.method = e),
            (this.pointerNode = t),
            (this.valueNode = r),
            (this.storeNode = i);
        }
        getInputType(e) {
          return this.pointerNode.getNodeType(e);
        }
        getNodeType(e) {
          return this.getInputType(e);
        }
        generate(e) {
          let t = this.method,
            r = this.getNodeType(e),
            i = this.getInputType(e),
            s = this.pointerNode,
            n = this.valueNode,
            a = [];
          a.push(`&${s.build(e, i)}`), null !== n && a.push(n.build(e, i));
          let o = `${e.getMethod(t, r)}( ${a.join(", ")} )`;
          if (null !== this.storeNode) {
            let t = this.storeNode.build(e, i);
            e.addLineFlowCode(`${t} = ${o}`, this);
          } else e.addLineFlowCode(o, this);
        }
      }
      (cb.ATOMIC_LOAD = "atomicLoad"),
        (cb.ATOMIC_STORE = "atomicStore"),
        (cb.ATOMIC_ADD = "atomicAdd"),
        (cb.ATOMIC_SUB = "atomicSub"),
        (cb.ATOMIC_MAX = "atomicMax"),
        (cb.ATOMIC_MIN = "atomicMin"),
        (cb.ATOMIC_AND = "atomicAnd"),
        (cb.ATOMIC_OR = "atomicOr"),
        (cb.ATOMIC_XOR = "atomicXor");
      let cT = eE(cb),
        c_ = (e, t, r, i = null) => {
          let s = cT(e, t, r, i);
          return s.append(), s;
        };
      function cv(e) {
        let t = (n = n || new WeakMap()).get(e);
        return void 0 === t && n.set(e, (t = {})), t;
      }
      function cN(e) {
        let t = cv(e);
        return (
          t.shadowMatrix ||
          (t.shadowMatrix = tr("mat4")
            .setGroup(e7)
            .onRenderUpdate(
              () => (
                !0 !== e.castShadow && e.shadow.updateMatrices(e),
                e.shadow.matrix
              )
            ))
        );
      }
      function cS(e, t = sI) {
        let r = cN(e).mul(t);
        return r.xyz.div(r.w);
      }
      function cR(e) {
        let t = cv(e);
        return (
          t.position ||
          (t.position = tr(new u.Pq0())
            .setGroup(e7)
            .onRenderUpdate((t, r) =>
              r.value.setFromMatrixPosition(e.matrixWorld)
            ))
        );
      }
      function cA(e) {
        let t = cv(e);
        return (
          t.targetPosition ||
          (t.targetPosition = tr(new u.Pq0())
            .setGroup(e7)
            .onRenderUpdate((t, r) =>
              r.value.setFromMatrixPosition(e.target.matrixWorld)
            ))
        );
      }
      function cC(e) {
        let t = cv(e);
        return (
          t.viewPosition ||
          (t.viewPosition = tr(new u.Pq0())
            .setGroup(e7)
            .onRenderUpdate(({ camera: t }, r) => {
              (r.value = r.value || new u.Pq0()),
                r.value.setFromMatrixPosition(e.matrixWorld),
                r.value.applyMatrix4(t.matrixWorldInverse);
            }))
        );
      }
      let cE = (e) => sa.transformDirection(cR(e).sub(cA(e))),
        cw = (e) => e.sort((e, t) => e.id - t.id),
        cM = (e, t) => {
          for (let r of t)
            if (r.isAnalyticLightNode && r.light.id === e) return r;
          return null;
        },
        cB = new WeakMap();
      class cF extends V {
        static get type() {
          return "LightsNode";
        }
        constructor() {
          super("vec3"),
            (this.totalDiffuseNode = eW().toVar("totalDiffuse")),
            (this.totalSpecularNode = eW().toVar("totalSpecular")),
            (this.outgoingLightNode = eW().toVar("outgoingLight")),
            (this._lights = []),
            (this._lightNodes = null),
            (this._lightNodesHash = null),
            (this.global = !0);
        }
        customCacheKey() {
          let e = [],
            t = this._lights;
          for (let r = 0; r < t.length; r++) e.push(t[r].id);
          return g(e);
        }
        getHash(e) {
          if (null === this._lightNodesHash) {
            null === this._lightNodes && this.setupLightsNode(e);
            let t = [];
            for (let e of this._lightNodes) t.push(e.getSelf().getHash());
            this._lightNodesHash = "lights-" + t.join(",");
          }
          return this._lightNodesHash;
        }
        analyze(e) {
          for (let t of e.getDataFromNode(this).nodes) t.build(e);
        }
        setupLightsNode(e) {
          let t = [],
            r = this._lightNodes,
            i = cw(this._lights),
            s = e.renderer.library;
          for (let e of i)
            if (e.isNode) t.push(eR(e));
            else {
              let i = null;
              if ((null !== r && (i = cM(e.id, r)), null === i)) {
                let r = s.getLightNodeClass(e.constructor);
                if (null === r) {
                  console.warn(
                    `LightsNode.setupNodeLights: Light node not found for ${e.constructor.name}`
                  );
                  continue;
                }
                let i = null;
                cB.has(e)
                  ? (i = cB.get(e))
                  : ((i = eR(new r(e))), cB.set(e, i)),
                  t.push(i);
              }
            }
          this._lightNodes = t;
        }
        setupDirectLight(e, t, r) {
          let { lightingModel: i, reflectedLight: s } = e.context;
          i.direct({ ...r, lightNode: t, reflectedLight: s }, e);
        }
        setupDirectRectAreaLight(e, t, r) {
          let { lightingModel: i, reflectedLight: s } = e.context;
          i.directRectArea({ ...r, lightNode: t, reflectedLight: s }, e);
        }
        setupLights(e, t) {
          for (let r of t) r.build(e);
        }
        getLightNodes(e) {
          return (
            null === this._lightNodes && this.setupLightsNode(e),
            this._lightNodes
          );
        }
        setup(e) {
          let t = e.lightsNode;
          e.lightsNode = this;
          let r = this.outgoingLightNode,
            i = e.context,
            s = i.lightingModel,
            n = e.getDataFromNode(this);
          if (s) {
            let { totalDiffuseNode: t, totalSpecularNode: a } = this;
            (i.outgoingLight = r), (n.nodes = e.addStack().nodes), s.start(e);
            let { backdrop: o, backdropAlpha: l } = i,
              {
                directDiffuse: u,
                directSpecular: d,
                indirectDiffuse: h,
                indirectSpecular: c,
              } = i.reflectedLight,
              p = u.add(h);
            null !== o &&
              ((p = null !== l ? eW(l.mix(p, o)) : eW(o)),
              (i.material.transparent = !0)),
              t.assign(p),
              a.assign(d.add(c)),
              r.assign(t.add(a)),
              s.finish(e),
              (r = r.bypass(e.removeStack()));
          } else n.nodes = [];
          return (e.lightsNode = t), r;
        }
        setLights(e) {
          return (
            (this._lights = e),
            (this._lightNodes = null),
            (this._lightNodesHash = null),
            this
          );
        }
        getLights() {
          return this._lights;
        }
        get hasLights() {
          return this._lights.length > 0;
        }
      }
      class cU extends V {
        static get type() {
          return "ShadowBaseNode";
        }
        constructor(e) {
          super(),
            (this.light = e),
            (this.updateBeforeType = M.RENDER),
            (this.isShadowBaseNode = !0);
        }
        setupShadowPosition({ context: e, material: t }) {
          cI.assign(t.shadowPositionNode || e.shadowPositionWorld || sI);
        }
        dispose() {
          this.updateBeforeType = M.NONE;
        }
      }
      let cI = ts("vec3", "shadowPositionWorld");
      function cP(e, t = {}) {
        return (
          (t.toneMapping = e.toneMapping),
          (t.toneMappingExposure = e.toneMappingExposure),
          (t.outputColorSpace = e.outputColorSpace),
          (t.renderTarget = e.getRenderTarget()),
          (t.activeCubeFace = e.getActiveCubeFace()),
          (t.activeMipmapLevel = e.getActiveMipmapLevel()),
          (t.renderObjectFunction = e.getRenderObjectFunction()),
          (t.pixelRatio = e.getPixelRatio()),
          (t.mrt = e.getMRT()),
          (t.clearColor = e.getClearColor(t.clearColor || new u.Q1f())),
          (t.clearAlpha = e.getClearAlpha()),
          (t.autoClear = e.autoClear),
          (t.scissorTest = e.getScissorTest()),
          t
        );
      }
      function cL(e, t) {
        return (
          (t = cP(e, t)),
          e.setMRT(null),
          e.setRenderObjectFunction(null),
          e.setClearColor(0, 1),
          (e.autoClear = !0),
          t
        );
      }
      function cD(e, t) {
        (e.toneMapping = t.toneMapping),
          (e.toneMappingExposure = t.toneMappingExposure),
          (e.outputColorSpace = t.outputColorSpace),
          e.setRenderTarget(
            t.renderTarget,
            t.activeCubeFace,
            t.activeMipmapLevel
          ),
          e.setRenderObjectFunction(t.renderObjectFunction),
          e.setPixelRatio(t.pixelRatio),
          e.setMRT(t.mrt),
          e.setClearColor(t.clearColor, t.clearAlpha),
          (e.autoClear = t.autoClear),
          e.setScissorTest(t.scissorTest);
      }
      function cV(e, t = {}) {
        return (
          (t.background = e.background),
          (t.backgroundNode = e.backgroundNode),
          (t.overrideMaterial = e.overrideMaterial),
          t
        );
      }
      function cO(e, t) {
        return (
          (t = cV(e, t)),
          (e.background = null),
          (e.backgroundNode = null),
          (e.overrideMaterial = null),
          t
        );
      }
      function cG(e, t) {
        (e.background = t.background),
          (e.backgroundNode = t.backgroundNode),
          (e.overrideMaterial = t.overrideMaterial);
      }
      function ck(e, t, r) {
        return (r = cO(t, (r = cL(e, r))));
      }
      function cz(e, t, r) {
        cD(e, r), cG(t, r);
      }
      var c$ = Object.freeze({
        __proto__: null,
        resetRendererAndSceneState: ck,
        resetRendererState: cL,
        resetSceneState: cO,
        restoreRendererAndSceneState: cz,
        restoreRendererState: cD,
        restoreSceneState: cG,
        saveRendererAndSceneState: function (e, t, r = {}) {
          return (r = cV(t, (r = cP(e, r))));
        },
        saveRendererState: cP,
        saveSceneState: cV,
      });
      let cW = new WeakMap(),
        cH = eM(([e, t, r]) => {
          let i = sI.sub(e).length();
          return (i = i.sub(t).div(r.sub(t))).saturate();
        }),
        cq = (e) => {
          let t = e.shadow.camera,
            r = ne("near", "float", t).setGroup(e7),
            i = ne("far", "float", t).setGroup(e7);
          return cH(sg(e), r, i);
        },
        cj = (e) => {
          let t = cW.get(e);
          if (void 0 === t) {
            let r = e.isPointLight ? cq(e) : null;
            ((t = new os()).colorNode = eX(0, 0, 0, 1)),
              (t.depthNode = r),
              (t.isShadowPassMaterial = !0),
              (t.name = "ShadowMaterial"),
              (t.fog = !1),
              cW.set(e, t);
          }
          return t;
        },
        cX = eM(({ depthTexture: e, shadowCoord: t }) =>
          i4(e, t.xy).compare(t.z)
        ),
        cQ = eM(({ depthTexture: e, shadowCoord: t, shadow: r }) => {
          let i = (t, r) => i4(e, t).compare(r),
            s = ne("mapSize", "vec2", r).setGroup(e7),
            n = ne("radius", "float", r).setGroup(e7),
            a = eG(1).div(s),
            o = a.x.negate().mul(n),
            l = a.y.negate().mul(n),
            u = a.x.mul(n),
            d = a.y.mul(n),
            h = o.div(2),
            c = l.div(2),
            p = u.div(2),
            g = d.div(2);
          return tO(
            i(t.xy.add(eG(o, l)), t.z),
            i(t.xy.add(eG(0, l)), t.z),
            i(t.xy.add(eG(u, l)), t.z),
            i(t.xy.add(eG(h, c)), t.z),
            i(t.xy.add(eG(0, c)), t.z),
            i(t.xy.add(eG(p, c)), t.z),
            i(t.xy.add(eG(o, 0)), t.z),
            i(t.xy.add(eG(h, 0)), t.z),
            i(t.xy, t.z),
            i(t.xy.add(eG(p, 0)), t.z),
            i(t.xy.add(eG(u, 0)), t.z),
            i(t.xy.add(eG(h, g)), t.z),
            i(t.xy.add(eG(0, g)), t.z),
            i(t.xy.add(eG(p, g)), t.z),
            i(t.xy.add(eG(o, d)), t.z),
            i(t.xy.add(eG(0, d)), t.z),
            i(t.xy.add(eG(u, d)), t.z)
          ).mul(1 / 17);
        }),
        cK = eM(({ depthTexture: e, shadowCoord: t, shadow: r }) => {
          let i = (t, r) => i4(e, t).compare(r),
            s = ne("mapSize", "vec2", r).setGroup(e7),
            n = eG(1).div(s),
            a = n.x,
            o = n.y,
            l = t.xy,
            u = rm(l.mul(s).add(0.5));
          return (
            l.subAssign(u.mul(n)),
            tO(
              i(l, t.z),
              i(l.add(eG(a, 0)), t.z),
              i(l.add(eG(0, o)), t.z),
              i(l.add(n), t.z),
              rZ(
                i(l.add(eG(a.negate(), 0)), t.z),
                i(l.add(eG(a.mul(2), 0)), t.z),
                u.x
              ),
              rZ(
                i(l.add(eG(a.negate(), o)), t.z),
                i(l.add(eG(a.mul(2), o)), t.z),
                u.x
              ),
              rZ(
                i(l.add(eG(0, o.negate())), t.z),
                i(l.add(eG(0, o.mul(2))), t.z),
                u.y
              ),
              rZ(
                i(l.add(eG(a, o.negate())), t.z),
                i(l.add(eG(a, o.mul(2))), t.z),
                u.y
              ),
              rZ(
                rZ(
                  i(l.add(eG(a.negate(), o.negate())), t.z),
                  i(l.add(eG(a.mul(2), o.negate())), t.z),
                  u.x
                ),
                rZ(
                  i(l.add(eG(a.negate(), o.mul(2))), t.z),
                  i(l.add(eG(a.mul(2), o.mul(2))), t.z),
                  u.x
                ),
                u.y
              )
            ).mul(1 / 9)
          );
        }),
        cY = eM(({ depthTexture: e, shadowCoord: t }) => {
          let r = eL(1).toVar(),
            i = i4(e).sample(t.xy).rg,
            s = rO(t.z, i.x);
          return (
            eU(s.notEqual(eL(1)), () => {
              let e = t.z.sub(i.x),
                n = rD(0, i.y.mul(i.y)),
                a = n.div(n.add(e.mul(e)));
              (a = rJ(tG(a, 0.3).div(0.95 - 0.3))), r.assign(rJ(rD(s, a)));
            }),
            r
          );
        }),
        cZ = eM(({ samples: e, radius: t, size: r, shadowPass: i }) => {
          let s = eL(0).toVar(),
            n = eL(0).toVar(),
            a = e.lessThanEqual(eL(1)).select(eL(0), eL(2).div(e.sub(1))),
            o = e.lessThanEqual(eL(1)).select(eL(0), eL(-1));
          aT(
            { start: eD(0), end: eD(e), type: "int", condition: "<" },
            ({ i: e }) => {
              let l = o.add(eL(e).mul(a)),
                u = i.sample(tO(aP.xy, eG(0, l).mul(t)).div(r)).x;
              s.addAssign(u), n.addAssign(u.mul(u));
            }
          ),
            s.divAssign(e),
            n.divAssign(e);
          let l = rd(n.sub(s.mul(s)));
          return eG(s, l);
        }),
        cJ = eM(({ samples: e, radius: t, size: r, shadowPass: i }) => {
          let s = eL(0).toVar(),
            n = eL(0).toVar(),
            a = e.lessThanEqual(eL(1)).select(eL(0), eL(2).div(e.sub(1))),
            o = e.lessThanEqual(eL(1)).select(eL(0), eL(-1));
          aT(
            { start: eD(0), end: eD(e), type: "int", condition: "<" },
            ({ i: e }) => {
              let l = o.add(eL(e).mul(a)),
                u = i.sample(tO(aP.xy, eG(l, 0).mul(t)).div(r));
              s.addAssign(u.x), n.addAssign(tO(u.y.mul(u.y), u.x.mul(u.x)));
            }
          ),
            s.divAssign(e),
            n.divAssign(e);
          let l = rd(n.sub(s.mul(s)));
          return eG(s, l);
        }),
        c0 = [cX, cQ, cK, cY],
        c1 = new d2();
      class c2 extends cU {
        static get type() {
          return "ShadowNode";
        }
        constructor(e, t = null) {
          super(e),
            (this.shadow = t || e.shadow),
            (this.shadowMap = null),
            (this.vsmShadowMapVertical = null),
            (this.vsmShadowMapHorizontal = null),
            (this.vsmMaterialVertical = null),
            (this.vsmMaterialHorizontal = null),
            (this._node = null),
            (this._cameraFrameId = new WeakMap()),
            (this.isShadowNode = !0);
        }
        setupShadowFilter(
          e,
          { filterFn: t, depthTexture: r, shadowCoord: i, shadow: s }
        ) {
          let n = i.x
              .greaterThanEqual(0)
              .and(i.x.lessThanEqual(1))
              .and(i.y.greaterThanEqual(0))
              .and(i.y.lessThanEqual(1))
              .and(i.z.lessThanEqual(1)),
            a = t({ depthTexture: r, shadowCoord: i, shadow: s });
          return n.select(a, eL(1));
        }
        setupShadowCoord(e, t) {
          let r,
            { shadow: i } = this,
            { renderer: s } = e,
            n = ne("bias", "float", i).setGroup(e7),
            a = t;
          if (i.camera.isOrthographicCamera || !0 !== s.logarithmicDepthBuffer)
            (r = (a = a.xyz.div(a.w)).z),
              s.coordinateSystem === u.i7u && (r = r.mul(2).sub(1));
          else {
            let e = a.w;
            a = a.xy.div(e);
            let t = ne("near", "float", i.camera).setGroup(e7),
              s = ne("far", "float", i.camera).setGroup(e7);
            r = a0(e.negate(), t, s);
          }
          return eW(a.x, a.y.oneMinus(), r.add(n));
        }
        getShadowFilterFn(e) {
          return c0[e];
        }
        setupShadow(e) {
          let { renderer: t } = e,
            { light: r, shadow: i } = this,
            s = t.shadowMap.type,
            n = new u.VCu(i.mapSize.width, i.mapSize.height);
          n.compareFunction = u.vim;
          let a = e.createRenderTarget(i.mapSize.width, i.mapSize.height);
          if (
            ((a.depthTexture = n),
            i.camera.updateProjectionMatrix(),
            s === u.RyA)
          ) {
            (n.compareFunction = null),
              (this.vsmShadowMapVertical = e.createRenderTarget(
                i.mapSize.width,
                i.mapSize.height,
                { format: u.paN, type: u.ix0 }
              )),
              (this.vsmShadowMapHorizontal = e.createRenderTarget(
                i.mapSize.width,
                i.mapSize.height,
                { format: u.paN, type: u.ix0 }
              ));
            let t = i4(n),
              r = i4(this.vsmShadowMapVertical.texture),
              s = ne("blurSamples", "float", i).setGroup(e7),
              a = ne("radius", "float", i).setGroup(e7),
              o = ne("mapSize", "vec2", i).setGroup(e7),
              l =
                this.vsmMaterialVertical ||
                (this.vsmMaterialVertical = new os());
            (l.fragmentNode = cZ({
              samples: s,
              radius: a,
              size: o,
              shadowPass: t,
            }).context(e.getSharedContext())),
              (l.name = "VSMVertical"),
              ((l =
                this.vsmMaterialHorizontal ||
                (this.vsmMaterialHorizontal = new os())).fragmentNode = cJ({
                samples: s,
                radius: a,
                size: o,
                shadowPass: r,
              }).context(e.getSharedContext())),
              (l.name = "VSMHorizontal");
          }
          let o = ne("intensity", "float", i).setGroup(e7),
            l = ne("normalBias", "float", i).setGroup(e7),
            d = cN(r).mul(cI.add(sj.mul(l))),
            h = this.setupShadowCoord(e, d),
            c =
              i.filterNode || this.getShadowFilterFn(t.shadowMap.type) || null;
          if (null === c)
            throw Error(
              "THREE.WebGPURenderer: Shadow map type not supported yet."
            );
          let p = s === u.RyA ? this.vsmShadowMapHorizontal.texture : n,
            g = this.setupShadowFilter(e, {
              filterFn: c,
              shadowTexture: a.texture,
              depthTexture: p,
              shadowCoord: h,
              shadow: i,
            }),
            m = i4(a.texture, h),
            f = rZ(1, g.rgb.mix(m, 1), o.mul(m.a)).toVar();
          return (this.shadowMap = a), (this.shadow.map = a), f;
        }
        setup(e) {
          if (!1 !== e.renderer.shadowMap.enabled)
            return eM(() => {
              let t = this._node;
              return (
                this.setupShadowPosition(e),
                null === t && (this._node = t = this.setupShadow(e)),
                e.material.shadowNode &&
                  console.warn(
                    'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'
                  ),
                e.material.receivedShadowNode &&
                  (t = e.material.receivedShadowNode(t)),
                t
              );
            })();
        }
        renderShadow(e) {
          let { shadow: t, shadowMap: r, light: i } = this,
            { renderer: s, scene: n } = e;
          t.updateMatrices(i),
            r.setSize(t.mapSize.width, t.mapSize.height),
            s.render(n, t.camera);
        }
        updateShadow(e) {
          let { shadowMap: t, light: r, shadow: i } = this,
            { renderer: s, scene: n, camera: o } = e,
            l = s.shadowMap.type,
            d = t.depthTexture.version;
          (this._depthVersionCached = d),
            (i.camera.layers.mask = o.layers.mask);
          let h = s.getRenderObjectFunction(),
            c = s.getMRT(),
            p = !!c && c.has("velocity");
          (a = ck(s, n, a)),
            (n.overrideMaterial = cj(r)),
            s.setRenderObjectFunction((e, t, r, n, a, d, ...h) => {
              (!0 === e.castShadow || (e.receiveShadow && l === u.RyA)) &&
                (p && (R(e).useVelocity = !0),
                e.onBeforeShadow(s, e, o, i.camera, n, t.overrideMaterial, d),
                s.renderObject(e, t, r, n, a, d, ...h),
                e.onAfterShadow(s, e, o, i.camera, n, t.overrideMaterial, d));
            }),
            s.setRenderTarget(t),
            this.renderShadow(e),
            s.setRenderObjectFunction(h),
            !0 !== r.isPointLight && l === u.RyA && this.vsmPass(s),
            cz(s, n, a);
        }
        vsmPass(e) {
          let { shadow: t } = this;
          this.vsmShadowMapVertical.setSize(t.mapSize.width, t.mapSize.height),
            this.vsmShadowMapHorizontal.setSize(
              t.mapSize.width,
              t.mapSize.height
            ),
            e.setRenderTarget(this.vsmShadowMapVertical),
            (c1.material = this.vsmMaterialVertical),
            c1.render(e),
            e.setRenderTarget(this.vsmShadowMapHorizontal),
            (c1.material = this.vsmMaterialHorizontal),
            c1.render(e);
        }
        dispose() {
          this.shadowMap.dispose(),
            (this.shadowMap = null),
            null !== this.vsmShadowMapVertical &&
              (this.vsmShadowMapVertical.dispose(),
              (this.vsmShadowMapVertical = null),
              this.vsmMaterialVertical.dispose(),
              (this.vsmMaterialVertical = null)),
            null !== this.vsmShadowMapHorizontal &&
              (this.vsmShadowMapHorizontal.dispose(),
              (this.vsmShadowMapHorizontal = null),
              this.vsmMaterialHorizontal.dispose(),
              (this.vsmMaterialHorizontal = null)),
            super.dispose();
        }
        updateBefore(e) {
          let { shadow: t } = this,
            r = t.needsUpdate || t.autoUpdate;
          r &&
            (this._cameraFrameId[e.camera] === e.frameId && (r = !1),
            (this._cameraFrameId[e.camera] = e.frameId)),
            r &&
              (this.updateShadow(e),
              this.shadowMap.depthTexture.version ===
                this._depthVersionCached && (t.needsUpdate = !1));
        }
      }
      let c3 = (e, t) => eR(new c2(e, t)),
        c4 = new u.Q1f(),
        c6 = eM(([e, t]) => {
          let r = e.toVar(),
            i = rv(r),
            s = tz(1, rD(i.x, rD(i.y, i.z)));
          i.mulAssign(s), r.mulAssign(s.mul(t.mul(2).oneMinus()));
          let n = eG(r.xy).toVar(),
            a = t.mul(1.5).oneMinus();
          return (
            eU(i.z.greaterThanEqual(a), () => {
              eU(r.z.greaterThan(0), () => {
                n.x.assign(tG(4, r.x));
              });
            })
              .ElseIf(i.x.greaterThanEqual(a), () => {
                let e = rN(r.x);
                n.x.assign(r.z.mul(e).add(e.mul(2)));
              })
              .ElseIf(i.y.greaterThanEqual(a), () => {
                let e = rN(r.y);
                n.x.assign(r.x.add(e.mul(2)).add(2)),
                  n.y.assign(r.z.mul(e).sub(2));
              }),
            eG(0.125, 0.25).mul(n).add(eG(0.375, 0.75)).flipY()
          );
        }).setLayout({
          name: "cubeToUV",
          type: "vec2",
          inputs: [
            { name: "pos", type: "vec3" },
            { name: "texelSizeY", type: "float" },
          ],
        }),
        c5 = eM(({ depthTexture: e, bd3D: t, dp: r, texelSize: i }) =>
          i4(e, c6(t, i.y)).compare(r)
        ),
        c8 = eM(
          ({ depthTexture: e, bd3D: t, dp: r, texelSize: i, shadow: s }) => {
            let n = ne("radius", "float", s).setGroup(e7),
              a = eG(-1, 1).mul(n).mul(i.y);
            return i4(e, c6(t.add(a.xyy), i.y))
              .compare(r)
              .add(i4(e, c6(t.add(a.yyy), i.y)).compare(r))
              .add(i4(e, c6(t.add(a.xyx), i.y)).compare(r))
              .add(i4(e, c6(t.add(a.yyx), i.y)).compare(r))
              .add(i4(e, c6(t, i.y)).compare(r))
              .add(i4(e, c6(t.add(a.xxy), i.y)).compare(r))
              .add(i4(e, c6(t.add(a.yxy), i.y)).compare(r))
              .add(i4(e, c6(t.add(a.xxx), i.y)).compare(r))
              .add(i4(e, c6(t.add(a.yxx), i.y)).compare(r))
              .mul(1 / 9);
          }
        ),
        c9 = eM(
          ({ filterFn: e, depthTexture: t, shadowCoord: r, shadow: i }) => {
            let s = r.xyz.toVar(),
              n = s.length(),
              a = tr("float")
                .setGroup(e7)
                .onRenderUpdate(() => i.camera.near),
              o = tr("float")
                .setGroup(e7)
                .onRenderUpdate(() => i.camera.far),
              l = ne("bias", "float", i).setGroup(e7),
              u = tr(i.mapSize).setGroup(e7),
              d = eL(1).toVar();
            return (
              eU(
                n.sub(o).lessThanEqual(0).and(n.sub(a).greaterThanEqual(0)),
                () => {
                  let r = n.sub(a).div(o.sub(a)).toVar();
                  r.addAssign(l);
                  let h = s.normalize(),
                    c = eG(1).div(u.mul(eG(4, 2)));
                  d.assign(
                    e({
                      depthTexture: t,
                      bd3D: h,
                      dp: r,
                      texelSize: c,
                      shadow: i,
                    })
                  );
                }
              ),
              d
            );
          }
        ),
        c7 = new u.IUQ(),
        pe = new u.I9Y(),
        pt = new u.I9Y();
      class pr extends c2 {
        static get type() {
          return "PointShadowNode";
        }
        constructor(e, t = null) {
          super(e, t);
        }
        getShadowFilterFn(e) {
          return e === u.bTm ? c5 : c8;
        }
        setupShadowCoord(e, t) {
          return t;
        }
        setupShadowFilter(
          e,
          {
            filterFn: t,
            shadowTexture: r,
            depthTexture: i,
            shadowCoord: s,
            shadow: n,
          }
        ) {
          return c9({
            filterFn: t,
            shadowTexture: r,
            depthTexture: i,
            shadowCoord: s,
            shadow: n,
          });
        }
        renderShadow(e) {
          let { shadow: t, shadowMap: r, light: i } = this,
            { renderer: s, scene: n } = e,
            a = t.getFrameExtents();
          pt.copy(t.mapSize),
            pt.multiply(a),
            r.setSize(pt.width, pt.height),
            pe.copy(t.mapSize);
          let o = s.autoClear,
            l = s.getClearColor(c4),
            u = s.getClearAlpha();
          (s.autoClear = !1),
            s.setClearColor(t.clearColor, t.clearAlpha),
            s.clear();
          let d = t.getViewportCount();
          for (let e = 0; e < d; e++) {
            let a = t.getViewport(e),
              o = pe.x * a.x,
              l = pt.y - pe.y - pe.y * a.y;
            c7.set(o, l, pe.x * a.z, pe.y * a.w),
              r.viewport.copy(c7),
              t.updateMatrices(i, e),
              s.render(n, t.camera);
          }
          (s.autoClear = o), s.setClearColor(l, u);
        }
      }
      let pi = (e, t) => eR(new pr(e, t));
      class ps extends aC {
        static get type() {
          return "AnalyticLightNode";
        }
        constructor(e = null) {
          super(),
            (this.light = e),
            (this.color = new u.Q1f()),
            (this.colorNode =
              (e && e.colorNode) || tr(this.color).setGroup(e7)),
            (this.baseColorNode = null),
            (this.shadowNode = null),
            (this.shadowColorNode = null),
            (this.isAnalyticLightNode = !0),
            (this.updateType = M.FRAME);
        }
        customCacheKey() {
          return m(this.light.id, +!!this.light.castShadow);
        }
        getHash() {
          return this.light.uuid;
        }
        getLightVector(e) {
          return cC(this.light).sub(e.context.positionView || sL);
        }
        setupDirect() {}
        setupDirectRectArea() {}
        setupShadowNode() {
          return c3(this.light);
        }
        setupShadow(e) {
          let { renderer: t } = e;
          if (!1 === t.shadowMap.enabled) return;
          let r = this.shadowColorNode;
          if (null === r) {
            let t,
              i = this.light.shadow.shadowNode;
            (t = void 0 !== i ? eR(i) : this.setupShadowNode(e)),
              (this.shadowNode = t),
              (this.shadowColorNode = r = this.colorNode.mul(t)),
              (this.baseColorNode = this.colorNode);
          }
          this.colorNode = r;
        }
        setup(e) {
          (this.colorNode = this.baseColorNode || this.colorNode),
            this.light.castShadow
              ? e.object.receiveShadow && this.setupShadow(e)
              : null !== this.shadowNode &&
                (this.shadowNode.dispose(),
                (this.shadowNode = null),
                (this.shadowColorNode = null));
          let t = this.setupDirect(e),
            r = this.setupDirectRectArea(e);
          t && e.lightsNode.setupDirectLight(e, this, t),
            r && e.lightsNode.setupDirectRectAreaLight(e, this, r);
        }
        update() {
          let { light: e } = this;
          this.color.copy(e.color).multiplyScalar(e.intensity);
        }
      }
      let pn = eM(
          ({ lightDistance: e, cutoffDistance: t, decayExponent: r }) => {
            let i = e.pow(r).max(0.01).reciprocal();
            return t
              .greaterThan(0)
              .select(i.mul(e.div(t).pow4().oneMinus().clamp().pow2()), i);
          }
        ),
        pa = ({
          color: e,
          lightVector: t,
          cutoffDistance: r,
          decayExponent: i,
        }) => {
          let s = t.normalize(),
            n = pn({
              lightDistance: t.length(),
              cutoffDistance: r,
              decayExponent: i,
            });
          return { lightDirection: s, lightColor: e.mul(n) };
        };
      class po extends ps {
        static get type() {
          return "PointLightNode";
        }
        constructor(e = null) {
          super(e),
            (this.cutoffDistanceNode = tr(0).setGroup(e7)),
            (this.decayExponentNode = tr(2).setGroup(e7));
        }
        update(e) {
          let { light: t } = this;
          super.update(e),
            (this.cutoffDistanceNode.value = t.distance),
            (this.decayExponentNode.value = t.decay);
        }
        setupShadowNode() {
          return pi(this.light);
        }
        setupDirect(e) {
          return pa({
            color: this.colorNode,
            lightVector: this.getLightVector(e),
            cutoffDistance: this.cutoffDistanceNode,
            decayExponent: this.decayExponentNode,
          });
        }
      }
      let pl = eM(([e = iZ()]) => {
          let t = e.mul(2),
            r = t.x.floor(),
            i = t.y.floor();
          return r.add(i).mod(2).sign();
        }),
        pu = eM(([e = iZ()], { renderer: t, material: r }) => {
          let i = eL(1).toVar(),
            s = rY(e.mul(2).sub(1));
          if (r.alphaToCoverage && t.samples > 1) {
            let e = eL(s.fwidth()).toVar();
            i.assign(r2(e.oneMinus(), e.add(1), s).oneMinus());
          } else s.greaterThan(1).discard();
          return i;
        }),
        pd = eM(([e, t, r]) => {
          let i = eL(r).toVar(),
            s = eL(t).toVar();
          return r7(eO(e).toVar(), s, i);
        }).setLayout({
          name: "mx_select",
          type: "float",
          inputs: [
            { name: "b", type: "bool" },
            { name: "t", type: "float" },
            { name: "f", type: "float" },
          ],
        }),
        ph = eM(([e, t]) => {
          let r = eO(t).toVar(),
            i = eL(e).toVar();
          return r7(r, i.negate(), i);
        }).setLayout({
          name: "mx_negate_if",
          type: "float",
          inputs: [
            { name: "val", type: "float" },
            { name: "b", type: "bool" },
          ],
        }),
        pc = eM(([e]) => eD(rc(eL(e).toVar()))).setLayout({
          name: "mx_floor",
          type: "int",
          inputs: [{ name: "x", type: "float" }],
        }),
        pp = eM(([e, t]) => {
          let r = eL(e).toVar();
          return t.assign(pc(r)), r.sub(eL(t));
        }),
        pg = dR([
          eM(([e, t, r, i, s, n]) => {
            let a = eL(n).toVar(),
              o = eL(s).toVar(),
              l = eL(i).toVar(),
              u = eL(r).toVar(),
              d = eL(t).toVar(),
              h = eL(e).toVar(),
              c = eL(tG(1, o)).toVar();
            return tG(1, a)
              .mul(h.mul(c).add(d.mul(o)))
              .add(a.mul(u.mul(c).add(l.mul(o))));
          }).setLayout({
            name: "mx_bilerp_0",
            type: "float",
            inputs: [
              { name: "v0", type: "float" },
              { name: "v1", type: "float" },
              { name: "v2", type: "float" },
              { name: "v3", type: "float" },
              { name: "s", type: "float" },
              { name: "t", type: "float" },
            ],
          }),
          eM(([e, t, r, i, s, n]) => {
            let a = eL(n).toVar(),
              o = eL(s).toVar(),
              l = eW(i).toVar(),
              u = eW(r).toVar(),
              d = eW(t).toVar(),
              h = eW(e).toVar(),
              c = eL(tG(1, o)).toVar();
            return tG(1, a)
              .mul(h.mul(c).add(d.mul(o)))
              .add(a.mul(u.mul(c).add(l.mul(o))));
          }).setLayout({
            name: "mx_bilerp_1",
            type: "vec3",
            inputs: [
              { name: "v0", type: "vec3" },
              { name: "v1", type: "vec3" },
              { name: "v2", type: "vec3" },
              { name: "v3", type: "vec3" },
              { name: "s", type: "float" },
              { name: "t", type: "float" },
            ],
          }),
        ]),
        pm = dR([
          eM(([e, t, r, i, s, n, a, o, l, u, d]) => {
            let h = eL(d).toVar(),
              c = eL(u).toVar(),
              p = eL(l).toVar(),
              g = eL(o).toVar(),
              m = eL(a).toVar(),
              f = eL(n).toVar(),
              y = eL(s).toVar(),
              x = eL(i).toVar(),
              b = eL(r).toVar(),
              T = eL(t).toVar(),
              _ = eL(e).toVar(),
              v = eL(tG(1, p)).toVar(),
              N = eL(tG(1, c)).toVar();
            return eL(tG(1, h))
              .toVar()
              .mul(
                N.mul(_.mul(v).add(T.mul(p))).add(c.mul(b.mul(v).add(x.mul(p))))
              )
              .add(
                h.mul(
                  N.mul(y.mul(v).add(f.mul(p))).add(
                    c.mul(m.mul(v).add(g.mul(p)))
                  )
                )
              );
          }).setLayout({
            name: "mx_trilerp_0",
            type: "float",
            inputs: [
              { name: "v0", type: "float" },
              { name: "v1", type: "float" },
              { name: "v2", type: "float" },
              { name: "v3", type: "float" },
              { name: "v4", type: "float" },
              { name: "v5", type: "float" },
              { name: "v6", type: "float" },
              { name: "v7", type: "float" },
              { name: "s", type: "float" },
              { name: "t", type: "float" },
              { name: "r", type: "float" },
            ],
          }),
          eM(([e, t, r, i, s, n, a, o, l, u, d]) => {
            let h = eL(d).toVar(),
              c = eL(u).toVar(),
              p = eL(l).toVar(),
              g = eW(o).toVar(),
              m = eW(a).toVar(),
              f = eW(n).toVar(),
              y = eW(s).toVar(),
              x = eW(i).toVar(),
              b = eW(r).toVar(),
              T = eW(t).toVar(),
              _ = eW(e).toVar(),
              v = eL(tG(1, p)).toVar(),
              N = eL(tG(1, c)).toVar();
            return eL(tG(1, h))
              .toVar()
              .mul(
                N.mul(_.mul(v).add(T.mul(p))).add(c.mul(b.mul(v).add(x.mul(p))))
              )
              .add(
                h.mul(
                  N.mul(y.mul(v).add(f.mul(p))).add(
                    c.mul(m.mul(v).add(g.mul(p)))
                  )
                )
              );
          }).setLayout({
            name: "mx_trilerp_1",
            type: "vec3",
            inputs: [
              { name: "v0", type: "vec3" },
              { name: "v1", type: "vec3" },
              { name: "v2", type: "vec3" },
              { name: "v3", type: "vec3" },
              { name: "v4", type: "vec3" },
              { name: "v5", type: "vec3" },
              { name: "v6", type: "vec3" },
              { name: "v7", type: "vec3" },
              { name: "s", type: "float" },
              { name: "t", type: "float" },
              { name: "r", type: "float" },
            ],
          }),
        ]),
        pf = dR([
          eM(([e, t, r]) => {
            let i = eL(r).toVar(),
              s = eL(t).toVar(),
              n = eV(e).toVar(),
              a = eV(n.bitAnd(eV(7))).toVar(),
              o = eL(pd(a.lessThan(eV(4)), s, i)).toVar(),
              l = eL(tk(2, pd(a.lessThan(eV(4)), i, s))).toVar();
            return ph(o, eO(a.bitAnd(eV(1)))).add(ph(l, eO(a.bitAnd(eV(2)))));
          }).setLayout({
            name: "mx_gradient_float_0",
            type: "float",
            inputs: [
              { name: "hash", type: "uint" },
              { name: "x", type: "float" },
              { name: "y", type: "float" },
            ],
          }),
          eM(([e, t, r, i]) => {
            let s = eL(i).toVar(),
              n = eL(r).toVar(),
              a = eL(t).toVar(),
              o = eV(e).toVar(),
              l = eV(o.bitAnd(eV(15))).toVar(),
              u = eL(pd(l.lessThan(eV(8)), a, n)).toVar(),
              d = eL(
                pd(
                  l.lessThan(eV(4)),
                  n,
                  pd(l.equal(eV(12)).or(l.equal(eV(14))), a, s)
                )
              ).toVar();
            return ph(u, eO(l.bitAnd(eV(1)))).add(ph(d, eO(l.bitAnd(eV(2)))));
          }).setLayout({
            name: "mx_gradient_float_1",
            type: "float",
            inputs: [
              { name: "hash", type: "uint" },
              { name: "x", type: "float" },
              { name: "y", type: "float" },
              { name: "z", type: "float" },
            ],
          }),
        ]),
        py = dR([
          eM(([e, t, r]) => {
            let i = eL(r).toVar(),
              s = eL(t).toVar(),
              n = eq(e).toVar();
            return eW(pf(n.x, s, i), pf(n.y, s, i), pf(n.z, s, i));
          }).setLayout({
            name: "mx_gradient_vec3_0",
            type: "vec3",
            inputs: [
              { name: "hash", type: "uvec3" },
              { name: "x", type: "float" },
              { name: "y", type: "float" },
            ],
          }),
          eM(([e, t, r, i]) => {
            let s = eL(i).toVar(),
              n = eL(r).toVar(),
              a = eL(t).toVar(),
              o = eq(e).toVar();
            return eW(pf(o.x, a, n, s), pf(o.y, a, n, s), pf(o.z, a, n, s));
          }).setLayout({
            name: "mx_gradient_vec3_1",
            type: "vec3",
            inputs: [
              { name: "hash", type: "uvec3" },
              { name: "x", type: "float" },
              { name: "y", type: "float" },
              { name: "z", type: "float" },
            ],
          }),
        ]),
        px = eM(([e]) => tk(0.6616, eL(e).toVar())).setLayout({
          name: "mx_gradient_scale2d_0",
          type: "float",
          inputs: [{ name: "v", type: "float" }],
        }),
        pb = eM(([e]) => tk(0.982, eL(e).toVar())).setLayout({
          name: "mx_gradient_scale3d_0",
          type: "float",
          inputs: [{ name: "v", type: "float" }],
        }),
        pT = dR([
          px,
          eM(([e]) => tk(0.6616, eW(e).toVar())).setLayout({
            name: "mx_gradient_scale2d_1",
            type: "vec3",
            inputs: [{ name: "v", type: "vec3" }],
          }),
        ]),
        p_ = dR([
          pb,
          eM(([e]) => tk(0.982, eW(e).toVar())).setLayout({
            name: "mx_gradient_scale3d_1",
            type: "vec3",
            inputs: [{ name: "v", type: "vec3" }],
          }),
        ]),
        pv = eM(([e, t]) => {
          let r = eD(t).toVar(),
            i = eV(e).toVar();
          return i.shiftLeft(r).bitOr(i.shiftRight(eD(32).sub(r)));
        }).setLayout({
          name: "mx_rotl32",
          type: "uint",
          inputs: [
            { name: "x", type: "uint" },
            { name: "k", type: "int" },
          ],
        }),
        pN = eM(([e, t, r]) => {
          e.subAssign(r),
            e.bitXorAssign(pv(r, eD(4))),
            r.addAssign(t),
            t.subAssign(e),
            t.bitXorAssign(pv(e, eD(6))),
            e.addAssign(r),
            r.subAssign(t),
            r.bitXorAssign(pv(t, eD(8))),
            t.addAssign(e),
            e.subAssign(r),
            e.bitXorAssign(pv(r, eD(16))),
            r.addAssign(t),
            t.subAssign(e),
            t.bitXorAssign(pv(e, eD(19))),
            e.addAssign(r),
            r.subAssign(t),
            r.bitXorAssign(pv(t, eD(4))),
            t.addAssign(e);
        }),
        pS = eM(([e, t, r]) => {
          let i = eV(r).toVar(),
            s = eV(t).toVar(),
            n = eV(e).toVar();
          return (
            i.bitXorAssign(s),
            i.subAssign(pv(s, eD(14))),
            n.bitXorAssign(i),
            n.subAssign(pv(i, eD(11))),
            s.bitXorAssign(n),
            s.subAssign(pv(n, eD(25))),
            i.bitXorAssign(s),
            i.subAssign(pv(s, eD(16))),
            n.bitXorAssign(i),
            n.subAssign(pv(i, eD(4))),
            s.bitXorAssign(n),
            s.subAssign(pv(n, eD(14))),
            i.bitXorAssign(s),
            i.subAssign(pv(s, eD(24))),
            i
          );
        }).setLayout({
          name: "mx_bjfinal",
          type: "uint",
          inputs: [
            { name: "a", type: "uint" },
            { name: "b", type: "uint" },
            { name: "c", type: "uint" },
          ],
        }),
        pR = eM(([e]) =>
          eL(eV(e).toVar()).div(eL(eV(eD(0xffffffff))))
        ).setLayout({
          name: "mx_bits_to_01",
          type: "float",
          inputs: [{ name: "bits", type: "uint" }],
        }),
        pA = eM(([e]) => {
          let t = eL(e).toVar();
          return t
            .mul(t)
            .mul(t)
            .mul(t.mul(t.mul(6).sub(15)).add(10));
        }).setLayout({
          name: "mx_fade",
          type: "float",
          inputs: [{ name: "t", type: "float" }],
        }),
        pC = eM(([e]) => {
          let t = eD(e).toVar(),
            r = eV(eV(1)).toVar(),
            i = eV(
              eV(eD(0xdeadbeef))
                .add(r.shiftLeft(eV(2)))
                .add(eV(13))
            ).toVar();
          return pS(i.add(eV(t)), i, i);
        }).setLayout({
          name: "mx_hash_int_0",
          type: "uint",
          inputs: [{ name: "x", type: "int" }],
        }),
        pE = eM(([e, t]) => {
          let r = eD(t).toVar(),
            i = eD(e).toVar(),
            s = eV(eV(2)).toVar(),
            n = eV().toVar(),
            a = eV().toVar(),
            o = eV().toVar();
          return (
            n.assign(
              a.assign(
                o.assign(
                  eV(eD(0xdeadbeef))
                    .add(s.shiftLeft(eV(2)))
                    .add(eV(13))
                )
              )
            ),
            n.addAssign(eV(i)),
            a.addAssign(eV(r)),
            pS(n, a, o)
          );
        }).setLayout({
          name: "mx_hash_int_1",
          type: "uint",
          inputs: [
            { name: "x", type: "int" },
            { name: "y", type: "int" },
          ],
        }),
        pw = eM(([e, t, r]) => {
          let i = eD(r).toVar(),
            s = eD(t).toVar(),
            n = eD(e).toVar(),
            a = eV(eV(3)).toVar(),
            o = eV().toVar(),
            l = eV().toVar(),
            u = eV().toVar();
          return (
            o.assign(
              l.assign(
                u.assign(
                  eV(eD(0xdeadbeef))
                    .add(a.shiftLeft(eV(2)))
                    .add(eV(13))
                )
              )
            ),
            o.addAssign(eV(n)),
            l.addAssign(eV(s)),
            u.addAssign(eV(i)),
            pS(o, l, u)
          );
        }).setLayout({
          name: "mx_hash_int_2",
          type: "uint",
          inputs: [
            { name: "x", type: "int" },
            { name: "y", type: "int" },
            { name: "z", type: "int" },
          ],
        }),
        pM = dR([
          pC,
          pE,
          pw,
          eM(([e, t, r, i]) => {
            let s = eD(i).toVar(),
              n = eD(r).toVar(),
              a = eD(t).toVar(),
              o = eD(e).toVar(),
              l = eV(eV(4)).toVar(),
              u = eV().toVar(),
              d = eV().toVar(),
              h = eV().toVar();
            return (
              u.assign(
                d.assign(
                  h.assign(
                    eV(eD(0xdeadbeef))
                      .add(l.shiftLeft(eV(2)))
                      .add(eV(13))
                  )
                )
              ),
              u.addAssign(eV(o)),
              d.addAssign(eV(a)),
              h.addAssign(eV(n)),
              pN(u, d, h),
              u.addAssign(eV(s)),
              pS(u, d, h)
            );
          }).setLayout({
            name: "mx_hash_int_3",
            type: "uint",
            inputs: [
              { name: "x", type: "int" },
              { name: "y", type: "int" },
              { name: "z", type: "int" },
              { name: "xx", type: "int" },
            ],
          }),
          eM(([e, t, r, i, s]) => {
            let n = eD(s).toVar(),
              a = eD(i).toVar(),
              o = eD(r).toVar(),
              l = eD(t).toVar(),
              u = eD(e).toVar(),
              d = eV(eV(5)).toVar(),
              h = eV().toVar(),
              c = eV().toVar(),
              p = eV().toVar();
            return (
              h.assign(
                c.assign(
                  p.assign(
                    eV(eD(0xdeadbeef))
                      .add(d.shiftLeft(eV(2)))
                      .add(eV(13))
                  )
                )
              ),
              h.addAssign(eV(u)),
              c.addAssign(eV(l)),
              p.addAssign(eV(o)),
              pN(h, c, p),
              h.addAssign(eV(a)),
              c.addAssign(eV(n)),
              pS(h, c, p)
            );
          }).setLayout({
            name: "mx_hash_int_4",
            type: "uint",
            inputs: [
              { name: "x", type: "int" },
              { name: "y", type: "int" },
              { name: "z", type: "int" },
              { name: "xx", type: "int" },
              { name: "yy", type: "int" },
            ],
          }),
        ]),
        pB = dR([
          eM(([e, t]) => {
            let r = eD(t).toVar(),
              i = eV(pM(eD(e).toVar(), r)).toVar(),
              s = eq().toVar();
            return (
              s.x.assign(i.bitAnd(eD(255))),
              s.y.assign(i.shiftRight(eD(8)).bitAnd(eD(255))),
              s.z.assign(i.shiftRight(eD(16)).bitAnd(eD(255))),
              s
            );
          }).setLayout({
            name: "mx_hash_vec3_0",
            type: "uvec3",
            inputs: [
              { name: "x", type: "int" },
              { name: "y", type: "int" },
            ],
          }),
          eM(([e, t, r]) => {
            let i = eD(r).toVar(),
              s = eD(t).toVar(),
              n = eV(pM(eD(e).toVar(), s, i)).toVar(),
              a = eq().toVar();
            return (
              a.x.assign(n.bitAnd(eD(255))),
              a.y.assign(n.shiftRight(eD(8)).bitAnd(eD(255))),
              a.z.assign(n.shiftRight(eD(16)).bitAnd(eD(255))),
              a
            );
          }).setLayout({
            name: "mx_hash_vec3_1",
            type: "uvec3",
            inputs: [
              { name: "x", type: "int" },
              { name: "y", type: "int" },
              { name: "z", type: "int" },
            ],
          }),
        ]),
        pF = dR([
          eM(([e]) => {
            let t = eG(e).toVar(),
              r = eD().toVar(),
              i = eD().toVar(),
              s = eL(pp(t.x, r)).toVar(),
              n = eL(pp(t.y, i)).toVar(),
              a = eL(pA(s)).toVar(),
              o = eL(pA(n)).toVar();
            return pT(
              eL(
                pg(
                  pf(pM(r, i), s, n),
                  pf(pM(r.add(eD(1)), i), s.sub(1), n),
                  pf(pM(r, i.add(eD(1))), s, n.sub(1)),
                  pf(pM(r.add(eD(1)), i.add(eD(1))), s.sub(1), n.sub(1)),
                  a,
                  o
                )
              ).toVar()
            );
          }).setLayout({
            name: "mx_perlin_noise_float_0",
            type: "float",
            inputs: [{ name: "p", type: "vec2" }],
          }),
          eM(([e]) => {
            let t = eW(e).toVar(),
              r = eD().toVar(),
              i = eD().toVar(),
              s = eD().toVar(),
              n = eL(pp(t.x, r)).toVar(),
              a = eL(pp(t.y, i)).toVar(),
              o = eL(pp(t.z, s)).toVar(),
              l = eL(pA(n)).toVar(),
              u = eL(pA(a)).toVar(),
              d = eL(pA(o)).toVar();
            return p_(
              eL(
                pm(
                  pf(pM(r, i, s), n, a, o),
                  pf(pM(r.add(eD(1)), i, s), n.sub(1), a, o),
                  pf(pM(r, i.add(eD(1)), s), n, a.sub(1), o),
                  pf(pM(r.add(eD(1)), i.add(eD(1)), s), n.sub(1), a.sub(1), o),
                  pf(pM(r, i, s.add(eD(1))), n, a, o.sub(1)),
                  pf(pM(r.add(eD(1)), i, s.add(eD(1))), n.sub(1), a, o.sub(1)),
                  pf(pM(r, i.add(eD(1)), s.add(eD(1))), n, a.sub(1), o.sub(1)),
                  pf(
                    pM(r.add(eD(1)), i.add(eD(1)), s.add(eD(1))),
                    n.sub(1),
                    a.sub(1),
                    o.sub(1)
                  ),
                  l,
                  u,
                  d
                )
              ).toVar()
            );
          }).setLayout({
            name: "mx_perlin_noise_float_1",
            type: "float",
            inputs: [{ name: "p", type: "vec3" }],
          }),
        ]),
        pU = dR([
          eM(([e]) => {
            let t = eG(e).toVar(),
              r = eD().toVar(),
              i = eD().toVar(),
              s = eL(pp(t.x, r)).toVar(),
              n = eL(pp(t.y, i)).toVar(),
              a = eL(pA(s)).toVar(),
              o = eL(pA(n)).toVar();
            return pT(
              eW(
                pg(
                  py(pB(r, i), s, n),
                  py(pB(r.add(eD(1)), i), s.sub(1), n),
                  py(pB(r, i.add(eD(1))), s, n.sub(1)),
                  py(pB(r.add(eD(1)), i.add(eD(1))), s.sub(1), n.sub(1)),
                  a,
                  o
                )
              ).toVar()
            );
          }).setLayout({
            name: "mx_perlin_noise_vec3_0",
            type: "vec3",
            inputs: [{ name: "p", type: "vec2" }],
          }),
          eM(([e]) => {
            let t = eW(e).toVar(),
              r = eD().toVar(),
              i = eD().toVar(),
              s = eD().toVar(),
              n = eL(pp(t.x, r)).toVar(),
              a = eL(pp(t.y, i)).toVar(),
              o = eL(pp(t.z, s)).toVar(),
              l = eL(pA(n)).toVar(),
              u = eL(pA(a)).toVar(),
              d = eL(pA(o)).toVar();
            return p_(
              eW(
                pm(
                  py(pB(r, i, s), n, a, o),
                  py(pB(r.add(eD(1)), i, s), n.sub(1), a, o),
                  py(pB(r, i.add(eD(1)), s), n, a.sub(1), o),
                  py(pB(r.add(eD(1)), i.add(eD(1)), s), n.sub(1), a.sub(1), o),
                  py(pB(r, i, s.add(eD(1))), n, a, o.sub(1)),
                  py(pB(r.add(eD(1)), i, s.add(eD(1))), n.sub(1), a, o.sub(1)),
                  py(pB(r, i.add(eD(1)), s.add(eD(1))), n, a.sub(1), o.sub(1)),
                  py(
                    pB(r.add(eD(1)), i.add(eD(1)), s.add(eD(1))),
                    n.sub(1),
                    a.sub(1),
                    o.sub(1)
                  ),
                  l,
                  u,
                  d
                )
              ).toVar()
            );
          }).setLayout({
            name: "mx_perlin_noise_vec3_1",
            type: "vec3",
            inputs: [{ name: "p", type: "vec3" }],
          }),
        ]),
        pI = eM(([e]) => pR(pM(eD(pc(eL(e).toVar())).toVar()))).setLayout({
          name: "mx_cell_noise_float_0",
          type: "float",
          inputs: [{ name: "p", type: "float" }],
        }),
        pP = eM(([e]) => {
          let t = eG(e).toVar();
          return pR(pM(eD(pc(t.x)).toVar(), eD(pc(t.y)).toVar()));
        }).setLayout({
          name: "mx_cell_noise_float_1",
          type: "float",
          inputs: [{ name: "p", type: "vec2" }],
        }),
        pL = dR([
          pI,
          pP,
          eM(([e]) => {
            let t = eW(e).toVar(),
              r = eD(pc(t.x)).toVar();
            return pR(pM(r, eD(pc(t.y)).toVar(), eD(pc(t.z)).toVar()));
          }).setLayout({
            name: "mx_cell_noise_float_2",
            type: "float",
            inputs: [{ name: "p", type: "vec3" }],
          }),
          eM(([e]) => {
            let t = eX(e).toVar(),
              r = eD(pc(t.x)).toVar(),
              i = eD(pc(t.y)).toVar();
            return pR(pM(r, i, eD(pc(t.z)).toVar(), eD(pc(t.w)).toVar()));
          }).setLayout({
            name: "mx_cell_noise_float_3",
            type: "float",
            inputs: [{ name: "p", type: "vec4" }],
          }),
        ]),
        pD = eM(([e]) => {
          let t = eD(pc(eL(e).toVar())).toVar();
          return eW(pR(pM(t, eD(0))), pR(pM(t, eD(1))), pR(pM(t, eD(2))));
        }).setLayout({
          name: "mx_cell_noise_vec3_0",
          type: "vec3",
          inputs: [{ name: "p", type: "float" }],
        }),
        pV = eM(([e]) => {
          let t = eG(e).toVar(),
            r = eD(pc(t.x)).toVar(),
            i = eD(pc(t.y)).toVar();
          return eW(
            pR(pM(r, i, eD(0))),
            pR(pM(r, i, eD(1))),
            pR(pM(r, i, eD(2)))
          );
        }).setLayout({
          name: "mx_cell_noise_vec3_1",
          type: "vec3",
          inputs: [{ name: "p", type: "vec2" }],
        }),
        pO = dR([
          pD,
          pV,
          eM(([e]) => {
            let t = eW(e).toVar(),
              r = eD(pc(t.x)).toVar(),
              i = eD(pc(t.y)).toVar(),
              s = eD(pc(t.z)).toVar();
            return eW(
              pR(pM(r, i, s, eD(0))),
              pR(pM(r, i, s, eD(1))),
              pR(pM(r, i, s, eD(2)))
            );
          }).setLayout({
            name: "mx_cell_noise_vec3_2",
            type: "vec3",
            inputs: [{ name: "p", type: "vec3" }],
          }),
          eM(([e]) => {
            let t = eX(e).toVar(),
              r = eD(pc(t.x)).toVar(),
              i = eD(pc(t.y)).toVar(),
              s = eD(pc(t.z)).toVar(),
              n = eD(pc(t.w)).toVar();
            return eW(
              pR(pM(r, i, s, n, eD(0))),
              pR(pM(r, i, s, n, eD(1))),
              pR(pM(r, i, s, n, eD(2)))
            );
          }).setLayout({
            name: "mx_cell_noise_vec3_3",
            type: "vec3",
            inputs: [{ name: "p", type: "vec4" }],
          }),
        ]),
        pG = eM(([e, t, r, i]) => {
          let s = eL(i).toVar(),
            n = eL(r).toVar(),
            a = eD(t).toVar(),
            o = eW(e).toVar(),
            l = eL(0).toVar(),
            u = eL(1).toVar();
          return (
            aT(a, () => {
              l.addAssign(u.mul(pF(o))), u.mulAssign(s), o.mulAssign(n);
            }),
            l
          );
        }).setLayout({
          name: "mx_fractal_noise_float",
          type: "float",
          inputs: [
            { name: "p", type: "vec3" },
            { name: "octaves", type: "int" },
            { name: "lacunarity", type: "float" },
            { name: "diminish", type: "float" },
          ],
        }),
        pk = eM(([e, t, r, i]) => {
          let s = eL(i).toVar(),
            n = eL(r).toVar(),
            a = eD(t).toVar(),
            o = eW(e).toVar(),
            l = eW(0).toVar(),
            u = eL(1).toVar();
          return (
            aT(a, () => {
              l.addAssign(u.mul(pU(o))), u.mulAssign(s), o.mulAssign(n);
            }),
            l
          );
        }).setLayout({
          name: "mx_fractal_noise_vec3",
          type: "vec3",
          inputs: [
            { name: "p", type: "vec3" },
            { name: "octaves", type: "int" },
            { name: "lacunarity", type: "float" },
            { name: "diminish", type: "float" },
          ],
        }),
        pz = eM(([e, t, r, i]) => {
          let s = eL(i).toVar(),
            n = eL(r).toVar(),
            a = eD(t).toVar(),
            o = eW(e).toVar();
          return eG(
            pG(o, a, n, s),
            pG(o.add(eW(eD(19), eD(193), eD(17))), a, n, s)
          );
        }).setLayout({
          name: "mx_fractal_noise_vec2",
          type: "vec2",
          inputs: [
            { name: "p", type: "vec3" },
            { name: "octaves", type: "int" },
            { name: "lacunarity", type: "float" },
            { name: "diminish", type: "float" },
          ],
        }),
        p$ = eM(([e, t, r, i]) => {
          let s = eL(i).toVar(),
            n = eL(r).toVar(),
            a = eD(t).toVar(),
            o = eW(e).toVar();
          return eX(
            eW(pk(o, a, n, s)).toVar(),
            eL(pG(o.add(eW(eD(19), eD(193), eD(17))), a, n, s)).toVar()
          );
        }).setLayout({
          name: "mx_fractal_noise_vec4",
          type: "vec4",
          inputs: [
            { name: "p", type: "vec3" },
            { name: "octaves", type: "int" },
            { name: "lacunarity", type: "float" },
            { name: "diminish", type: "float" },
          ],
        }),
        pW = dR([
          eM(([e, t, r, i, s, n, a]) => {
            let o = eD(a).toVar(),
              l = eL(n).toVar(),
              u = eD(s).toVar(),
              d = eD(i).toVar(),
              h = eD(r).toVar(),
              c = eD(t).toVar(),
              p = eG(e).toVar(),
              g = eW(pO(eG(c.add(d), h.add(u)))).toVar(),
              m = eG(g.x, g.y).toVar();
            m.subAssign(0.5), m.mulAssign(l), m.addAssign(0.5);
            let f = eG(eG(eL(c), eL(h)).add(m)).toVar(),
              y = eG(f.sub(p)).toVar();
            return (
              eU(o.equal(eD(2)), () => rv(y.x).add(rv(y.y))),
              eU(o.equal(eD(3)), () => rD(rv(y.x), rv(y.y))),
              r$(y, y)
            );
          }).setLayout({
            name: "mx_worley_distance_0",
            type: "float",
            inputs: [
              { name: "p", type: "vec2" },
              { name: "x", type: "int" },
              { name: "y", type: "int" },
              { name: "xoff", type: "int" },
              { name: "yoff", type: "int" },
              { name: "jitter", type: "float" },
              { name: "metric", type: "int" },
            ],
          }),
          eM(([e, t, r, i, s, n, a, o, l]) => {
            let u = eD(l).toVar(),
              d = eL(o).toVar(),
              h = eD(a).toVar(),
              c = eD(n).toVar(),
              p = eD(s).toVar(),
              g = eD(i).toVar(),
              m = eD(r).toVar(),
              f = eD(t).toVar(),
              y = eW(e).toVar(),
              x = eW(pO(eW(f.add(p), m.add(c), g.add(h)))).toVar();
            x.subAssign(0.5), x.mulAssign(d), x.addAssign(0.5);
            let b = eW(eW(eL(f), eL(m), eL(g)).add(x)).toVar(),
              T = eW(b.sub(y)).toVar();
            return (
              eU(u.equal(eD(2)), () => rv(T.x).add(rv(T.y)).add(rv(T.z))),
              eU(u.equal(eD(3)), () => rD(rD(rv(T.x), rv(T.y)), rv(T.z))),
              r$(T, T)
            );
          }).setLayout({
            name: "mx_worley_distance_1",
            type: "float",
            inputs: [
              { name: "p", type: "vec3" },
              { name: "x", type: "int" },
              { name: "y", type: "int" },
              { name: "z", type: "int" },
              { name: "xoff", type: "int" },
              { name: "yoff", type: "int" },
              { name: "zoff", type: "int" },
              { name: "jitter", type: "float" },
              { name: "metric", type: "int" },
            ],
          }),
        ]),
        pH = eM(([e, t, r]) => {
          let i = eD(r).toVar(),
            s = eL(t).toVar(),
            n = eG(e).toVar(),
            a = eD().toVar(),
            o = eD().toVar(),
            l = eG(pp(n.x, a), pp(n.y, o)).toVar(),
            u = eL(1e6).toVar();
          return (
            aT(
              { start: -1, end: eD(1), name: "x", condition: "<=" },
              ({ x: e }) => {
                aT(
                  { start: -1, end: eD(1), name: "y", condition: "<=" },
                  ({ y: t }) => {
                    let r = eL(pW(l, e, t, a, o, s, i)).toVar();
                    u.assign(rL(u, r));
                  }
                );
              }
            ),
            eU(i.equal(eD(0)), () => {
              u.assign(rd(u));
            }),
            u
          );
        }).setLayout({
          name: "mx_worley_noise_float_0",
          type: "float",
          inputs: [
            { name: "p", type: "vec2" },
            { name: "jitter", type: "float" },
            { name: "metric", type: "int" },
          ],
        }),
        pq = eM(([e, t, r]) => {
          let i = eD(r).toVar(),
            s = eL(t).toVar(),
            n = eG(e).toVar(),
            a = eD().toVar(),
            o = eD().toVar(),
            l = eG(pp(n.x, a), pp(n.y, o)).toVar(),
            u = eG(1e6, 1e6).toVar();
          return (
            aT(
              { start: -1, end: eD(1), name: "x", condition: "<=" },
              ({ x: e }) => {
                aT(
                  { start: -1, end: eD(1), name: "y", condition: "<=" },
                  ({ y: t }) => {
                    let r = eL(pW(l, e, t, a, o, s, i)).toVar();
                    eU(r.lessThan(u.x), () => {
                      u.y.assign(u.x), u.x.assign(r);
                    }).ElseIf(r.lessThan(u.y), () => {
                      u.y.assign(r);
                    });
                  }
                );
              }
            ),
            eU(i.equal(eD(0)), () => {
              u.assign(rd(u));
            }),
            u
          );
        }).setLayout({
          name: "mx_worley_noise_vec2_0",
          type: "vec2",
          inputs: [
            { name: "p", type: "vec2" },
            { name: "jitter", type: "float" },
            { name: "metric", type: "int" },
          ],
        }),
        pj = eM(([e, t, r]) => {
          let i = eD(r).toVar(),
            s = eL(t).toVar(),
            n = eG(e).toVar(),
            a = eD().toVar(),
            o = eD().toVar(),
            l = eG(pp(n.x, a), pp(n.y, o)).toVar(),
            u = eW(1e6, 1e6, 1e6).toVar();
          return (
            aT(
              { start: -1, end: eD(1), name: "x", condition: "<=" },
              ({ x: e }) => {
                aT(
                  { start: -1, end: eD(1), name: "y", condition: "<=" },
                  ({ y: t }) => {
                    let r = eL(pW(l, e, t, a, o, s, i)).toVar();
                    eU(r.lessThan(u.x), () => {
                      u.z.assign(u.y), u.y.assign(u.x), u.x.assign(r);
                    })
                      .ElseIf(r.lessThan(u.y), () => {
                        u.z.assign(u.y), u.y.assign(r);
                      })
                      .ElseIf(r.lessThan(u.z), () => {
                        u.z.assign(r);
                      });
                  }
                );
              }
            ),
            eU(i.equal(eD(0)), () => {
              u.assign(rd(u));
            }),
            u
          );
        }).setLayout({
          name: "mx_worley_noise_vec3_0",
          type: "vec3",
          inputs: [
            { name: "p", type: "vec2" },
            { name: "jitter", type: "float" },
            { name: "metric", type: "int" },
          ],
        }),
        pX = dR([
          pH,
          eM(([e, t, r]) => {
            let i = eD(r).toVar(),
              s = eL(t).toVar(),
              n = eW(e).toVar(),
              a = eD().toVar(),
              o = eD().toVar(),
              l = eD().toVar(),
              u = eW(pp(n.x, a), pp(n.y, o), pp(n.z, l)).toVar(),
              d = eL(1e6).toVar();
            return (
              aT(
                { start: -1, end: eD(1), name: "x", condition: "<=" },
                ({ x: e }) => {
                  aT(
                    { start: -1, end: eD(1), name: "y", condition: "<=" },
                    ({ y: t }) => {
                      aT(
                        { start: -1, end: eD(1), name: "z", condition: "<=" },
                        ({ z: r }) => {
                          let n = eL(pW(u, e, t, r, a, o, l, s, i)).toVar();
                          d.assign(rL(d, n));
                        }
                      );
                    }
                  );
                }
              ),
              eU(i.equal(eD(0)), () => {
                d.assign(rd(d));
              }),
              d
            );
          }).setLayout({
            name: "mx_worley_noise_float_1",
            type: "float",
            inputs: [
              { name: "p", type: "vec3" },
              { name: "jitter", type: "float" },
              { name: "metric", type: "int" },
            ],
          }),
        ]),
        pQ = dR([
          pq,
          eM(([e, t, r]) => {
            let i = eD(r).toVar(),
              s = eL(t).toVar(),
              n = eW(e).toVar(),
              a = eD().toVar(),
              o = eD().toVar(),
              l = eD().toVar(),
              u = eW(pp(n.x, a), pp(n.y, o), pp(n.z, l)).toVar(),
              d = eG(1e6, 1e6).toVar();
            return (
              aT(
                { start: -1, end: eD(1), name: "x", condition: "<=" },
                ({ x: e }) => {
                  aT(
                    { start: -1, end: eD(1), name: "y", condition: "<=" },
                    ({ y: t }) => {
                      aT(
                        { start: -1, end: eD(1), name: "z", condition: "<=" },
                        ({ z: r }) => {
                          let n = eL(pW(u, e, t, r, a, o, l, s, i)).toVar();
                          eU(n.lessThan(d.x), () => {
                            d.y.assign(d.x), d.x.assign(n);
                          }).ElseIf(n.lessThan(d.y), () => {
                            d.y.assign(n);
                          });
                        }
                      );
                    }
                  );
                }
              ),
              eU(i.equal(eD(0)), () => {
                d.assign(rd(d));
              }),
              d
            );
          }).setLayout({
            name: "mx_worley_noise_vec2_1",
            type: "vec2",
            inputs: [
              { name: "p", type: "vec3" },
              { name: "jitter", type: "float" },
              { name: "metric", type: "int" },
            ],
          }),
        ]),
        pK = dR([
          pj,
          eM(([e, t, r]) => {
            let i = eD(r).toVar(),
              s = eL(t).toVar(),
              n = eW(e).toVar(),
              a = eD().toVar(),
              o = eD().toVar(),
              l = eD().toVar(),
              u = eW(pp(n.x, a), pp(n.y, o), pp(n.z, l)).toVar(),
              d = eW(1e6, 1e6, 1e6).toVar();
            return (
              aT(
                { start: -1, end: eD(1), name: "x", condition: "<=" },
                ({ x: e }) => {
                  aT(
                    { start: -1, end: eD(1), name: "y", condition: "<=" },
                    ({ y: t }) => {
                      aT(
                        { start: -1, end: eD(1), name: "z", condition: "<=" },
                        ({ z: r }) => {
                          let n = eL(pW(u, e, t, r, a, o, l, s, i)).toVar();
                          eU(n.lessThan(d.x), () => {
                            d.z.assign(d.y), d.y.assign(d.x), d.x.assign(n);
                          })
                            .ElseIf(n.lessThan(d.y), () => {
                              d.z.assign(d.y), d.y.assign(n);
                            })
                            .ElseIf(n.lessThan(d.z), () => {
                              d.z.assign(n);
                            });
                        }
                      );
                    }
                  );
                }
              ),
              eU(i.equal(eD(0)), () => {
                d.assign(rd(d));
              }),
              d
            );
          }).setLayout({
            name: "mx_worley_noise_vec3_1",
            type: "vec3",
            inputs: [
              { name: "p", type: "vec3" },
              { name: "jitter", type: "float" },
              { name: "metric", type: "int" },
            ],
          }),
        ]),
        pY = eM(([e]) => {
          let t = e.y,
            r = e.z,
            i = eW().toVar();
          return (
            eU(t.lessThan(1e-4), () => {
              i.assign(eW(r, r, r));
            }).Else(() => {
              let s = e.x,
                n = eD(rB((s = s.sub(rc(s)).mul(6).toVar()))),
                a = s.sub(eL(n)),
                o = r.mul(t.oneMinus()),
                l = r.mul(t.mul(a).oneMinus()),
                u = r.mul(t.mul(a.oneMinus()).oneMinus());
              eU(n.equal(eD(0)), () => {
                i.assign(eW(r, u, o));
              })
                .ElseIf(n.equal(eD(1)), () => {
                  i.assign(eW(l, r, o));
                })
                .ElseIf(n.equal(eD(2)), () => {
                  i.assign(eW(o, r, u));
                })
                .ElseIf(n.equal(eD(3)), () => {
                  i.assign(eW(o, l, r));
                })
                .ElseIf(n.equal(eD(4)), () => {
                  i.assign(eW(u, o, r));
                })
                .Else(() => {
                  i.assign(eW(r, o, l));
                });
            }),
            i
          );
        }).setLayout({
          name: "mx_hsvtorgb",
          type: "vec3",
          inputs: [{ name: "hsv", type: "vec3" }],
        }),
        pZ = eM(([e]) => {
          let t = eW(e).toVar(),
            r = eL(t.x).toVar(),
            i = eL(t.y).toVar(),
            s = eL(t.z).toVar(),
            n = eL(rL(r, rL(i, s))).toVar(),
            a = eL(rD(r, rD(i, s))).toVar(),
            o = eL(a.sub(n)).toVar(),
            l = eL().toVar(),
            u = eL().toVar(),
            d = eL().toVar();
          return (
            d.assign(a),
            eU(a.greaterThan(0), () => {
              u.assign(o.div(a));
            }).Else(() => {
              u.assign(0);
            }),
            eU(u.lessThanEqual(0), () => {
              l.assign(0);
            }).Else(() => {
              eU(r.greaterThanEqual(a), () => {
                l.assign(i.sub(s).div(o));
              })
                .ElseIf(i.greaterThanEqual(a), () => {
                  l.assign(tO(2, s.sub(r).div(o)));
                })
                .Else(() => {
                  l.assign(tO(4, r.sub(i).div(o)));
                }),
                l.mulAssign(1 / 6),
                eU(l.lessThan(0), () => {
                  l.addAssign(1);
                });
            }),
            eW(l, u, d)
          );
        }).setLayout({
          name: "mx_rgbtohsv",
          type: "vec3",
          inputs: [{ name: "c", type: "vec3" }],
        }),
        pJ = eM(([e]) => {
          let t = eW(e).toVar(),
            r = ej(tj(t, eW(0.04045))).toVar();
          return rZ(
            eW(t.div(12.92)).toVar(),
            eW(rH(rD(t.add(eW(0.055)), eW(0)).div(1.055), eW(2.4))).toVar(),
            r
          );
        }).setLayout({
          name: "mx_srgb_texture_to_lin_rec709",
          type: "vec3",
          inputs: [{ name: "color", type: "vec3" }],
        }),
        p0 = (e, t) => {
          e = eL(e);
          let r = eG((t = eL(t)).dFdx(), t.dFdy())
            .length()
            .mul(0.7071067811865476);
          return r2(e.sub(r), e.add(r), t);
        },
        p1 = (e, t, r, i) => rZ(e, t, r[i].clamp()),
        p2 = (e, t, r, i, s) => rZ(e, t, p0(r, i[s])),
        p3 = eM(([e, t, r]) => {
          let i = rg(e).toVar("nDir"),
            s = tG(eL(0.5).mul(t.sub(r)), sI)
              .div(i)
              .toVar("rbmax"),
            n = tG(eL(-0.5).mul(t.sub(r)), sI)
              .div(i)
              .toVar("rbmin"),
            a = eW().toVar("rbminmax");
          (a.x = i.x.greaterThan(eL(0)).select(s.x, n.x)),
            (a.y = i.y.greaterThan(eL(0)).select(s.y, n.y)),
            (a.z = i.z.greaterThan(eL(0)).select(s.z, n.z));
          let o = rL(rL(a.x, a.y), a.z).toVar("correction");
          return sI.add(i.mul(o)).toVar("boxIntersection").sub(r);
        }),
        p4 = eM(([e, t]) => {
          let r = e.x,
            i = e.y,
            s = e.z,
            n = t.element(0).mul(0.886227);
          return (n = (n = (n = (n = (n = (n = (n = n.add(
            t.element(1).mul(1.023328).mul(i)
          )).add(t.element(2).mul(1.023328).mul(s))).add(
            t.element(3).mul(1.023328).mul(r)
          )).add(t.element(4).mul(0.858086).mul(r).mul(i))).add(
            t.element(5).mul(0.858086).mul(i).mul(s)
          )).add(t.element(6).mul(s.mul(s).mul(0.743125).sub(0.247708)))).add(
            t.element(7).mul(0.858086).mul(r).mul(s)
          )).add(
            t
              .element(8)
              .mul(0.429043)
              .mul(tk(r, r).sub(tk(i, i)))
          );
        });
      var p6 = Object.freeze({
        __proto__: null,
        BRDF_GGX: oX,
        BRDF_Lambert: oF,
        BasicPointShadowFilter: c5,
        BasicShadowFilter: cX,
        Break: a_,
        Const: il,
        Continue: () => iq("continue").append(),
        DFGApprox: oQ,
        D_GGX: oH,
        Discard: ij,
        EPSILON: t9,
        F_Schlick: oB,
        Fn: eM,
        INFINITY: t7,
        If: eU,
        Loop: aT,
        NodeAccess: F,
        NodeShaderStage: w,
        NodeType: B,
        NodeUpdateType: M,
        PCFShadowFilter: cQ,
        PCFSoftShadowFilter: cK,
        PI: re,
        PI2: rt,
        PointShadowFilter: c8,
        Return: () => iq("return").append(),
        Schlick_to_F0: oY,
        ScriptableNodeResources: h8,
        ShaderNode: eS,
        TBNViewMatrix: nf,
        VSMShadowFilter: cY,
        V_GGX_SmithCorrelated: o$,
        Var: io,
        abs: rv,
        acesFilmicToneMapping: hj,
        acos: rT,
        add: tO,
        addMethodChaining: J,
        addNodeElement: function (e) {
          console.warn(
            "THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add",
            e
          );
        },
        agxToneMapping: hY,
        all: rr,
        alphaT: ty,
        and: tK,
        anisotropy: tx,
        anisotropyB: tT,
        anisotropyT: tb,
        any: ri,
        append: eI,
        array: e4,
        arrayBuffer: (e) => eR(new Q(e, "ArrayBuffer")),
        asin: rb,
        assign: tP,
        atan: r_,
        atan2: r8,
        atomicAdd: (e, t, r = null) => c_(cb.ATOMIC_ADD, e, t, r),
        atomicAnd: (e, t, r = null) => c_(cb.ATOMIC_AND, e, t, r),
        atomicFunc: c_,
        atomicLoad: (e, t = null) => c_(cb.ATOMIC_LOAD, e, null, t),
        atomicMax: (e, t, r = null) => c_(cb.ATOMIC_MAX, e, t, r),
        atomicMin: (e, t, r = null) => c_(cb.ATOMIC_MIN, e, t, r),
        atomicOr: (e, t, r = null) => c_(cb.ATOMIC_OR, e, t, r),
        atomicStore: (e, t, r = null) => c_(cb.ATOMIC_STORE, e, t, r),
        atomicSub: (e, t, r = null) => c_(cb.ATOMIC_SUB, e, t, r),
        atomicXor: (e, t, r = null) => c_(cb.ATOMIC_XOR, e, t, r),
        attenuationColor: tF,
        attenuationDistance: tB,
        attribute: iY,
        attributeArray: (e, t = "float") => {
          let r, i;
          return (
            !0 === t.isStruct
              ? ((r = t.layout.getLength()), (i = _("float")))
              : ((r = v(t)), (i = _(t))),
            hs(new he(e, r, i), t, e)
          );
        },
        backgroundBlurriness: hh,
        backgroundIntensity: hc,
        backgroundRotation: hp,
        batch: am,
        billboarding: dB,
        bitAnd: t0,
        bitNot: t1,
        bitOr: t2,
        bitXor: t3,
        bitangentGeometry: nd,
        bitangentLocal: nh,
        bitangentView: nc,
        bitangentWorld: np,
        bitcast: rI,
        blendBurn: hR,
        blendColor: hw,
        blendDodge: hA,
        blendOverlay: hE,
        blendScreen: hC,
        blur: lz,
        bool: eO,
        buffer: i8,
        bufferAttribute: iF,
        bumpMap: nR,
        burn: (...e) => (
          console.warn(
            'THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.'
          ),
          hR(e)
        ),
        bvec2: e$,
        bvec3: ej,
        bvec4: eY,
        bypass: ik,
        cache: iO,
        call: tD,
        cameraFar: si,
        cameraIndex: st,
        cameraNear: sr,
        cameraNormalMatrix: sl,
        cameraPosition: su,
        cameraProjectionMatrix: ss,
        cameraProjectionMatrixInverse: sn,
        cameraViewMatrix: sa,
        cameraWorldMatrix: so,
        cbrt: rK,
        cdl: hP,
        ceil: rp,
        checker: pl,
        cineonToneMapping: hH,
        clamp: rJ,
        clearcoat: td,
        clearcoatRoughness: th,
        code: h0,
        color: eP,
        colorSpaceToWorking: iv,
        colorToDirection: (e) => eR(e).mul(2).sub(1),
        compute: iD,
        cond: ie,
        context: ir,
        convert: e2,
        convertColorSpace: (e, t, r) => eR(new ix(eR(e), t, r)),
        convertToTexture: (e, ...t) =>
          e.isTextureNode ? e : e.isPassNode ? e.getTextureNode() : d6(e, ...t),
        cos: ry,
        cross: rW,
        cubeTexture: s8,
        cubeToUV: c6,
        dFdx: rC,
        dFdy: rE,
        dashSize: tR,
        defaultBuildStages: I,
        defaultShaderStages: U,
        defined: ev,
        degrees: rn,
        deltaTime: dC,
        densityFog: function (e, t) {
          return (
            console.warn(
              'THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'
            ),
            ci(e, cr(t))
          );
        },
        densityFogFactor: cr,
        depth: a2,
        depthPass: (e, t, r) => eR(new hk(hk.DEPTH, e, t, r)),
        difference: rz,
        diffuseColor: ta,
        directPointLight: pa,
        directionToColor: og,
        dispersion: tU,
        distance: rk,
        div: tz,
        dodge: (...e) => (
          console.warn(
            'THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'
          ),
          hA(e)
        ),
        dot: r$,
        drawIndex: au,
        dynamicBufferAttribute: iU,
        element: e1,
        emissive: to,
        equal: tW,
        equals: rP,
        equirectUV: ox,
        exp: ra,
        exp2: ro,
        expression: iq,
        faceDirection: sG,
        faceForward: r3,
        faceforward: r3,
        float: eL,
        floor: rc,
        fog: ci,
        fract: rm,
        frameGroup: e9,
        frameId: dE,
        frontFacing: sO,
        fwidth: rF,
        gain: (e, t) =>
          e.lessThan(0.5)
            ? db(e.mul(2), t).div(2)
            : tG(1, db(tk(tG(1, e), 2), t).div(2)),
        gapSize: tA,
        getConstNodeType: eN,
        getCurrentStack: eF,
        getDirection: lV,
        getDistanceAttenuation: pn,
        getGeometryRoughness: ok,
        getNormalFromDepth: d9,
        getParallaxCorrectNormal: p3,
        getRoughness: oz,
        getScreenPosition: d8,
        getShIrradianceAt: p4,
        getTextureIndex: dm,
        getViewPosition: d5,
        globalId: cc,
        glsl: (e, t) => h0(e, t, "glsl"),
        glslFn: (e, t) => h2(e, t, "glsl"),
        grayscale: hM,
        greaterThan: tj,
        greaterThanEqual: tQ,
        hash: dx,
        highpModelNormalViewMatrix: sM,
        highpModelViewMatrix: sw,
        hue: hU,
        instance: ah,
        instanceIndex: an,
        instancedArray: (e, t = "float") => {
          let r, i;
          return (
            !0 === t.isStruct
              ? ((r = t.layout.getLength()), (i = _("float")))
              : ((r = v(t)), (i = _(t))),
            hs(new d7(e, r, i), t, e)
          );
        },
        instancedBufferAttribute: iI,
        instancedDynamicBufferAttribute: iP,
        instancedMesh: ap,
        int: eD,
        inverseSqrt: rh,
        inversesqrt: rh,
        invocationLocalIndex: al,
        invocationSubgroupIndex: ao,
        ior: tE,
        iridescence: tg,
        iridescenceIOR: tm,
        iridescenceThickness: tf,
        ivec2: ek,
        ivec3: eH,
        ivec4: eQ,
        js: (e, t) => h0(e, t, "js"),
        label: ii,
        length: rS,
        lengthSq: rY,
        lessThan: tq,
        lessThanEqual: tX,
        lightPosition: cR,
        lightProjectionUV: cS,
        lightShadowMatrix: cN,
        lightTargetDirection: cE,
        lightTargetPosition: cA,
        lightViewPosition: cC,
        lightingContext: aM,
        lights: (e = []) => eR(new cF()).setLights(e),
        linearDepth: a3,
        linearToneMapping: h$,
        localId: cp,
        log: rl,
        log2: ru,
        logarithmicDepthToViewZ: (e, t, r) => {
          let i = e.mul(rl(r.div(t)));
          return eL(Math.E).pow(i).mul(t).negate();
        },
        loop: (...e) => (
          console.warn("TSL.LoopNode: loop() has been renamed to Loop()."),
          aT(...e)
        ),
        luminance: hI,
        mat2: eZ,
        mat3: eJ,
        mat4: e0,
        matcapUV: ux,
        materialAO: ae,
        materialAlphaTest: nE,
        materialAnisotropy: nj,
        materialAnisotropyVector: at,
        materialAttenuationColor: n1,
        materialAttenuationDistance: n0,
        materialClearcoat: nk,
        materialClearcoatNormal: n$,
        materialClearcoatRoughness: nz,
        materialColor: nw,
        materialDispersion: n9,
        materialEmissive: nB,
        materialEnvIntensity: s0,
        materialEnvRotation: s1,
        materialIOR: nJ,
        materialIridescence: nX,
        materialIridescenceIOR: nQ,
        materialIridescenceThickness: nK,
        materialLightMap: n7,
        materialLineDashOffset: n5,
        materialLineDashSize: n3,
        materialLineGapSize: n4,
        materialLineScale: n2,
        materialLineWidth: n6,
        materialMetalness: nO,
        materialNormal: nG,
        materialOpacity: nF,
        materialPointSize: n8,
        materialReference: ni,
        materialReflectivity: nD,
        materialRefractionRatio: sJ,
        materialRotation: nW,
        materialRoughness: nV,
        materialSheen: nH,
        materialSheenRoughness: nq,
        materialShininess: nM,
        materialSpecular: nU,
        materialSpecularColor: nP,
        materialSpecularIntensity: nI,
        materialSpecularStrength: nL,
        materialThickness: nZ,
        materialTransmission: nY,
        max: rD,
        maxMipLevel: i2,
        mediumpModelViewMatrix: sE,
        metalness: tu,
        min: rL,
        mix: rZ,
        mixElement: r6,
        mod: rV,
        modInt: t$,
        modelDirection: sb,
        modelNormalMatrix: sR,
        modelPosition: s_,
        modelRadius: sS,
        modelScale: sv,
        modelViewMatrix: sC,
        modelViewPosition: sN,
        modelViewProjection: ar,
        modelWorldMatrix: sT,
        modelWorldMatrixInverse: sA,
        morphReference: aA,
        mrt: dy,
        mul: tk,
        mx_aastep: p0,
        mx_cell_noise_float: (e = iZ()) => pL(e.convert("vec2|vec3")),
        mx_contrast: (e, t = 1, r = 0.5) => eL(e).sub(r).mul(t).add(r),
        mx_fractal_noise_float: (e = iZ(), t = 3, r = 2, i = 0.5, s = 1) =>
          pG(e, eD(t), r, i).mul(s),
        mx_fractal_noise_vec2: (e = iZ(), t = 3, r = 2, i = 0.5, s = 1) =>
          pz(e, eD(t), r, i).mul(s),
        mx_fractal_noise_vec3: (e = iZ(), t = 3, r = 2, i = 0.5, s = 1) =>
          pk(e, eD(t), r, i).mul(s),
        mx_fractal_noise_vec4: (e = iZ(), t = 3, r = 2, i = 0.5, s = 1) =>
          p$(e, eD(t), r, i).mul(s),
        mx_hsvtorgb: pY,
        mx_noise_float: (e = iZ(), t = 1, r = 0) =>
          pF(e.convert("vec2|vec3")).mul(t).add(r),
        mx_noise_vec3: (e = iZ(), t = 1, r = 0) =>
          pU(e.convert("vec2|vec3")).mul(t).add(r),
        mx_noise_vec4: (e = iZ(), t = 1, r = 0) =>
          eX(pU((e = e.convert("vec2|vec3"))), pF(e.add(eG(19, 73))))
            .mul(t)
            .add(r),
        mx_ramplr: (e, t, r = iZ()) => p1(e, t, r, "x"),
        mx_ramptb: (e, t, r = iZ()) => p1(e, t, r, "y"),
        mx_rgbtohsv: pZ,
        mx_safepower: (e, t = 1) => (e = eL(e)).abs().pow(t).mul(e.sign()),
        mx_splitlr: (e, t, r, i = iZ()) => p2(e, t, r, i, "x"),
        mx_splittb: (e, t, r, i = iZ()) => p2(e, t, r, i, "y"),
        mx_srgb_texture_to_lin_rec709: pJ,
        mx_transform_uv: (e = 1, t = 0, r = iZ()) => r.mul(e).add(t),
        mx_worley_noise_float: (e = iZ(), t = 1) =>
          pX(e.convert("vec2|vec3"), t, eD(1)),
        mx_worley_noise_vec2: (e = iZ(), t = 1) =>
          pQ(e.convert("vec2|vec3"), t, eD(1)),
        mx_worley_noise_vec3: (e = iZ(), t = 1) =>
          pK(e.convert("vec2|vec3"), t, eD(1)),
        negate: rR,
        neutralToneMapping: hZ,
        nodeArray: eC,
        nodeImmutable: ew,
        nodeObject: eR,
        nodeObjects: eA,
        nodeProxy: eE,
        normalFlat: s$,
        normalGeometry: sk,
        normalLocal: sz,
        normalMap: n_,
        normalView: sW,
        normalWorld: sH,
        normalize: rg,
        not: tZ,
        notEqual: tH,
        numWorkgroups: cd,
        objectDirection: sc,
        objectGroup: te,
        objectPosition: sg,
        objectRadius: sy,
        objectScale: sm,
        objectViewPosition: sf,
        objectWorldMatrix: sp,
        oneMinus: rA,
        or: tY,
        orthographicDepthToViewZ: (e, t, r) => t.sub(r).mul(e).sub(t),
        oscSawtooth: (e = dA) => e.fract(),
        oscSine: (e = dA) =>
          e
            .add(0.75)
            .mul(2 * Math.PI)
            .sin()
            .mul(0.5)
            .add(0.5),
        oscSquare: (e = dA) => e.fract().round(),
        oscTriangle: (e = dA) => e.add(0.5).fract().mul(2).sub(1).abs(),
        output: tS,
        outputStruct: dg,
        overlay: (...e) => (
          console.warn(
            'THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'
          ),
          hE(e)
        ),
        overloadingFn: dR,
        parabola: db,
        parallaxDirection: ny,
        parallaxUV: (e, t) => e.sub(ny.mul(t)),
        parameter: (e, t) => eR(new dl(e, t)),
        pass: (e, t, r) => eR(new hk(hk.COLOR, e, t, r)),
        passTexture: (e, t) => eR(new hO(e, t)),
        pcurve: (e, t, r) =>
          rH(tz(rH(e, t), tO(rH(e, t), rH(tG(1, e), r))), 1 / t),
        perspectiveDepthToViewZ: aJ,
        pmremTexture: ur,
        pointShadow: pi,
        pointUV: ho,
        pointWidth: tC,
        positionGeometry: sB,
        positionLocal: sF,
        positionPrevious: sU,
        positionView: sL,
        positionViewDirection: sD,
        positionWorld: sI,
        positionWorldDirection: sP,
        posterize: hD,
        pow: rH,
        pow2: rq,
        pow3: rj,
        pow4: rX,
        property: ts,
        radians: rs,
        rand: r4,
        range: co,
        rangeFog: function (e, t, r) {
          return (
            console.warn(
              'THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'
            ),
            ci(e, ct(t, r))
          );
        },
        rangeFogFactor: ct,
        reciprocal: rM,
        reference: ne,
        referenceBuffer: nt,
        reflect: rG,
        reflectVector: s4,
        reflectView: s2,
        reflector: (e) => eR(new dY(e)),
        refract: r1,
        refractVector: s6,
        refractView: s3,
        reinhardToneMapping: hW,
        remainder: t5,
        remap: i$,
        remapClamp: iW,
        renderGroup: e7,
        renderOutput: iQ,
        rendererReference: iC,
        rotate: uv,
        rotateUV: dw,
        roughness: tl,
        round: rw,
        rtt: d6,
        sRGBTransferEOTF: ip,
        sRGBTransferOETF: ig,
        sampler: (e) => (!0 === e.isNode ? e : i4(e)).convert("sampler"),
        saturate: r0,
        saturation: hB,
        screen: (...e) => (
          console.warn(
            'THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'
          ),
          hC(e)
        ),
        screenCoordinate: aP,
        screenSize: aI,
        screenUV: aU,
        scriptable: h7,
        scriptableValue: h4,
        select: r7,
        setCurrentStack: eB,
        shaderStages: P,
        shadow: c3,
        shadowPositionWorld: cI,
        shapeCircle: pu,
        sharedUniformGroup: e8,
        sheen: tc,
        sheenRoughness: tp,
        shiftLeft: t4,
        shiftRight: t6,
        shininess: tN,
        sign: rN,
        sin: rf,
        sinc: (e, t) =>
          rf(re.mul(t.mul(e).sub(1))).div(re.mul(t.mul(e).sub(1))),
        skinning: (e) => eR(new ay(e)),
        skinningReference: ax,
        smoothstep: r2,
        smoothstepElement: r5,
        specularColor: t_,
        specularF90: tv,
        spherizeUV: dM,
        split: (e, t) => eR(new W(eR(e), t)),
        spritesheetUV: dI,
        sqrt: rd,
        stack: dd,
        step: rO,
        storage: hs,
        storageBarrier: () => cf("storage").append(),
        storageObject: (e, t, r) => (
          console.warn(
            'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'
          ),
          hs(e, t, r).setPBO(!0)
        ),
        storageTexture: hm,
        string: (e = "") => eR(new Q(e, "string")),
        struct: (e, t = null) => {
          let r = new dh(e, t),
            i = (...t) => {
              let i = null;
              if (t.length > 0)
                if (t[0].isNode) {
                  i = {};
                  let r = Object.keys(e);
                  for (let e = 0; e < t.length; e++) i[r[e]] = t[e];
                } else i = t[0];
              return eR(new dc(r, i));
            };
          return (i.layout = r), (i.isStruct = !0), i;
        },
        sub: tG,
        subgroupIndex: aa,
        subgroupSize: cg,
        tan: rx,
        tangentGeometry: ns,
        tangentLocal: nn,
        tangentView: na,
        tangentWorld: no,
        temp: iu,
        texture: i4,
        texture3D: hx,
        textureBarrier: () => cf("texture").append(),
        textureBicubic: la,
        textureCubeUV: lO,
        textureLoad: i6,
        textureSize: i0,
        textureStore: (e, t, r) => {
          let i = hm(e, t, r);
          return null !== r && i.append(), i;
        },
        thickness: tM,
        time: dA,
        timerDelta: (e = 1) => (
          console.warn(
            'TSL: timerDelta() is deprecated. Use "deltaTime" instead.'
          ),
          dC.mul(e)
        ),
        timerGlobal: (e = 1) => (
          console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.'),
          dA.mul(e)
        ),
        timerLocal: (e = 1) => (
          console.warn('TSL: timerLocal() is deprecated. Use "time" instead.'),
          dA.mul(e)
        ),
        toOutputColorSpace: ib,
        toWorkingColorSpace: iT,
        toneMapping: iw,
        toneMappingExposure: iM,
        toonOutlinePass: (e, t, r = new u.Q1f(0, 0, 0), i = 0.003, s = 1) =>
          eR(new hz(e, t, eR(r), eR(i), eR(s))),
        transformDirection: rQ,
        transformNormal: sQ,
        transformNormalToView: sK,
        transformedBentNormalView: nx,
        transformedBitangentView: ng,
        transformedBitangentWorld: nm,
        transformedClearcoatNormalView: sX,
        transformedNormalView: sq,
        transformedNormalWorld: sj,
        transformedTangentView: nl,
        transformedTangentWorld: nu,
        transmission: tw,
        transpose: rU,
        triNoise3D: dv,
        triplanarTexture: (...e) => dL(...e),
        triplanarTextures: dL,
        trunc: rB,
        tslFn: (...e) => (
          console.warn("TSL.ShaderNode: tslFn() has been renamed to Fn()."),
          eM(...e)
        ),
        uint: eV,
        uniform: tr,
        uniformArray: se,
        uniformGroup: e5,
        uniforms: (e, t) => (
          console.warn(
            "TSL.UniformArrayNode: uniforms() has been renamed to uniformArray()."
          ),
          eR(new i7(e, t))
        ),
        userData: (e, t, r) => eR(new hb(e, t, r)),
        uv: iZ,
        uvec2: ez,
        uvec3: eq,
        uvec4: eK,
        varying: ih,
        varyingProperty: tn,
        vec2: eG,
        vec3: eW,
        vec4: eX,
        vectorComponents: L,
        velocity: hS,
        vertexColor: (e) => eR(new hn(e)),
        vertexIndex: as,
        vertexStage: ic,
        vibrance: hF,
        viewZToLogarithmicDepth: a0,
        viewZToOrthographicDepth: aY,
        viewZToPerspectiveDepth: aZ,
        viewport: aL,
        viewportBottomLeft: az,
        viewportCoordinate: aV,
        viewportDepthTexture: aQ,
        viewportLinearDepth: a4,
        viewportMipTexture: aq,
        viewportResolution: aG,
        viewportSafeUV: dF,
        viewportSharedTexture: oh,
        viewportSize: aD,
        viewportTexture: aH,
        viewportTopLeft: ak,
        viewportUV: aO,
        wgsl: (e, t) => h0(e, t, "wgsl"),
        wgslFn: (e, t) => h2(e, t, "wgsl"),
        workgroupArray: (e, t) => eR(new cx("Workgroup", e, t)),
        workgroupBarrier: () => cf("workgroup").append(),
        workgroupId: ch,
        workingToColorSpace: i_,
        xor: tJ,
      });
      let p5 = new da();
      class p8 extends uk {
        constructor(e, t) {
          super(), (this.renderer = e), (this.nodes = t);
        }
        update(e, t, r) {
          let i = this.renderer,
            s = this.nodes.getBackgroundNode(e) || e.background,
            n = !1;
          if (null === s) i._clearColor.getRGB(p5), (p5.a = i._clearColor.a);
          else if (!0 === s.isColor) s.getRGB(p5), (p5.a = 1), (n = !0);
          else if (!0 === s.isNode) {
            let r = this.get(e);
            p5.copy(i._clearColor);
            let n = r.backgroundMesh;
            if (void 0 === n) {
              let e = ir(eX(s).mul(hc), {
                  getUV: () => hp.mul(sH),
                  getTextureLevel: () => hh,
                }),
                t = ar;
              t = t.setZ(t.w);
              let i = new os();
              (i.name = "Background.material"),
                (i.side = u.hsX),
                (i.depthTest = !1),
                (i.depthWrite = !1),
                (i.fog = !1),
                (i.lights = !1),
                (i.vertexNode = t),
                (i.colorNode = e),
                (r.backgroundMeshNode = e),
                (r.backgroundMesh = n = new u.eaF(new u.Gu$(1, 32, 32), i)),
                (n.frustumCulled = !1),
                (n.name = "Background.mesh"),
                (n.onBeforeRender = function (e, t, r) {
                  this.matrixWorld.copyPosition(r.matrixWorld);
                });
            }
            let a = s.getCacheKey();
            r.backgroundCacheKey !== a &&
              ((r.backgroundMeshNode.node = eX(s).mul(hc)),
              (r.backgroundMeshNode.needsUpdate = !0),
              (n.material.needsUpdate = !0),
              (r.backgroundCacheKey = a)),
              t.unshift(n, n.geometry, n.material, 0, 0, null, null);
          } else
            console.error(
              "THREE.Renderer: Unsupported background configuration.",
              s
            );
          let a = i.xr.getEnvironmentBlendMode();
          if (
            ("additive" === a
              ? p5.set(0, 0, 0, 1)
              : "alpha-blend" === a && p5.set(0, 0, 0, 0),
            !0 === i.autoClear || !0 === n)
          ) {
            let e = r.clearColorValue;
            (e.r = p5.r),
              (e.g = p5.g),
              (e.b = p5.b),
              (e.a = p5.a),
              (!0 === i.backend.isWebGLBackend || !0 === i.alpha) &&
                ((e.r *= e.a), (e.g *= e.a), (e.b *= e.a)),
              (r.depthClearValue = i._clearDepth),
              (r.stencilClearValue = i._clearStencil),
              (r.clearColor = !0 === i.autoClearColor),
              (r.clearDepth = !0 === i.autoClearDepth),
              (r.clearStencil = !0 === i.autoClearStencil);
          } else
            (r.clearColor = !1), (r.clearDepth = !1), (r.clearStencil = !1);
        }
      }
      let p9 = 0;
      class p7 {
        constructor(e = "", t = [], r = 0, i = []) {
          (this.name = e),
            (this.bindings = t),
            (this.index = r),
            (this.bindingsReference = i),
            (this.id = p9++);
        }
      }
      class ge {
        constructor(e, t, r, i, s, n, a, o, l, u = []) {
          (this.vertexShader = e),
            (this.fragmentShader = t),
            (this.computeShader = r),
            (this.transforms = u),
            (this.nodeAttributes = i),
            (this.bindings = s),
            (this.updateNodes = n),
            (this.updateBeforeNodes = a),
            (this.updateAfterNodes = o),
            (this.observer = l),
            (this.usedTimes = 0);
        }
        createBindings() {
          let e = [];
          for (let t of this.bindings)
            if (!0 !== t.bindings[0].groupNode.shared) {
              let r = new p7(t.name, [], t.index, t);
              for (let i of (e.push(r), t.bindings)) r.bindings.push(i.clone());
            } else e.push(t);
          return e;
        }
      }
      class gt {
        constructor(e, t, r = null) {
          (this.isNodeAttribute = !0),
            (this.name = e),
            (this.type = t),
            (this.node = r);
        }
      }
      class gr {
        constructor(e, t, r) {
          (this.isNodeUniform = !0),
            (this.name = e),
            (this.type = t),
            (this.node = r.getSelf());
        }
        get value() {
          return this.node.value;
        }
        set value(e) {
          this.node.value = e;
        }
        get id() {
          return this.node.id;
        }
        get groupNode() {
          return this.node.groupNode;
        }
      }
      class gi {
        constructor(e, t, r = !1, i = null) {
          (this.isNodeVar = !0),
            (this.name = e),
            (this.type = t),
            (this.readOnly = r),
            (this.count = i);
        }
      }
      class gs extends gi {
        constructor(e, t) {
          super(e, t),
            (this.needsInterpolation = !1),
            (this.isNodeVarying = !0);
        }
      }
      class gn {
        constructor(e, t, r = "") {
          (this.name = e),
            (this.type = t),
            (this.code = r),
            Object.defineProperty(this, "isNodeCode", { value: !0 });
        }
      }
      let ga = 0;
      class go {
        constructor(e = null) {
          (this.id = ga++), (this.nodesData = new WeakMap()), (this.parent = e);
        }
        getData(e) {
          let t = this.nodesData.get(e);
          return (
            void 0 === t &&
              null !== this.parent &&
              (t = this.parent.getData(e)),
            t
          );
        }
        setData(e, t) {
          this.nodesData.set(e, t);
        }
      }
      class gl {
        constructor(e, t) {
          (this.name = e), (this.members = t), (this.output = !1);
        }
      }
      class gu {
        constructor(e, t) {
          (this.name = e),
            (this.value = t),
            (this.boundary = 0),
            (this.itemSize = 0),
            (this.offset = 0);
        }
        setValue(e) {
          this.value = e;
        }
        getValue() {
          return this.value;
        }
      }
      class gd extends gu {
        constructor(e, t = 0) {
          super(e, t),
            (this.isNumberUniform = !0),
            (this.boundary = 4),
            (this.itemSize = 1);
        }
      }
      class gh extends gu {
        constructor(e, t = new u.I9Y()) {
          super(e, t),
            (this.isVector2Uniform = !0),
            (this.boundary = 8),
            (this.itemSize = 2);
        }
      }
      class gc extends gu {
        constructor(e, t = new u.Pq0()) {
          super(e, t),
            (this.isVector3Uniform = !0),
            (this.boundary = 16),
            (this.itemSize = 3);
        }
      }
      class gp extends gu {
        constructor(e, t = new u.IUQ()) {
          super(e, t),
            (this.isVector4Uniform = !0),
            (this.boundary = 16),
            (this.itemSize = 4);
        }
      }
      class gg extends gu {
        constructor(e, t = new u.Q1f()) {
          super(e, t),
            (this.isColorUniform = !0),
            (this.boundary = 16),
            (this.itemSize = 3);
        }
      }
      class gm extends gu {
        constructor(e, t = new u.k_V()) {
          super(e, t),
            (this.isMatrix2Uniform = !0),
            (this.boundary = 16),
            (this.itemSize = 4);
        }
      }
      class gf extends gu {
        constructor(e, t = new u.dwI()) {
          super(e, t),
            (this.isMatrix3Uniform = !0),
            (this.boundary = 48),
            (this.itemSize = 12);
        }
      }
      class gy extends gu {
        constructor(e, t = new u.kn4()) {
          super(e, t),
            (this.isMatrix4Uniform = !0),
            (this.boundary = 64),
            (this.itemSize = 16);
        }
      }
      class gx extends gd {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gb extends gh {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gT extends gc {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class g_ extends gp {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gv extends gg {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gN extends gm {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gS extends gf {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class gR extends gy {
        constructor(e) {
          super(e.name, e.value), (this.nodeUniform = e);
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      let gA = new WeakMap(),
        gC = new Map([
          [Int8Array, "int"],
          [Int16Array, "int"],
          [Int32Array, "int"],
          [Uint8Array, "uint"],
          [Uint16Array, "uint"],
          [Uint32Array, "uint"],
          [Float32Array, "float"],
        ]),
        gE = (e) =>
          /e/g.test(e)
            ? String(e).replace(/\+/g, "")
            : (e = Number(e)) + (e % 1 ? "" : ".0");
      class gw {
        constructor(e, t, r) {
          (this.object = e),
            (this.material = (e && e.material) || null),
            (this.geometry = (e && e.geometry) || null),
            (this.renderer = t),
            (this.parser = r),
            (this.scene = null),
            (this.camera = null),
            (this.nodes = []),
            (this.sequentialNodes = []),
            (this.updateNodes = []),
            (this.updateBeforeNodes = []),
            (this.updateAfterNodes = []),
            (this.hashNodes = {}),
            (this.observer = null),
            (this.lightsNode = null),
            (this.environmentNode = null),
            (this.fogNode = null),
            (this.clippingContext = null),
            (this.vertexShader = null),
            (this.fragmentShader = null),
            (this.computeShader = null),
            (this.flowNodes = { vertex: [], fragment: [], compute: [] }),
            (this.flowCode = { vertex: "", fragment: "", compute: "" }),
            (this.uniforms = {
              vertex: [],
              fragment: [],
              compute: [],
              index: 0,
            }),
            (this.structs = {
              vertex: [],
              fragment: [],
              compute: [],
              index: 0,
            }),
            (this.bindings = { vertex: {}, fragment: {}, compute: {} }),
            (this.bindingsIndexes = {}),
            (this.bindGroups = null),
            (this.attributes = []),
            (this.bufferAttributes = []),
            (this.varyings = []),
            (this.codes = {}),
            (this.vars = {}),
            (this.flow = { code: "" }),
            (this.chaining = []),
            (this.stack = dd()),
            (this.stacks = []),
            (this.tab = "	"),
            (this.currentFunctionNode = null),
            (this.context = { material: this.material }),
            (this.cache = new go()),
            (this.globalCache = this.cache),
            (this.flowsData = new WeakMap()),
            (this.shaderStage = null),
            (this.buildStage = null),
            (this.useComparisonMethod = !1);
        }
        getBindGroupsCache() {
          let e = gA.get(this.renderer);
          return void 0 === e && ((e = new uL()), gA.set(this.renderer, e)), e;
        }
        createRenderTarget(e, t, r) {
          return new u.O0B(e, t, r);
        }
        createCubeRenderTarget(e, t) {
          return new ob(e, t);
        }
        includes(e) {
          return this.nodes.includes(e);
        }
        getOutputStructName() {}
        _getBindGroup(e, t) {
          let r,
            i = this.getBindGroupsCache(),
            s = [],
            n = !0;
          for (let e of t) s.push(e), (n = n && !0 !== e.groupNode.shared);
          return (
            n
              ? void 0 === (r = i.get(s)) &&
                ((r = new p7(e, s, this.bindingsIndexes[e].group, s)),
                i.set(s, r))
              : (r = new p7(e, s, this.bindingsIndexes[e].group, s)),
            r
          );
        }
        getBindGroupArray(e, t) {
          let r = this.bindings[t],
            i = r[e];
          return (
            void 0 === i &&
              (void 0 === this.bindingsIndexes[e] &&
                (this.bindingsIndexes[e] = {
                  binding: 0,
                  group: Object.keys(this.bindingsIndexes).length,
                }),
              (r[e] = i = [])),
            i
          );
        }
        getBindings() {
          let e = this.bindGroups;
          if (null === e) {
            let t = {},
              r = this.bindings;
            for (let e of P)
              for (let i in r[e]) {
                let s = r[e][i];
                (t[i] || (t[i] = [])).push(...s);
              }
            for (let r in ((e = []), t)) {
              let i = t[r],
                s = this._getBindGroup(r, i);
              e.push(s);
            }
            this.bindGroups = e;
          }
          return e;
        }
        sortBindingGroups() {
          let e = this.getBindings();
          e.sort(
            (e, t) =>
              e.bindings[0].groupNode.order - t.bindings[0].groupNode.order
          );
          for (let t = 0; t < e.length; t++) {
            let r = e[t];
            (this.bindingsIndexes[r.name].group = t), (r.index = t);
          }
        }
        setHashNode(e, t) {
          this.hashNodes[t] = e;
        }
        addNode(e) {
          !1 === this.nodes.includes(e) &&
            (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
        }
        addSequentialNode(e) {
          !1 === this.sequentialNodes.includes(e) &&
            this.sequentialNodes.push(e);
        }
        buildUpdateNodes() {
          for (let e of this.nodes)
            e.getUpdateType() !== M.NONE && this.updateNodes.push(e.getSelf());
          for (let e of this.sequentialNodes) {
            let t = e.getUpdateBeforeType(),
              r = e.getUpdateAfterType();
            t !== M.NONE && this.updateBeforeNodes.push(e.getSelf()),
              r !== M.NONE && this.updateAfterNodes.push(e.getSelf());
          }
        }
        get currentNode() {
          return this.chaining[this.chaining.length - 1];
        }
        isFilteredTexture(e) {
          return (
            e.magFilter === u.k6q ||
            e.magFilter === u.kRr ||
            e.magFilter === u.Cfg ||
            e.magFilter === u.$_I ||
            e.minFilter === u.k6q ||
            e.minFilter === u.kRr ||
            e.minFilter === u.Cfg ||
            e.minFilter === u.$_I
          );
        }
        addChain(e) {
          this.chaining.push(e);
        }
        removeChain(e) {
          if (this.chaining.pop() !== e)
            throw Error("NodeBuilder: Invalid node chaining!");
        }
        getMethod(e) {
          return e;
        }
        getNodeFromHash(e) {
          return this.hashNodes[e];
        }
        addFlow(e, t) {
          return this.flowNodes[e].push(t), t;
        }
        setContext(e) {
          this.context = e;
        }
        getContext() {
          return this.context;
        }
        getSharedContext() {
          return { ...this.context }, this.context;
        }
        setCache(e) {
          this.cache = e;
        }
        getCache() {
          return this.cache;
        }
        getCacheFromNode(e, t = !0) {
          let r = this.getDataFromNode(e);
          return (
            void 0 === r.cache &&
              (r.cache = new go(t ? this.getCache() : null)),
            r.cache
          );
        }
        isAvailable() {
          return !1;
        }
        getVertexIndex() {
          console.warn("Abstract function.");
        }
        getInstanceIndex() {
          console.warn("Abstract function.");
        }
        getDrawIndex() {
          console.warn("Abstract function.");
        }
        getFrontFacing() {
          console.warn("Abstract function.");
        }
        getFragCoord() {
          console.warn("Abstract function.");
        }
        isFlipY() {
          return !1;
        }
        increaseUsage(e) {
          let t = this.getDataFromNode(e);
          return (
            (t.usageCount = void 0 === t.usageCount ? 1 : t.usageCount + 1),
            t.usageCount
          );
        }
        generateTexture() {
          console.warn("Abstract function.");
        }
        generateTextureLod() {
          console.warn("Abstract function.");
        }
        generateArrayDeclaration(e, t) {
          return this.getType(e) + "[ " + t + " ]";
        }
        generateArray(e, t, r = null) {
          let i = this.generateArrayDeclaration(e, t) + "( ";
          for (let s = 0; s < t; s++) {
            let n = r ? r[s] : null;
            null !== n ? (i += n.build(this, e)) : (i += this.generateConst(e)),
              s < t - 1 && (i += ", ");
          }
          return i + " )";
        }
        generateStruct(e, t, r = null) {
          let i = [];
          for (let e of t) {
            let { name: t, type: s } = e;
            r && r[t] && r[t].isNode
              ? i.push(r[t].build(this, s))
              : i.push(this.generateConst(s));
          }
          return e + "( " + i.join(", ") + " )";
        }
        generateConst(e, t = null) {
          if (
            (null === t &&
              ("float" === e || "int" === e || "uint" === e
                ? (t = 0)
                : "bool" === e
                ? (t = !1)
                : "color" === e
                ? (t = new u.Q1f())
                : "vec2" === e
                ? (t = new u.I9Y())
                : "vec3" === e
                ? (t = new u.Pq0())
                : "vec4" === e && (t = new u.IUQ())),
            "float" === e)
          )
            return gE(t);
          if ("int" === e) return `${Math.round(t)}`;
          if ("uint" === e) return t >= 0 ? `${Math.round(t)}u` : "0u";
          if ("bool" === e) return t ? "true" : "false";
          if ("color" === e)
            return `${this.getType("vec3")}( ${gE(t.r)}, ${gE(t.g)}, ${gE(
              t.b
            )} )`;
          let r = this.getTypeLength(e),
            i = this.getComponentType(e),
            s = (e) => this.generateConst(i, e);
          if (2 === r) return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
          if (3 === r)
            return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
          if (4 === r && "mat2" !== e)
            return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(
              t.w
            )} )`;
          if (r >= 4 && t && (t.isMatrix2 || t.isMatrix3 || t.isMatrix4))
            return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
          if (r > 4) return `${this.getType(e)}()`;
          throw Error(
            `NodeBuilder: Type '${e}' not found in generate constant attempt.`
          );
        }
        getType(e) {
          return "color" === e ? "vec3" : e;
        }
        hasGeometryAttribute(e) {
          return this.geometry && void 0 !== this.geometry.getAttribute(e);
        }
        getAttribute(e, t) {
          let r = this.attributes;
          for (let t of r) if (t.name === e) return t;
          let i = new gt(e, t);
          return r.push(i), i;
        }
        getPropertyName(e) {
          return e.name;
        }
        isVector(e) {
          return /vec\d/.test(e);
        }
        isMatrix(e) {
          return /mat\d/.test(e);
        }
        isReference(e) {
          return (
            "void" === e ||
            "property" === e ||
            "sampler" === e ||
            "texture" === e ||
            "cubeTexture" === e ||
            "storageTexture" === e ||
            "depthTexture" === e ||
            "texture3D" === e
          );
        }
        needsToWorkingColorSpace() {
          return !1;
        }
        getComponentTypeFromTexture(e) {
          let t = e.type;
          if (e.isDataTexture) {
            if (t === u.Yuy) return "int";
            if (t === u.bkx) return "uint";
          }
          return "float";
        }
        getElementType(e) {
          return "mat2" === e
            ? "vec2"
            : "mat3" === e
            ? "vec3"
            : "mat4" === e
            ? "vec4"
            : this.getComponentType(e);
        }
        getComponentType(e) {
          if (
            "float" === (e = this.getVectorType(e)) ||
            "bool" === e ||
            "int" === e ||
            "uint" === e
          )
            return e;
          let t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
          return null === t
            ? null
            : "b" === t[1]
            ? "bool"
            : "i" === t[1]
            ? "int"
            : "u" === t[1]
            ? "uint"
            : "float";
        }
        getVectorType(e) {
          return "color" === e
            ? "vec3"
            : "texture" === e ||
              "cubeTexture" === e ||
              "storageTexture" === e ||
              "texture3D" === e
            ? "vec4"
            : e;
        }
        getTypeFromLength(e, t = "float") {
          if (1 === e) return t;
          let r = T(e),
            i = "float" === t ? "" : t[0];
          return !0 === /mat2/.test(t) && (r = r.replace("vec", "mat")), i + r;
        }
        getTypeFromArray(e) {
          return gC.get(e.constructor);
        }
        getTypeFromAttribute(e) {
          let t,
            r = e;
          e.isInterleavedBufferAttribute && (r = e.data);
          let i = r.array,
            s = e.itemSize,
            n = e.normalized;
          return (
            e instanceof u.Oax || !0 === n || (t = this.getTypeFromArray(i)),
            this.getTypeFromLength(s, t)
          );
        }
        getTypeLength(e) {
          let t = this.getVectorType(e),
            r = /vec([2-4])/.exec(t);
          return null !== r
            ? Number(r[1])
            : "float" === t || "bool" === t || "int" === t || "uint" === t
            ? 1
            : !0 === /mat2/.test(e)
            ? 4
            : !0 === /mat3/.test(e)
            ? 9
            : 16 * (!0 === /mat4/.test(e));
        }
        getVectorFromMatrix(e) {
          return e.replace("mat", "vec");
        }
        changeComponentType(e, t) {
          return this.getTypeFromLength(this.getTypeLength(e), t);
        }
        getIntegerType(e) {
          let t = this.getComponentType(e);
          return "int" === t || "uint" === t
            ? e
            : this.changeComponentType(e, "int");
        }
        addStack() {
          return (
            (this.stack = dd(this.stack)),
            this.stacks.push(eF() || this.stack),
            eB(this.stack),
            this.stack
          );
        }
        removeStack() {
          let e = this.stack;
          return (this.stack = e.parent), eB(this.stacks.pop()), e;
        }
        getDataFromNode(e, t = this.shaderStage, r = null) {
          let i = (r =
            null === r
              ? e.isGlobal(this)
                ? this.globalCache
                : this.cache
              : r).getData(e);
          return (
            void 0 === i && ((i = {}), r.setData(e, i)),
            void 0 === i[t] && (i[t] = {}),
            i[t]
          );
        }
        getNodeProperties(e, t = "any") {
          let r = this.getDataFromNode(e, t);
          return r.properties || (r.properties = { outputNode: null });
        }
        getBufferAttributeFromNode(e, t) {
          let r = this.getDataFromNode(e),
            i = r.bufferAttribute;
          return (
            void 0 === i &&
              ((i = new gt("nodeAttribute" + this.uniforms.index++, t, e)),
              this.bufferAttributes.push(i),
              (r.bufferAttribute = i)),
            i
          );
        }
        getStructTypeFromNode(e, t, r = null, i = this.shaderStage) {
          let s = this.getDataFromNode(e, i, this.globalCache),
            n = s.structType;
          if (void 0 === n) {
            let e = this.structs.index++;
            null === r && (r = "StructType" + e),
              (n = new gl(r, t)),
              this.structs[i].push(n),
              (s.structType = n);
          }
          return n;
        }
        getOutputStructTypeFromNode(e, t) {
          let r = this.getStructTypeFromNode(e, t, "OutputType", "fragment");
          return (r.output = !0), r;
        }
        getUniformFromNode(e, t, r = this.shaderStage, i = null) {
          let s = this.getDataFromNode(e, r, this.globalCache),
            n = s.uniform;
          if (void 0 === n) {
            let a = this.uniforms.index++;
            (n = new gr(i || "nodeUniform" + a, t, e)),
              this.uniforms[r].push(n),
              (s.uniform = n);
          }
          return n;
        }
        getArrayCount(e) {
          let t = null;
          return (
            e.isArrayNode
              ? (t = e.count)
              : e.isVarNode && e.node.isArrayNode && (t = e.node.count),
            t
          );
        }
        getVarFromNode(
          e,
          t = null,
          r = e.getNodeType(this),
          i = this.shaderStage,
          s = !1
        ) {
          let n = this.getDataFromNode(e, i),
            a = n.variable;
          if (void 0 === a) {
            let o = s ? "_const" : "_var",
              l = this.vars[i] || (this.vars[i] = []),
              u = this.vars[o] || (this.vars[o] = 0);
            null === t &&
              ((t = (s ? "nodeConst" : "nodeVar") + u), this.vars[o]++);
            let d = this.getArrayCount(e);
            (a = new gi(t, r, s, d)), s || l.push(a), (n.variable = a);
          }
          return a;
        }
        isDeterministic(e) {
          if (e.isMathNode)
            return (
              this.isDeterministic(e.aNode) &&
              (!e.bNode || this.isDeterministic(e.bNode)) &&
              (!e.cNode || this.isDeterministic(e.cNode))
            );
          if (e.isOperatorNode)
            return (
              this.isDeterministic(e.aNode) &&
              (!e.bNode || this.isDeterministic(e.bNode))
            );
          if (e.isArrayNode) {
            if (null !== e.values) {
              for (let t of e.values) if (!this.isDeterministic(t)) return !1;
            }
            return !0;
          }
          return !!e.isConstNode || !1;
        }
        getVaryingFromNode(e, t = null, r = e.getNodeType(this)) {
          let i = this.getDataFromNode(e, "any"),
            s = i.varying;
          if (void 0 === s) {
            let e = this.varyings,
              n = e.length;
            null === t && (t = "nodeVarying" + n),
              (s = new gs(t, r)),
              e.push(s),
              (i.varying = s);
          }
          return s;
        }
        getCodeFromNode(e, t, r = this.shaderStage) {
          let i = this.getDataFromNode(e),
            s = i.code;
          if (void 0 === s) {
            let e = this.codes[r] || (this.codes[r] = []);
            (s = new gn("nodeCode" + e.length, t)), e.push(s), (i.code = s);
          }
          return s;
        }
        addFlowCodeHierarchy(e, t) {
          let { flowCodes: r, flowCodeBlock: i } = this.getDataFromNode(e),
            s = !0,
            n = t;
          for (; n; ) {
            if (!0 === i.get(n)) {
              s = !1;
              break;
            }
            n = this.getDataFromNode(n).parentNodeBlock;
          }
          if (s) for (let e of r) this.addLineFlowCode(e);
        }
        addLineFlowCodeBlock(e, t, r) {
          let i = this.getDataFromNode(e),
            s = i.flowCodes || (i.flowCodes = []),
            n = i.flowCodeBlock || (i.flowCodeBlock = new WeakMap());
          s.push(t), n.set(r, !0);
        }
        addLineFlowCode(e, t = null) {
          return (
            "" === e ||
              (null !== t &&
                this.context.nodeBlock &&
                this.addLineFlowCodeBlock(t, e, this.context.nodeBlock),
              (e = this.tab + e),
              /;\s*$/.test(e) || (e += ";\n"),
              (this.flow.code += e)),
            this
          );
        }
        addFlowCode(e) {
          return (this.flow.code += e), this;
        }
        addFlowTab() {
          return (this.tab += "	"), this;
        }
        removeFlowTab() {
          return (this.tab = this.tab.slice(0, -1)), this;
        }
        getFlowData(e) {
          return this.flowsData.get(e);
        }
        flowNode(e) {
          let t = e.getNodeType(this),
            r = this.flowChildNode(e, t);
          return this.flowsData.set(e, r), r;
        }
        addInclude(e) {
          null !== this.currentFunctionNode &&
            this.currentFunctionNode.includes.push(e);
        }
        buildFunctionNode(e) {
          let t = new h1(),
            r = this.currentFunctionNode;
          return (
            (this.currentFunctionNode = t),
            (t.code = this.buildFunctionCode(e)),
            (this.currentFunctionNode = r),
            t
          );
        }
        flowShaderNode(e) {
          let t = e.layout,
            r = {
              [Symbol.iterator]() {
                let e = 0,
                  t = Object.values(this);
                return { next: () => ({ value: t[e], done: e++ >= t.length }) };
              },
            };
          for (let e of t.inputs) r[e.name] = new dl(e.type, e.name);
          e.layout = null;
          let i = e.call(r),
            s = this.flowStagesNode(i, t.type);
          return (e.layout = t), s;
        }
        flowStagesNode(e, t = null) {
          let r = this.flow,
            i = this.vars,
            s = this.cache,
            n = this.buildStage,
            a = this.stack,
            o = { code: "" };
          for (let r of ((this.flow = o),
          (this.vars = {}),
          (this.cache = new go()),
          (this.stack = dd()),
          I))
            this.setBuildStage(r), (o.result = e.build(this, t));
          return (
            (o.vars = this.getVars(this.shaderStage)),
            (this.flow = r),
            (this.vars = i),
            (this.cache = s),
            (this.stack = a),
            this.setBuildStage(n),
            o
          );
        }
        getFunctionOperator() {
          return null;
        }
        flowChildNode(e, t = null) {
          let r = this.flow,
            i = { code: "" };
          return (
            (this.flow = i), (i.result = e.build(this, t)), (this.flow = r), i
          );
        }
        flowNodeFromShaderStage(e, t, r = null, i = null) {
          let s = this.shaderStage;
          this.setShaderStage(e);
          let n = this.flowChildNode(t, r);
          return (
            null !== i &&
              (n.code += `${this.tab + i} = ${n.result};
`),
            (this.flowCode[e] = this.flowCode[e] + n.code),
            this.setShaderStage(s),
            n
          );
        }
        getAttributesArray() {
          return this.attributes.concat(this.bufferAttributes);
        }
        getAttributes() {
          console.warn("Abstract function.");
        }
        getVaryings() {
          console.warn("Abstract function.");
        }
        getVar(e, t, r = null) {
          return `${
            null !== r ? this.generateArrayDeclaration(e, r) : this.getType(e)
          } ${t}`;
        }
        getVars(e) {
          let t = "",
            r = this.vars[e];
          if (void 0 !== r)
            for (let e of r) t += `${this.getVar(e.type, e.name)}; `;
          return t;
        }
        getUniforms() {
          console.warn("Abstract function.");
        }
        getCodes(e) {
          let t = this.codes[e],
            r = "";
          if (void 0 !== t) for (let e of t) r += e.code + "\n";
          return r;
        }
        getHash() {
          return this.vertexShader + this.fragmentShader + this.computeShader;
        }
        setShaderStage(e) {
          this.shaderStage = e;
        }
        getShaderStage() {
          return this.shaderStage;
        }
        setBuildStage(e) {
          this.buildStage = e;
        }
        getBuildStage() {
          return this.buildStage;
        }
        buildCode() {
          console.warn("Abstract function.");
        }
        build() {
          let { object: e, material: t, renderer: r } = this;
          if (null !== t) {
            let e = r.library.fromMaterial(t);
            null === e &&
              (console.error(
                `NodeMaterial: Material "${t.type}" is not compatible.`
              ),
              (e = new os())),
              e.build(this);
          } else this.addFlow("compute", e);
          for (let e of I)
            for (let t of (this.setBuildStage(e),
            this.context.vertex &&
              this.context.vertex.isNode &&
              this.flowNodeFromShaderStage("vertex", this.context.vertex),
            P))
              for (let r of (this.setShaderStage(t), this.flowNodes[t]))
                "generate" === e ? this.flowNode(r) : r.build(this);
          return (
            this.setBuildStage(null),
            this.setShaderStage(null),
            this.buildCode(),
            this.buildUpdateNodes(),
            this
          );
        }
        getNodeUniform(e, t) {
          if ("float" === t || "int" === t || "uint" === t) return new gx(e);
          if ("vec2" === t || "ivec2" === t || "uvec2" === t) return new gb(e);
          if ("vec3" === t || "ivec3" === t || "uvec3" === t) return new gT(e);
          if ("vec4" === t || "ivec4" === t || "uvec4" === t) return new g_(e);
          if ("color" === t) return new gv(e);
          if ("mat2" === t) return new gN(e);
          if ("mat3" === t) return new gS(e);
          if ("mat4" === t) return new gR(e);
          throw Error(`Uniform "${t}" not declared.`);
        }
        format(e, t, r) {
          if (
            ((t = this.getVectorType(t)),
            (r = this.getVectorType(r)),
            t === r || null === r || this.isReference(r))
          )
            return e;
          let i = this.getTypeLength(t),
            s = this.getTypeLength(r);
          return 16 === i && 9 === s
            ? `${this.getType(r)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)`
            : 9 === i && 4 === s
            ? `${this.getType(r)}(${e}[0].xy, ${e}[1].xy)`
            : i > 4 || s > 4 || 0 === s
            ? e
            : i === s
            ? `${this.getType(r)}( ${e} )`
            : i > s
            ? this.format(
                `${e}.${"xyz".slice(0, s)}`,
                this.getTypeFromLength(s, this.getComponentType(t)),
                r
              )
            : 4 === s && i > 1
            ? `${this.getType(r)}( ${this.format(e, t, "vec3")}, 1.0 )`
            : 2 === i
            ? `${this.getType(r)}( ${this.format(e, t, "vec2")}, 0.0 )`
            : (1 === i &&
                s > 1 &&
                t !== this.getComponentType(r) &&
                (e = `${this.getType(this.getComponentType(r))}( ${e} )`),
              `${this.getType(r)}( ${e} )`);
        }
        getSignature() {
          return `// Three.js r${u.sPf} - Node System
`;
        }
        createNodeMaterial(e = "NodeMaterial") {
          throw Error(
            `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`
          );
        }
      }
      class gM {
        constructor() {
          (this.time = 0),
            (this.deltaTime = 0),
            (this.frameId = 0),
            (this.renderId = 0),
            (this.updateMap = new WeakMap()),
            (this.updateBeforeMap = new WeakMap()),
            (this.updateAfterMap = new WeakMap()),
            (this.renderer = null),
            (this.material = null),
            (this.camera = null),
            (this.object = null),
            (this.scene = null);
        }
        _getMaps(e, t) {
          let r = e.get(t);
          return (
            void 0 === r &&
              ((r = { renderMap: new WeakMap(), frameMap: new WeakMap() }),
              e.set(t, r)),
            r
          );
        }
        updateBeforeNode(e) {
          let t = e.getUpdateBeforeType(),
            r = e.updateReference(this);
          if (t === M.FRAME) {
            let { frameMap: t } = this._getMaps(this.updateBeforeMap, r);
            t.get(r) !== this.frameId &&
              !1 !== e.updateBefore(this) &&
              t.set(r, this.frameId);
          } else if (t === M.RENDER) {
            let { renderMap: t } = this._getMaps(this.updateBeforeMap, r);
            t.get(r) !== this.renderId &&
              !1 !== e.updateBefore(this) &&
              t.set(r, this.renderId);
          } else t === M.OBJECT && e.updateBefore(this);
        }
        updateAfterNode(e) {
          let t = e.getUpdateAfterType(),
            r = e.updateReference(this);
          if (t === M.FRAME) {
            let { frameMap: t } = this._getMaps(this.updateAfterMap, r);
            t.get(r) !== this.frameId &&
              !1 !== e.updateAfter(this) &&
              t.set(r, this.frameId);
          } else if (t === M.RENDER) {
            let { renderMap: t } = this._getMaps(this.updateAfterMap, r);
            t.get(r) !== this.renderId &&
              !1 !== e.updateAfter(this) &&
              t.set(r, this.renderId);
          } else t === M.OBJECT && e.updateAfter(this);
        }
        updateNode(e) {
          let t = e.getUpdateType(),
            r = e.updateReference(this);
          if (t === M.FRAME) {
            let { frameMap: t } = this._getMaps(this.updateMap, r);
            t.get(r) !== this.frameId &&
              !1 !== e.update(this) &&
              t.set(r, this.frameId);
          } else if (t === M.RENDER) {
            let { renderMap: t } = this._getMaps(this.updateMap, r);
            t.get(r) !== this.renderId &&
              !1 !== e.update(this) &&
              t.set(r, this.renderId);
          } else t === M.OBJECT && e.update(this);
        }
        update() {
          this.frameId++,
            void 0 === this.lastTime && (this.lastTime = performance.now()),
            (this.deltaTime = (performance.now() - this.lastTime) / 1e3),
            (this.lastTime = performance.now()),
            (this.time += this.deltaTime);
        }
      }
      class gB {
        constructor(e, t, r = null, i = "", s = !1) {
          (this.type = e),
            (this.name = t),
            (this.count = r),
            (this.qualifier = i),
            (this.isConst = s);
        }
      }
      gB.isNodeFunctionInput = !0;
      class gF extends ps {
        static get type() {
          return "DirectionalLightNode";
        }
        constructor(e = null) {
          super(e);
        }
        setupDirect() {
          let e = this.colorNode;
          return { lightDirection: cE(this.light), lightColor: e };
        }
      }
      let gU = new u.kn4(),
        gI = new u.kn4(),
        gP = null;
      class gL extends ps {
        static get type() {
          return "RectAreaLightNode";
        }
        constructor(e = null) {
          super(e),
            (this.halfHeight = tr(new u.Pq0()).setGroup(e7)),
            (this.halfWidth = tr(new u.Pq0()).setGroup(e7)),
            (this.updateType = M.RENDER);
        }
        update(e) {
          super.update(e);
          let { light: t } = this,
            r = e.camera.matrixWorldInverse;
          gI.identity(),
            gU.copy(t.matrixWorld),
            gU.premultiply(r),
            gI.extractRotation(gU),
            this.halfWidth.value.set(0.5 * t.width, 0, 0),
            this.halfHeight.value.set(0, 0.5 * t.height, 0),
            this.halfWidth.value.applyMatrix4(gI),
            this.halfHeight.value.applyMatrix4(gI);
        }
        setupDirectRectArea(e) {
          let t, r;
          e.isAvailable("float32Filterable")
            ? ((t = i4(gP.LTC_FLOAT_1)), (r = i4(gP.LTC_FLOAT_2)))
            : ((t = i4(gP.LTC_HALF_1)), (r = i4(gP.LTC_HALF_2)));
          let { colorNode: i, light: s } = this;
          return {
            lightColor: i,
            lightPosition: cC(s),
            halfWidth: this.halfWidth,
            halfHeight: this.halfHeight,
            ltc_1: t,
            ltc_2: r,
          };
        }
        static setLTC(e) {
          gP = e;
        }
      }
      class gD extends ps {
        static get type() {
          return "SpotLightNode";
        }
        constructor(e = null) {
          super(e),
            (this.coneCosNode = tr(0).setGroup(e7)),
            (this.penumbraCosNode = tr(0).setGroup(e7)),
            (this.cutoffDistanceNode = tr(0).setGroup(e7)),
            (this.decayExponentNode = tr(0).setGroup(e7));
        }
        update(e) {
          super.update(e);
          let { light: t } = this;
          (this.coneCosNode.value = Math.cos(t.angle)),
            (this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra))),
            (this.cutoffDistanceNode.value = t.distance),
            (this.decayExponentNode.value = t.decay);
        }
        getSpotAttenuation(e) {
          let { coneCosNode: t, penumbraCosNode: r } = this;
          return r2(t, r, e);
        }
        setupDirect(e) {
          let {
              colorNode: t,
              cutoffDistanceNode: r,
              decayExponentNode: i,
              light: s,
            } = this,
            n = this.getLightVector(e),
            a = n.normalize(),
            o = a.dot(cE(s)),
            l = this.getSpotAttenuation(o),
            u = pn({
              lightDistance: n.length(),
              cutoffDistance: r,
              decayExponent: i,
            }),
            d = t.mul(l).mul(u);
          if (s.map) {
            let t = cS(s, e.context.positionWorld),
              r = i4(s.map, t.xy).onRenderUpdate(() => s.map);
            d = t.mul(2).sub(1).abs().lessThan(1).all().select(d.mul(r), d);
          }
          return { lightColor: d, lightDirection: a };
        }
      }
      class gV extends gD {
        static get type() {
          return "IESSpotLightNode";
        }
        getSpotAttenuation(e) {
          let t = this.light.iesMap,
            r = null;
          return t && !0 === t.isTexture
            ? i4(t, eG(e.acos().mul(1 / Math.PI), 0), 0).r
            : super.getSpotAttenuation(e);
        }
      }
      class gO extends ps {
        static get type() {
          return "AmbientLightNode";
        }
        constructor(e = null) {
          super(e);
        }
        setup({ context: e }) {
          e.irradiance.addAssign(this.colorNode);
        }
      }
      class gG extends ps {
        static get type() {
          return "HemisphereLightNode";
        }
        constructor(e = null) {
          super(e),
            (this.lightPositionNode = cR(e)),
            (this.lightDirectionNode = this.lightPositionNode.normalize()),
            (this.groundColorNode = tr(new u.Q1f()).setGroup(e7));
        }
        update(e) {
          let { light: t } = this;
          super.update(e),
            (this.lightPositionNode.object3d = t),
            this.groundColorNode.value
              .copy(t.groundColor)
              .multiplyScalar(t.intensity);
        }
        setup(e) {
          let {
              colorNode: t,
              groundColorNode: r,
              lightDirectionNode: i,
            } = this,
            s = rZ(r, t, sW.dot(i).mul(0.5).add(0.5));
          e.context.irradiance.addAssign(s);
        }
      }
      class gk extends ps {
        static get type() {
          return "LightProbeNode";
        }
        constructor(e = null) {
          super(e);
          let t = [];
          for (let e = 0; e < 9; e++) t.push(new u.Pq0());
          this.lightProbe = se(t);
        }
        update(e) {
          let { light: t } = this;
          super.update(e);
          for (let e = 0; e < 9; e++)
            this.lightProbe.array[e]
              .copy(t.sh.coefficients[e])
              .multiplyScalar(t.intensity);
        }
        setup(e) {
          let t = p4(sH, this.lightProbe);
          e.context.irradiance.addAssign(t);
        }
      }
      class gz {
        parseFunction() {
          console.warn("Abstract function.");
        }
      }
      class g$ {
        constructor(e, t, r = "", i = "") {
          (this.type = e),
            (this.inputs = t),
            (this.name = r),
            (this.precision = i);
        }
        getCode() {
          console.warn("Abstract function.");
        }
      }
      g$.isNodeFunction = !0;
      let gW =
          /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,
        gH = /[a-z_0-9]+/gi,
        gq = "#pragma main",
        gj = (e) => {
          let t = (e = e.trim()).indexOf(gq),
            r = -1 !== t ? e.slice(t + gq.length) : e,
            i = r.match(gW);
          if (null !== i && 5 === i.length) {
            let s = i[4],
              n = [],
              a = null;
            for (; null !== (a = gH.exec(s)); ) n.push(a);
            let o = [],
              l = 0;
            for (; l < n.length; ) {
              let e = "const" === n[l][0];
              !0 === e && l++;
              let t = n[l][0];
              "in" === t || "out" === t || "inout" === t ? l++ : (t = "");
              let r = n[l++][0],
                i = Number.parseInt(n[l][0]);
              !1 === Number.isNaN(i) ? l++ : (i = null);
              let s = n[l++][0];
              o.push(new gB(r, s, i, t, e));
            }
            let u = r.substring(i[0].length),
              d = void 0 !== i[3] ? i[3] : "",
              h = i[2];
            return {
              type: h,
              inputs: o,
              name: d,
              precision: void 0 !== i[1] ? i[1] : "",
              inputsCode: s,
              blockCode: u,
              headerCode: -1 !== t ? e.slice(0, t) : "",
            };
          }
          throw Error("FunctionNode: Function is not a GLSL code.");
        };
      class gX extends g$ {
        constructor(e) {
          let {
            type: t,
            inputs: r,
            name: i,
            precision: s,
            inputsCode: n,
            blockCode: a,
            headerCode: o,
          } = gj(e);
          super(t, r, i, s),
            (this.inputsCode = n),
            (this.blockCode = a),
            (this.headerCode = o);
        }
        getCode(e = this.name) {
          let t,
            r = this.blockCode;
          if ("" !== r) {
            let { type: i, inputsCode: s, headerCode: n, precision: a } = this,
              o = `${i} ${e} ( ${s.trim()} )`;
            "" !== a && (o = `${a} ${o}`), (t = n + o + r);
          } else t = "";
          return t;
        }
      }
      class gQ extends gz {
        parseFunction(e) {
          return new gX(e);
        }
      }
      let gK = new WeakMap(),
        gY = [],
        gZ = [];
      class gJ extends uk {
        constructor(e, t) {
          super(),
            (this.renderer = e),
            (this.backend = t),
            (this.nodeFrame = new gM()),
            (this.nodeBuilderCache = new Map()),
            (this.callHashCache = new uL()),
            (this.groupsData = new uL()),
            (this.cacheLib = {});
        }
        updateGroup(e) {
          let t = e.groupNode,
            r = t.name;
          if (r === te.name) return !0;
          if (r === e7.name) {
            let t = this.get(e),
              r = this.nodeFrame.renderId;
            return t.renderId !== r && ((t.renderId = r), !0);
          }
          if (r === e9.name) {
            let t = this.get(e),
              r = this.nodeFrame.frameId;
            return t.frameId !== r && ((t.frameId = r), !0);
          }
          (gY[0] = t), (gY[1] = e);
          let i = this.groupsData.get(gY);
          return (
            void 0 === i && this.groupsData.set(gY, (i = {})),
            (gY.length = 0),
            i.version !== t.version && ((i.version = t.version), !0)
          );
        }
        getForRenderCacheKey(e) {
          return e.initialCacheKey;
        }
        getForRender(e) {
          let t = this.get(e),
            r = t.nodeBuilderState;
          if (void 0 === r) {
            let { nodeBuilderCache: i } = this,
              s = this.getForRenderCacheKey(e);
            if (void 0 === (r = i.get(s))) {
              let t = this.backend.createNodeBuilder(e.object, this.renderer);
              (t.scene = e.scene),
                (t.material = e.material),
                (t.camera = e.camera),
                (t.context.material = e.material),
                (t.lightsNode = e.lightsNode),
                (t.environmentNode = this.getEnvironmentNode(e.scene)),
                (t.fogNode = this.getFogNode(e.scene)),
                (t.clippingContext = e.clippingContext),
                t.build(),
                (r = this._createNodeBuilderState(t)),
                i.set(s, r);
            }
            r.usedTimes++, (t.nodeBuilderState = r);
          }
          return r;
        }
        delete(e) {
          if (e.isRenderObject) {
            let t = this.get(e).nodeBuilderState;
            t.usedTimes--,
              0 === t.usedTimes &&
                this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
          }
          return super.delete(e);
        }
        getForCompute(e) {
          let t = this.get(e),
            r = t.nodeBuilderState;
          if (void 0 === r) {
            let i = this.backend.createNodeBuilder(e, this.renderer);
            i.build(),
              (t.nodeBuilderState = r = this._createNodeBuilderState(i));
          }
          return r;
        }
        _createNodeBuilderState(e) {
          return new ge(
            e.vertexShader,
            e.fragmentShader,
            e.computeShader,
            e.getAttributesArray(),
            e.getBindings(),
            e.updateNodes,
            e.updateBeforeNodes,
            e.updateAfterNodes,
            e.observer,
            e.transforms
          );
        }
        getEnvironmentNode(e) {
          this.updateEnvironment(e);
          let t = null;
          if (e.environmentNode && e.environmentNode.isNode)
            t = e.environmentNode;
          else {
            let r = this.get(e);
            r.environmentNode && (t = r.environmentNode);
          }
          return t;
        }
        getBackgroundNode(e) {
          this.updateBackground(e);
          let t = null;
          if (e.backgroundNode && e.backgroundNode.isNode) t = e.backgroundNode;
          else {
            let r = this.get(e);
            r.backgroundNode && (t = r.backgroundNode);
          }
          return t;
        }
        getFogNode(e) {
          return this.updateFog(e), e.fogNode || this.get(e).fogNode || null;
        }
        getCacheKey(e, t) {
          (gY[0] = e), (gY[1] = t);
          let r = this.renderer.info.calls,
            i = this.callHashCache.get(gY) || {};
          if (i.callId !== r) {
            let s = this.getEnvironmentNode(e),
              n = this.getFogNode(e);
            t && gZ.push(t.getCacheKey(!0)),
              s && gZ.push(s.getCacheKey()),
              n && gZ.push(n.getCacheKey()),
              gZ.push(+!!this.renderer.shadowMap.enabled),
              (i.callId = r),
              (i.cacheKey = g(gZ)),
              this.callHashCache.set(gY, i),
              (gZ.length = 0);
          }
          return (gY.length = 0), i.cacheKey;
        }
        get isToneMappingState() {
          return !this.renderer.getRenderTarget();
        }
        updateBackground(e) {
          let t = this.get(e),
            r = e.background;
          if (r) {
            let i =
              (0 === e.backgroundBlurriness && t.backgroundBlurriness > 0) ||
              (e.backgroundBlurriness > 0 && 0 === t.backgroundBlurriness);
            (t.background !== r || i) &&
              ((t.backgroundNode = this.getCacheNode(
                "background",
                r,
                () => {
                  if (
                    !0 === r.isCubeTexture ||
                    r.mapping === u.wfO ||
                    r.mapping === u.uV5 ||
                    r.mapping === u.Om
                  )
                    if (e.backgroundBlurriness > 0 || r.mapping === u.Om)
                      return ur(r);
                    else {
                      let e;
                      return oS(!0 === r.isCubeTexture ? s8(r) : i4(r));
                    }
                  if (!0 === r.isTexture)
                    return i4(r, aU.flipY()).setUpdateMatrix(!0);
                  !0 !== r.isColor &&
                    console.error(
                      "WebGPUNodes: Unsupported background configuration.",
                      r
                    );
                },
                i
              )),
              (t.background = r),
              (t.backgroundBlurriness = e.backgroundBlurriness));
          } else
            t.backgroundNode && (delete t.backgroundNode, delete t.background);
        }
        getCacheNode(e, t, r, i = !1) {
          let s = this.cacheLib[e] || (this.cacheLib[e] = new WeakMap()),
            n = s.get(t);
          return (void 0 === n || i) && ((n = r()), s.set(t, n)), n;
        }
        updateFog(e) {
          let t = this.get(e),
            r = e.fog;
          r
            ? t.fog !== r &&
              ((t.fogNode = this.getCacheNode("fog", r, () => {
                if (r.isFogExp2)
                  return ci(
                    ne("color", "color", r).setGroup(e7),
                    cr(ne("density", "float", r).setGroup(e7))
                  );
                if (r.isFog) {
                  let e = ne("color", "color", r).setGroup(e7);
                  return ci(
                    e,
                    ct(
                      ne("near", "float", r).setGroup(e7),
                      ne("far", "float", r).setGroup(e7)
                    )
                  );
                }
                console.error(
                  "THREE.Renderer: Unsupported fog configuration.",
                  r
                );
              })),
              (t.fog = r))
            : (delete t.fogNode, delete t.fog);
        }
        updateEnvironment(e) {
          let t = this.get(e),
            r = e.environment;
          r
            ? t.environment !== r &&
              ((t.environmentNode = this.getCacheNode("environment", r, () =>
                !0 === r.isCubeTexture
                  ? s8(r)
                  : !0 === r.isTexture
                  ? i4(r)
                  : void console.error(
                      "Nodes: Unsupported environment configuration.",
                      r
                    )
              )),
              (t.environment = r))
            : t.environmentNode &&
              (delete t.environmentNode, delete t.environment);
        }
        getNodeFrame(
          e = this.renderer,
          t = null,
          r = null,
          i = null,
          s = null
        ) {
          let n = this.nodeFrame;
          return (
            (n.renderer = e),
            (n.scene = t),
            (n.object = r),
            (n.camera = i),
            (n.material = s),
            n
          );
        }
        getNodeFrameForRender(e) {
          return this.getNodeFrame(
            e.renderer,
            e.scene,
            e.object,
            e.camera,
            e.material
          );
        }
        getOutputCacheKey() {
          let e = this.renderer;
          return e.toneMapping + "," + e.currentColorSpace;
        }
        hasOutputChange(e) {
          return gK.get(e) !== this.getOutputCacheKey();
        }
        getOutputNode(e) {
          let t = this.renderer,
            r = this.getOutputCacheKey(),
            i = i4(e, aU).renderOutput(t.toneMapping, t.currentColorSpace);
          return gK.set(e, r), i;
        }
        updateBefore(e) {
          for (let t of e.getNodeBuilderState().updateBeforeNodes)
            this.getNodeFrameForRender(e).updateBeforeNode(t);
        }
        updateAfter(e) {
          for (let t of e.getNodeBuilderState().updateAfterNodes)
            this.getNodeFrameForRender(e).updateAfterNode(t);
        }
        updateForCompute(e) {
          let t = this.getNodeFrame();
          for (let r of this.getForCompute(e).updateNodes) t.updateNode(r);
        }
        updateForRender(e) {
          let t = this.getNodeFrameForRender(e);
          for (let r of e.getNodeBuilderState().updateNodes) t.updateNode(r);
        }
        needsRefresh(e) {
          let t = this.getNodeFrameForRender(e);
          return e.getMonitor().needsRefresh(e, t);
        }
        dispose() {
          super.dispose(),
            (this.nodeFrame = new gM()),
            (this.nodeBuilderCache = new Map()),
            (this.cacheLib = {});
        }
      }
      let g0 = new u.Zcv();
      class g1 {
        constructor(e = null) {
          (this.version = 0),
            (this.clipIntersection = null),
            (this.cacheKey = ""),
            (this.shadowPass = !1),
            (this.viewNormalMatrix = new u.dwI()),
            (this.clippingGroupContexts = new WeakMap()),
            (this.intersectionPlanes = []),
            (this.unionPlanes = []),
            (this.parentVersion = null),
            null !== e &&
              ((this.viewNormalMatrix = e.viewNormalMatrix),
              (this.clippingGroupContexts = e.clippingGroupContexts),
              (this.shadowPass = e.shadowPass),
              (this.viewMatrix = e.viewMatrix));
        }
        projectPlanes(e, t, r) {
          let i = e.length;
          for (let s = 0; s < i; s++) {
            g0.copy(e[s]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
            let i = t[r + s],
              n = g0.normal;
            (i.x = -n.x), (i.y = -n.y), (i.z = -n.z), (i.w = g0.constant);
          }
        }
        updateGlobal(e, t) {
          (this.shadowPass =
            null !== e.overrideMaterial &&
            e.overrideMaterial.isShadowPassMaterial),
            (this.viewMatrix = t.matrixWorldInverse),
            this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
        }
        update(e, t) {
          let r,
            i,
            s = !1;
          e.version !== this.parentVersion &&
            ((this.intersectionPlanes = Array.from(e.intersectionPlanes)),
            (this.unionPlanes = Array.from(e.unionPlanes)),
            (this.parentVersion = e.version)),
            this.clipIntersection !== t.clipIntersection &&
              ((this.clipIntersection = t.clipIntersection),
              this.clipIntersection
                ? (this.unionPlanes.length = e.unionPlanes.length)
                : (this.intersectionPlanes.length =
                    e.intersectionPlanes.length));
          let n = t.clippingPlanes,
            a = n.length;
          if (
            (this.clipIntersection
              ? ((r = this.intersectionPlanes),
                (i = e.intersectionPlanes.length))
              : ((r = this.unionPlanes), (i = e.unionPlanes.length)),
            r.length !== i + a)
          ) {
            r.length = i + a;
            for (let e = 0; e < a; e++) r[i + e] = new u.IUQ();
            s = !0;
          }
          this.projectPlanes(n, r, i),
            s &&
              (this.version++,
              (this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`));
        }
        getGroupContext(e) {
          if (this.shadowPass && !e.clipShadows) return this;
          let t = this.clippingGroupContexts.get(e);
          return (
            void 0 === t &&
              ((t = new g1(this)), this.clippingGroupContexts.set(e, t)),
            t.update(this, e),
            t
          );
        }
        get unionClippingCount() {
          return this.unionPlanes.length;
        }
      }
      class g2 {
        constructor(e, t) {
          (this.bundleGroup = e), (this.camera = t);
        }
      }
      let g3 = [];
      class g4 {
        constructor() {
          this.bundles = new uL();
        }
        get(e, t) {
          let r = this.bundles;
          (g3[0] = e), (g3[1] = t);
          let i = r.get(g3);
          return (
            void 0 === i && ((i = new g2(e, t)), r.set(g3, i)),
            (g3.length = 0),
            i
          );
        }
        dispose() {
          this.bundles = new uL();
        }
      }
      class g6 {
        constructor() {
          (this.lightNodes = new WeakMap()),
            (this.materialNodes = new Map()),
            (this.toneMappingNodes = new Map());
        }
        fromMaterial(e) {
          if (e.isNodeMaterial) return e;
          let t = null,
            r = this.getMaterialNodeClass(e.type);
          if (null !== r) for (let i in ((t = new r()), e)) t[i] = e[i];
          return t;
        }
        addToneMapping(e, t) {
          this.addType(e, t, this.toneMappingNodes);
        }
        getToneMappingFunction(e) {
          return this.toneMappingNodes.get(e) || null;
        }
        getMaterialNodeClass(e) {
          return this.materialNodes.get(e) || null;
        }
        addMaterial(e, t) {
          this.addType(e, t, this.materialNodes);
        }
        getLightNodeClass(e) {
          return this.lightNodes.get(e) || null;
        }
        addLight(e, t) {
          this.addClass(e, t, this.lightNodes);
        }
        addType(e, t, r) {
          if (r.has(t)) return void console.warn(`Redefinition of node ${t}`);
          if ("function" != typeof e)
            throw Error(`Node class ${e.name} is not a class.`);
          if ("function" == typeof t || "object" == typeof t)
            throw Error(`Base class ${t} is not a class.`);
          r.set(t, e);
        }
        addClass(e, t, r) {
          if (r.has(t))
            return void console.warn(`Redefinition of node ${t.name}`);
          if ("function" != typeof e)
            throw Error(`Node class ${e.name} is not a class.`);
          if ("function" != typeof t)
            throw Error(`Base class ${t.name} is not a class.`);
          r.set(t, e);
        }
      }
      let g5 = new cF(),
        g8 = [];
      class g9 extends uL {
        constructor() {
          super();
        }
        createNode(e = []) {
          return new cF().setLights(e);
        }
        getNode(e, t) {
          if (e.isQuadMesh) return g5;
          (g8[0] = e), (g8[1] = t);
          let r = this.get(g8);
          return (
            void 0 === r && ((r = this.createNode()), this.set(g8, r)),
            (g8.length = 0),
            r
          );
        }
      }
      class g7 extends u.O0B {
        constructor(e = 1, t = 1, r = {}) {
          super(e, t, r),
            (this.isXRRenderTarget = !0),
            (this.hasExternalTextures = !1),
            (this.autoAllocateDepthBuffer = !0);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.hasExternalTextures = e.hasExternalTextures),
            (this.autoAllocateDepthBuffer = e.autoAllocateDepthBuffer),
            this
          );
        }
      }
      let me = new u.Pq0(),
        mt = new u.Pq0();
      class mr extends u.Qev {
        constructor(e) {
          super(),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.cameraAutoUpdate = !0),
            (this._renderer = e),
            (this._cameraL = new u.ubm()),
            (this._cameraL.viewport = new u.IUQ()),
            (this._cameraR = new u.ubm()),
            (this._cameraR.viewport = new u.IUQ()),
            (this._cameras = [this._cameraL, this._cameraR]),
            (this._cameraXR = new u.nZQ()),
            (this._currentDepthNear = null),
            (this._currentDepthFar = null),
            (this._controllers = []),
            (this._controllerInputSources = []),
            (this._xrRenderTarget = null),
            (this._currentAnimationContext = null),
            (this._currentAnimationLoop = null),
            (this._currentPixelRatio = null),
            (this._currentSize = new u.I9Y()),
            (this._onSessionEvent = ms.bind(this)),
            (this._onSessionEnd = mn.bind(this)),
            (this._onInputSourcesChange = ma.bind(this)),
            (this._onAnimationFrame = mo.bind(this)),
            (this._referenceSpace = null),
            (this._referenceSpaceType = "local-floor"),
            (this._customReferenceSpace = null),
            (this._framebufferScaleFactor = 1),
            (this._foveation = 1),
            (this._session = null),
            (this._glBaseLayer = null),
            (this._glBinding = null),
            (this._glProjLayer = null),
            (this._xrFrame = null),
            (this._useLayers =
              "undefined" != typeof XRWebGLBinding &&
              "createProjectionLayer" in XRWebGLBinding.prototype);
        }
        getController(e) {
          return this._getController(e).getTargetRaySpace();
        }
        getControllerGrip(e) {
          return this._getController(e).getGripSpace();
        }
        getHand(e) {
          return this._getController(e).getHandSpace();
        }
        getFoveation() {
          if (null !== this._glProjLayer || null !== this._glBaseLayer)
            return this._foveation;
        }
        setFoveation(e) {
          (this._foveation = e),
            null !== this._glProjLayer &&
              (this._glProjLayer.fixedFoveation = e),
            null !== this._glBaseLayer &&
              void 0 !== this._glBaseLayer.fixedFoveation &&
              (this._glBaseLayer.fixedFoveation = e);
        }
        getFramebufferScaleFactor() {
          return this._framebufferScaleFactor;
        }
        setFramebufferScaleFactor(e) {
          (this._framebufferScaleFactor = e),
            !0 === this.isPresenting &&
              console.warn(
                "THREE.XRManager: Cannot change framebuffer scale while presenting."
              );
        }
        getReferenceSpaceType() {
          return this._referenceSpaceType;
        }
        setReferenceSpaceType(e) {
          (this._referenceSpaceType = e),
            !0 === this.isPresenting &&
              console.warn(
                "THREE.XRManager: Cannot change reference space type while presenting."
              );
        }
        getReferenceSpace() {
          return this._customReferenceSpace || this._referenceSpace;
        }
        setReferenceSpace(e) {
          this._customReferenceSpace = e;
        }
        getCamera() {
          return this._cameraXR;
        }
        getEnvironmentBlendMode() {
          if (null !== this._session) return this._session.environmentBlendMode;
        }
        getFrame() {
          return this._xrFrame;
        }
        getSession() {
          return this._session;
        }
        async setSession(e) {
          let t = this._renderer,
            r = t.backend,
            i = t.getContext();
          if (((this._session = e), null !== e)) {
            if (!0 === r.isWebGPUBackend)
              throw Error(
                'THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.'
              );
            if (
              (e.addEventListener("select", this._onSessionEvent),
              e.addEventListener("selectstart", this._onSessionEvent),
              e.addEventListener("selectend", this._onSessionEvent),
              e.addEventListener("squeeze", this._onSessionEvent),
              e.addEventListener("squeezestart", this._onSessionEvent),
              e.addEventListener("squeezeend", this._onSessionEvent),
              e.addEventListener("end", this._onSessionEnd),
              e.addEventListener(
                "inputsourceschange",
                this._onInputSourcesChange
              ),
              await r.makeXRCompatible(),
              (this._currentPixelRatio = t.getPixelRatio()),
              t.getSize(this._currentSize),
              (this._currentAnimationContext = t._animation.getContext()),
              (this._currentAnimationLoop = t._animation.getAnimationLoop()),
              t._animation.stop(),
              !0 === this._useLayers)
            ) {
              let r = null,
                s = null,
                n = null;
              t.depth &&
                ((n = t.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24),
                (r = t.stencil ? u.dcC : u.zdS),
                (s = t.stencil ? u.V3x : u.bkx));
              let a = {
                  colorFormat: i.RGBA8,
                  depthFormat: n,
                  scaleFactor: this._framebufferScaleFactor,
                },
                o = new XRWebGLBinding(e, i),
                l = o.createProjectionLayer(a);
              (this._glBinding = o),
                (this._glProjLayer = l),
                e.updateRenderState({ layers: [l] }),
                t.setPixelRatio(1),
                t.setSize(l.textureWidth, l.textureHeight, !1),
                (this._xrRenderTarget = new g7(
                  l.textureWidth,
                  l.textureHeight,
                  {
                    format: u.GWd,
                    type: u.OUM,
                    colorSpace: t.outputColorSpace,
                    depthTexture: new u.VCu(
                      l.textureWidth,
                      l.textureHeight,
                      s,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      r
                    ),
                    stencilBuffer: t.stencil,
                    resolveDepthBuffer: !1 === l.ignoreDepthValues,
                    resolveStencilBuffer: !1 === l.ignoreDepthValues,
                  }
                )),
                (this._xrRenderTarget.hasExternalTextures = !0);
            } else {
              let r = new XRWebGLLayer(e, i, {
                antialias: t.samples > 0,
                alpha: !0,
                depth: t.depth,
                stencil: t.stencil,
                framebufferScaleFactor: this.getFramebufferScaleFactor(),
              });
              (this._glBaseLayer = r),
                e.updateRenderState({ baseLayer: r }),
                t.setPixelRatio(1),
                t.setSize(r.framebufferWidth, r.framebufferHeight, !1),
                (this._xrRenderTarget = new g7(
                  r.framebufferWidth,
                  r.framebufferHeight,
                  {
                    format: u.GWd,
                    type: u.OUM,
                    colorSpace: t.outputColorSpace,
                    stencilBuffer: t.stencil,
                    resolveDepthBuffer: !1 === r.ignoreDepthValues,
                    resolveStencilBuffer: !1 === r.ignoreDepthValues,
                  }
                ));
            }
            this.setFoveation(this.getFoveation()),
              (this._referenceSpace = await e.requestReferenceSpace(
                this.getReferenceSpaceType()
              )),
              t._animation.setAnimationLoop(this._onAnimationFrame),
              t._animation.setContext(e),
              t._animation.start(),
              (this.isPresenting = !0),
              this.dispatchEvent({ type: "sessionstart" });
          }
        }
        updateCamera(e) {
          var t, r, i;
          let s = this._session;
          if (null === s) return;
          let n = e.near,
            a = e.far,
            o = this._cameraXR,
            l = this._cameraL,
            d = this._cameraR;
          (o.near = d.near = l.near = n),
            (o.far = d.far = l.far = a),
            (this._currentDepthNear !== o.near ||
              this._currentDepthFar !== o.far) &&
              (s.updateRenderState({ depthNear: o.near, depthFar: o.far }),
              (this._currentDepthNear = o.near),
              (this._currentDepthFar = o.far)),
            (l.layers.mask = 2 | e.layers.mask),
            (d.layers.mask = 4 | e.layers.mask),
            (o.layers.mask = l.layers.mask | d.layers.mask);
          let h = e.parent,
            c = o.cameras;
          mi(o, h);
          for (let e = 0; e < c.length; e++) mi(c[e], h);
          2 === c.length
            ? (function (e, t, r) {
                me.setFromMatrixPosition(t.matrixWorld),
                  mt.setFromMatrixPosition(r.matrixWorld);
                let i = me.distanceTo(mt),
                  s = t.projectionMatrix.elements,
                  n = r.projectionMatrix.elements,
                  a = s[14] / (s[10] - 1),
                  o = s[14] / (s[10] + 1),
                  l = (s[9] + 1) / s[5],
                  u = (s[9] - 1) / s[5],
                  d = (s[8] - 1) / s[0],
                  h = (n[8] + 1) / n[0],
                  c = i / (-d + h),
                  p = -(c * d);
                if (
                  (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(p),
                  e.translateZ(c),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                  -1 === s[10])
                )
                  e.projectionMatrix.copy(t.projectionMatrix),
                    e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                else {
                  let t = a + c,
                    r = o + c;
                  e.projectionMatrix.makePerspective(
                    a * d - p,
                    a * h + (i - p),
                    ((l * o) / r) * t,
                    ((u * o) / r) * t,
                    t,
                    r
                  ),
                    e.projectionMatrixInverse.copy(e.projectionMatrix).invert();
                }
              })(o, l, d)
            : o.projectionMatrix.copy(l.projectionMatrix),
            (t = e),
            (r = o),
            null === (i = h)
              ? t.matrix.copy(r.matrixWorld)
              : (t.matrix.copy(i.matrixWorld),
                t.matrix.invert(),
                t.matrix.multiply(r.matrixWorld)),
            t.matrix.decompose(t.position, t.quaternion, t.scale),
            t.updateMatrixWorld(!0),
            t.projectionMatrix.copy(r.projectionMatrix),
            t.projectionMatrixInverse.copy(r.projectionMatrixInverse),
            t.isPerspectiveCamera &&
              ((t.fov =
                2 * u.a55 * Math.atan(1 / t.projectionMatrix.elements[5])),
              (t.zoom = 1));
        }
        _getController(e) {
          let t = this._controllers[e];
          return (
            void 0 === t && ((t = new u.R3r()), (this._controllers[e] = t)), t
          );
        }
      }
      function mi(e, t) {
        null === t
          ? e.matrixWorld.copy(e.matrix)
          : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
          e.matrixWorldInverse.copy(e.matrixWorld).invert();
      }
      function ms(e) {
        let t = this._controllerInputSources.indexOf(e.inputSource);
        if (-1 === t) return;
        let r = this._controllers[t];
        if (void 0 !== r) {
          let t = this.getReferenceSpace();
          r.update(e.inputSource, e.frame, t),
            r.dispatchEvent({ type: e.type, data: e.inputSource });
        }
      }
      function mn() {
        let e = this._session,
          t = this._renderer;
        e.removeEventListener("select", this._onSessionEvent),
          e.removeEventListener("selectstart", this._onSessionEvent),
          e.removeEventListener("selectend", this._onSessionEvent),
          e.removeEventListener("squeeze", this._onSessionEvent),
          e.removeEventListener("squeezestart", this._onSessionEvent),
          e.removeEventListener("squeezeend", this._onSessionEvent),
          e.removeEventListener("end", this._onSessionEnd),
          e.removeEventListener(
            "inputsourceschange",
            this._onInputSourcesChange
          );
        for (let e = 0; e < this._controllers.length; e++) {
          let t = this._controllerInputSources[e];
          null !== t &&
            ((this._controllerInputSources[e] = null),
            this._controllers[e].disconnect(t));
        }
        (this._currentDepthNear = null),
          (this._currentDepthFar = null),
          t.backend.setXRTarget(null),
          t.setOutputRenderTarget(null),
          (this._session = null),
          (this._xrRenderTarget = null),
          (this.isPresenting = !1),
          t._animation.stop(),
          t._animation.setAnimationLoop(this._currentAnimationLoop),
          t._animation.setContext(this._currentAnimationContext),
          t._animation.start(),
          t.setPixelRatio(this._currentPixelRatio),
          t.setSize(this._currentSize.width, this._currentSize.height, !1),
          this.dispatchEvent({ type: "sessionend" });
      }
      function ma(e) {
        let t = this._controllers,
          r = this._controllerInputSources;
        for (let i = 0; i < e.removed.length; i++) {
          let s = e.removed[i],
            n = r.indexOf(s);
          n >= 0 && ((r[n] = null), t[n].disconnect(s));
        }
        for (let i = 0; i < e.added.length; i++) {
          let s = e.added[i],
            n = r.indexOf(s);
          if (-1 === n) {
            for (let e = 0; e < t.length; e++)
              if (e >= r.length) {
                r.push(s), (n = e);
                break;
              } else if (null === r[e]) {
                (r[e] = s), (n = e);
                break;
              }
            if (-1 === n) break;
          }
          let a = t[n];
          a && a.connect(s);
        }
      }
      function mo(e, t) {
        if (void 0 === t) return;
        let r = this._cameraXR,
          i = this._renderer,
          s = i.backend,
          n = this._glBaseLayer,
          a = this.getReferenceSpace(),
          o = t.getViewerPose(a);
        if (((this._xrFrame = t), null !== o)) {
          let e = o.views;
          null !== this._glBaseLayer && s.setXRTarget(n.framebuffer);
          let t = !1;
          e.length !== r.cameras.length && ((r.cameras.length = 0), (t = !0));
          for (let i = 0; i < e.length; i++) {
            let a,
              o = e[i];
            if (!0 === this._useLayers) {
              let e = this._glBinding.getViewSubImage(this._glProjLayer, o);
              (a = e.viewport),
                0 === i &&
                  s.setXRRenderTargetTextures(
                    this._xrRenderTarget,
                    e.colorTexture,
                    this._glProjLayer.ignoreDepthValues
                      ? void 0
                      : e.depthStencilTexture
                  );
            } else a = n.getViewport(o);
            let l = this._cameras[i];
            void 0 === l &&
              ((l = new u.ubm()).layers.enable(i),
              (l.viewport = new u.IUQ()),
              (this._cameras[i] = l)),
              l.matrix.fromArray(o.transform.matrix),
              l.matrix.decompose(l.position, l.quaternion, l.scale),
              l.projectionMatrix.fromArray(o.projectionMatrix),
              l.projectionMatrixInverse.copy(l.projectionMatrix).invert(),
              l.viewport.set(a.x, a.y, a.width, a.height),
              0 === i &&
                (r.matrix.copy(l.matrix),
                r.matrix.decompose(r.position, r.quaternion, r.scale)),
              !0 === t && r.cameras.push(l);
          }
          i.setOutputRenderTarget(this._xrRenderTarget);
        }
        for (let e = 0; e < this._controllers.length; e++) {
          let r = this._controllerInputSources[e],
            i = this._controllers[e];
          null !== r && void 0 !== i && i.update(r, t, a);
        }
        this._currentAnimationLoop && this._currentAnimationLoop(e, t),
          t.detectedPlanes &&
            this.dispatchEvent({ type: "planesdetected", data: t }),
          (this._xrFrame = null);
      }
      let ml = new u.Z58(),
        mu = new u.I9Y(),
        md = new u.IUQ(),
        mh = new u.PPD(),
        mc = new u.kn4(),
        mp = new u.IUQ();
      class mg {
        constructor(e, t = {}) {
          this.isRenderer = !0;
          let {
            logarithmicDepthBuffer: r = !1,
            alpha: i = !0,
            depth: s = !0,
            stencil: n = !1,
            antialias: a = !1,
            samples: o = 0,
            getFallback: l = null,
            colorBufferType: d = u.ix0,
          } = t;
          (this.domElement = e.getDomElement()),
            (this.backend = e),
            (this.samples = o || !0 === a ? 4 : 0),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.alpha = i),
            (this.logarithmicDepthBuffer = r),
            (this.outputColorSpace = u.er$),
            (this.toneMapping = u.y_p),
            (this.toneMappingExposure = 1),
            (this.sortObjects = !0),
            (this.depth = s),
            (this.stencil = n),
            (this.info = new uj()),
            (this.nodes = {
              modelViewMatrix: null,
              modelNormalViewMatrix: null,
            }),
            (this.library = new g6()),
            (this.lighting = new g9()),
            (this._getFallback = l),
            (this._pixelRatio = 1),
            (this._width = this.domElement.width),
            (this._height = this.domElement.height),
            (this._viewport = new u.IUQ(0, 0, this._width, this._height)),
            (this._scissor = new u.IUQ(0, 0, this._width, this._height)),
            (this._scissorTest = !1),
            (this._attributes = null),
            (this._geometries = null),
            (this._nodes = null),
            (this._animation = null),
            (this._bindings = null),
            (this._objects = null),
            (this._pipelines = null),
            (this._bundles = null),
            (this._renderLists = null),
            (this._renderContexts = null),
            (this._textures = null),
            (this._background = null),
            (this._quad = new d2(new os())),
            (this._quad.material.name = "Renderer_output"),
            (this._currentRenderContext = null),
            (this._opaqueSort = null),
            (this._transparentSort = null),
            (this._frameBufferTarget = null);
          let h = +(!0 !== this.alpha);
          (this._clearColor = new da(0, 0, 0, h)),
            (this._clearDepth = 1),
            (this._clearStencil = 0),
            (this._renderTarget = null),
            (this._activeCubeFace = 0),
            (this._activeMipmapLevel = 0),
            (this._outputRenderTarget = null),
            (this._mrt = null),
            (this._renderObjectFunction = null),
            (this._currentRenderObjectFunction = null),
            (this._currentRenderBundle = null),
            (this._handleObjectFunction = this._renderObjectDirect),
            (this._isDeviceLost = !1),
            (this.onDeviceLost = this._onDeviceLost),
            (this._colorBufferType = d),
            (this._initialized = !1),
            (this._initPromise = null),
            (this._compilationPromises = null),
            (this.transparent = !0),
            (this.opaque = !0),
            (this.shadowMap = { enabled: !1, type: u.QP0 }),
            (this.xr = new mr(this)),
            (this.debug = {
              checkShaderErrors: !0,
              onShaderError: null,
              getShaderAsync: async (e, t, r) => {
                await this.compileAsync(e, t);
                let i = this._renderLists.get(e, t),
                  s = this._renderContexts.get(e, t, this._renderTarget),
                  n = e.overrideMaterial || r.material,
                  { fragmentShader: a, vertexShader: o } = this._objects
                    .get(r, n, e, t, i.lightsNode, s, s.clippingContext)
                    .getNodeBuilderState();
                return { fragmentShader: a, vertexShader: o };
              },
            });
        }
        async init() {
          if (this._initialized)
            throw Error("Renderer: Backend has already been initialized.");
          return (
            null !== this._initPromise ||
              (this._initPromise = new Promise(async (e, t) => {
                let r = this.backend;
                try {
                  await r.init(this);
                } catch (e) {
                  if (null === this._getFallback) return void t(e);
                  try {
                    (this.backend = r = this._getFallback(e)),
                      await r.init(this);
                  } catch (e) {
                    t(e);
                    return;
                  }
                }
                (this._nodes = new gJ(this, r)),
                  (this._animation = new uP(this._nodes, this.info)),
                  (this._attributes = new u$(r)),
                  (this._background = new p8(this, this._nodes)),
                  (this._geometries = new uq(this._attributes, this.info)),
                  (this._textures = new dn(this, r, this.info)),
                  (this._pipelines = new uJ(r, this._nodes)),
                  (this._bindings = new u0(
                    r,
                    this._nodes,
                    this._textures,
                    this._attributes,
                    this._pipelines,
                    this.info
                  )),
                  (this._objects = new uG(
                    this,
                    this._nodes,
                    this._geometries,
                    this._pipelines,
                    this._bindings,
                    this.info
                  )),
                  (this._renderLists = new u5(this.lighting)),
                  (this._bundles = new g4()),
                  (this._renderContexts = new di()),
                  this._animation.start(),
                  (this._initialized = !0),
                  e(this);
              })),
            this._initPromise
          );
        }
        get coordinateSystem() {
          return this.backend.coordinateSystem;
        }
        async compileAsync(e, t, r = null) {
          if (!0 === this._isDeviceLost) return;
          !1 === this._initialized && (await this.init());
          let i = this._nodes.nodeFrame,
            s = i.renderId,
            n = this._currentRenderContext,
            a = this._currentRenderObjectFunction,
            o = this._compilationPromises,
            l = !0 === e.isScene ? e : ml;
          null === r && (r = e);
          let u = this._renderTarget,
            d = this._renderContexts.get(r, t, u),
            h = this._activeMipmapLevel,
            c = [];
          (this._currentRenderContext = d),
            (this._currentRenderObjectFunction = this.renderObject),
            (this._handleObjectFunction = this._createObjectPipeline),
            (this._compilationPromises = c),
            i.renderId++,
            i.update(),
            (d.depth = this.depth),
            (d.stencil = this.stencil),
            d.clippingContext || (d.clippingContext = new g1()),
            d.clippingContext.updateGlobal(l, t),
            l.onBeforeRender(this, e, t, u);
          let p = this._renderLists.get(e, t);
          if (
            (p.begin(),
            this._projectObject(e, t, 0, p, d.clippingContext),
            r !== e &&
              r.traverseVisible(function (e) {
                e.isLight && e.layers.test(t.layers) && p.pushLight(e);
              }),
            p.finish(),
            null !== u)
          ) {
            this._textures.updateRenderTarget(u, h);
            let e = this._textures.get(u);
            (d.textures = e.textures), (d.depthTexture = e.depthTexture);
          } else (d.textures = null), (d.depthTexture = null);
          this._background.update(l, p, d);
          let g = p.opaque,
            m = p.transparent,
            f = p.transparentDoublePass,
            y = p.lightsNode;
          !0 === this.opaque && g.length > 0 && this._renderObjects(g, t, l, y),
            !0 === this.transparent &&
              m.length > 0 &&
              this._renderTransparents(m, f, t, l, y),
            (i.renderId = s),
            (this._currentRenderContext = n),
            (this._currentRenderObjectFunction = a),
            (this._compilationPromises = o),
            (this._handleObjectFunction = this._renderObjectDirect),
            await Promise.all(c);
        }
        async renderAsync(e, t) {
          !1 === this._initialized && (await this.init()),
            this._renderScene(e, t);
        }
        async waitForGPU() {
          await this.backend.waitForGPU();
        }
        setMRT(e) {
          return (this._mrt = e), this;
        }
        getMRT() {
          return this._mrt;
        }
        getColorBufferType() {
          return this._colorBufferType;
        }
        _onDeviceLost(e) {
          let t = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
          e.reason &&
            (t += `
Reason: ${e.reason}`),
            console.error(t),
            (this._isDeviceLost = !0);
        }
        _renderBundle(e, t, r) {
          let { bundleGroup: i, camera: s, renderList: n } = e,
            a = this._currentRenderContext,
            o = this._bundles.get(i, s),
            l = this.backend.get(o);
          void 0 === l.renderContexts && (l.renderContexts = new Set());
          let u = i.version !== l.version,
            d = !1 === l.renderContexts.has(a) || u;
          if ((l.renderContexts.add(a), d)) {
            this.backend.beginBundle(a),
              (void 0 === l.renderObjects || u) && (l.renderObjects = []),
              (this._currentRenderBundle = o);
            let e = n.opaque;
            !0 === this.opaque &&
              e.length > 0 &&
              this._renderObjects(e, s, t, r),
              (this._currentRenderBundle = null),
              this.backend.finishBundle(a, o),
              (l.version = i.version);
          } else {
            let { renderObjects: e } = l;
            for (let t = 0, r = e.length; t < r; t++) {
              let r = e[t];
              this._nodes.needsRefresh(r) &&
                (this._nodes.updateBefore(r),
                this._nodes.updateForRender(r),
                this._bindings.updateForRender(r),
                this._nodes.updateAfter(r));
            }
          }
          this.backend.addBundle(a, o);
        }
        render(e, t) {
          if (!1 === this._initialized)
            return (
              console.warn(
                "THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."
              ),
              this.renderAsync(e, t)
            );
          this._renderScene(e, t);
        }
        _getFrameBufferTarget() {
          let { currentToneMapping: e, currentColorSpace: t } = this,
            r = e !== u.y_p,
            i = t !== u.Zr2;
          if (!1 === r && !1 === i) return null;
          let { width: s, height: n } = this.getDrawingBufferSize(mu),
            { depth: a, stencil: o } = this,
            l = this._frameBufferTarget;
          return (
            null === l &&
              (((l = new u.O0B(s, n, {
                depthBuffer: a,
                stencilBuffer: o,
                type: this._colorBufferType,
                format: u.GWd,
                colorSpace: u.Zr2,
                generateMipmaps: !1,
                minFilter: u.k6q,
                magFilter: u.k6q,
                samples: this.samples,
              })).isPostProcessingRenderTarget = !0),
              (this._frameBufferTarget = l)),
            (l.depthBuffer = a),
            (l.stencilBuffer = o),
            l.setSize(s, n),
            l.viewport.copy(this._viewport),
            l.scissor.copy(this._scissor),
            l.viewport.multiplyScalar(this._pixelRatio),
            l.scissor.multiplyScalar(this._pixelRatio),
            (l.scissorTest = this._scissorTest),
            l
          );
        }
        _renderScene(e, t, r = !0) {
          let i;
          if (!0 === this._isDeviceLost) return;
          let s = r ? this._getFrameBufferTarget() : null,
            n = this._nodes.nodeFrame,
            a = n.renderId,
            o = this._currentRenderContext,
            l = this._currentRenderObjectFunction,
            u = !0 === e.isScene ? e : ml,
            d = this._renderTarget || this._outputRenderTarget,
            h = this._activeCubeFace,
            c = this._activeMipmapLevel;
          null !== s ? ((i = s), this.setRenderTarget(i)) : (i = d);
          let p = this._renderContexts.get(e, t, i);
          (this._currentRenderContext = p),
            (this._currentRenderObjectFunction =
              this._renderObjectFunction || this.renderObject),
            this.info.calls++,
            this.info.render.calls++,
            this.info.render.frameCalls++,
            (n.renderId = this.info.calls);
          let g = this.coordinateSystem,
            m = this.xr;
          if (
            t.coordinateSystem !== g &&
            !1 === m.isPresenting &&
            ((t.coordinateSystem = g),
            t.updateProjectionMatrix(),
            t.isArrayCamera)
          )
            for (let e of t.cameras)
              (e.coordinateSystem = g), e.updateProjectionMatrix();
          !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
            null === t.parent &&
              !0 === t.matrixWorldAutoUpdate &&
              t.updateMatrixWorld(),
            !0 === m.enabled &&
              !0 === m.isPresenting &&
              (!0 === m.cameraAutoUpdate && m.updateCamera(t),
              (t = m.getCamera()));
          let f = this._viewport,
            y = this._scissor,
            x = this._pixelRatio;
          null !== i && ((f = i.viewport), (y = i.scissor), (x = 1)),
            this.getDrawingBufferSize(mu),
            md.set(0, 0, mu.width, mu.height);
          let b = void 0 === f.minDepth ? 0 : f.minDepth,
            T = void 0 === f.maxDepth ? 1 : f.maxDepth;
          p.viewportValue.copy(f).multiplyScalar(x).floor(),
            (p.viewportValue.width >>= c),
            (p.viewportValue.height >>= c),
            (p.viewportValue.minDepth = b),
            (p.viewportValue.maxDepth = T),
            (p.viewport = !1 === p.viewportValue.equals(md)),
            p.scissorValue.copy(y).multiplyScalar(x).floor(),
            (p.scissor = this._scissorTest && !1 === p.scissorValue.equals(md)),
            (p.scissorValue.width >>= c),
            (p.scissorValue.height >>= c),
            p.clippingContext || (p.clippingContext = new g1()),
            p.clippingContext.updateGlobal(u, t),
            u.onBeforeRender(this, e, t, i),
            mc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            mh.setFromProjectionMatrix(mc, g);
          let _ = this._renderLists.get(e, t);
          if (
            (_.begin(),
            this._projectObject(e, t, 0, _, p.clippingContext),
            _.finish(),
            !0 === this.sortObjects &&
              _.sort(this._opaqueSort, this._transparentSort),
            null !== i)
          ) {
            this._textures.updateRenderTarget(i, c);
            let e = this._textures.get(i);
            (p.textures = e.textures),
              (p.depthTexture = e.depthTexture),
              (p.width = e.width),
              (p.height = e.height),
              (p.renderTarget = i),
              (p.depth = i.depthBuffer),
              (p.stencil = i.stencilBuffer);
          } else
            (p.textures = null),
              (p.depthTexture = null),
              (p.width = this.domElement.width),
              (p.height = this.domElement.height),
              (p.depth = this.depth),
              (p.stencil = this.stencil);
          (p.width >>= c),
            (p.height >>= c),
            (p.activeCubeFace = h),
            (p.activeMipmapLevel = c),
            (p.occlusionQueryCount = _.occlusionQueryCount),
            this._background.update(u, _, p),
            this.backend.beginRender(p);
          let {
            bundles: v,
            lightsNode: N,
            transparentDoublePass: S,
            transparent: R,
            opaque: A,
          } = _;
          return (
            v.length > 0 && this._renderBundles(v, u, N),
            !0 === this.opaque &&
              A.length > 0 &&
              this._renderObjects(A, t, u, N),
            !0 === this.transparent &&
              R.length > 0 &&
              this._renderTransparents(R, S, t, u, N),
            this.backend.finishRender(p),
            (n.renderId = a),
            (this._currentRenderContext = o),
            (this._currentRenderObjectFunction = l),
            null !== s &&
              (this.setRenderTarget(d, h, c), this._renderOutput(i)),
            u.onAfterRender(this, e, t, i),
            p
          );
        }
        _renderOutput(e) {
          let t = this._quad;
          this._nodes.hasOutputChange(e.texture) &&
            ((t.material.fragmentNode = this._nodes.getOutputNode(e.texture)),
            (t.material.needsUpdate = !0));
          let r = this.autoClear,
            i = this.xr.enabled;
          (this.autoClear = !1),
            (this.xr.enabled = !1),
            this._renderScene(t, t.camera, !1),
            (this.autoClear = r),
            (this.xr.enabled = i);
        }
        getMaxAnisotropy() {
          return this.backend.getMaxAnisotropy();
        }
        getActiveCubeFace() {
          return this._activeCubeFace;
        }
        getActiveMipmapLevel() {
          return this._activeMipmapLevel;
        }
        async setAnimationLoop(e) {
          !1 === this._initialized && (await this.init()),
            this._animation.setAnimationLoop(e);
        }
        async getArrayBufferAsync(e) {
          return await this.backend.getArrayBufferAsync(e);
        }
        getContext() {
          return this.backend.getContext();
        }
        getPixelRatio() {
          return this._pixelRatio;
        }
        getDrawingBufferSize(e) {
          return e
            .set(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            )
            .floor();
        }
        getSize(e) {
          return e.set(this._width, this._height);
        }
        setPixelRatio(e = 1) {
          this._pixelRatio !== e &&
            ((this._pixelRatio = e),
            this.setSize(this._width, this._height, !1));
        }
        setDrawingBufferSize(e, t, r) {
          (this._width = e),
            (this._height = t),
            (this._pixelRatio = r),
            (this.domElement.width = Math.floor(e * r)),
            (this.domElement.height = Math.floor(t * r)),
            this.setViewport(0, 0, e, t),
            this._initialized && this.backend.updateSize();
        }
        setSize(e, t, r = !0) {
          (this._width = e),
            (this._height = t),
            (this.domElement.width = Math.floor(e * this._pixelRatio)),
            (this.domElement.height = Math.floor(t * this._pixelRatio)),
            !0 === r &&
              ((this.domElement.style.width = e + "px"),
              (this.domElement.style.height = t + "px")),
            this.setViewport(0, 0, e, t),
            this._initialized && this.backend.updateSize();
        }
        setOpaqueSort(e) {
          this._opaqueSort = e;
        }
        setTransparentSort(e) {
          this._transparentSort = e;
        }
        getScissor(e) {
          let t = this._scissor;
          return (
            (e.x = t.x),
            (e.y = t.y),
            (e.width = t.width),
            (e.height = t.height),
            e
          );
        }
        setScissor(e, t, r, i) {
          let s = this._scissor;
          e.isVector4 ? s.copy(e) : s.set(e, t, r, i);
        }
        getScissorTest() {
          return this._scissorTest;
        }
        setScissorTest(e) {
          (this._scissorTest = e), this.backend.setScissorTest(e);
        }
        getViewport(e) {
          return e.copy(this._viewport);
        }
        setViewport(e, t, r, i, s = 0, n = 1) {
          let a = this._viewport;
          e.isVector4 ? a.copy(e) : a.set(e, t, r, i),
            (a.minDepth = s),
            (a.maxDepth = n);
        }
        getClearColor(e) {
          return e.copy(this._clearColor);
        }
        setClearColor(e, t = 1) {
          this._clearColor.set(e), (this._clearColor.a = t);
        }
        getClearAlpha() {
          return this._clearColor.a;
        }
        setClearAlpha(e) {
          this._clearColor.a = e;
        }
        getClearDepth() {
          return this._clearDepth;
        }
        setClearDepth(e) {
          this._clearDepth = e;
        }
        getClearStencil() {
          return this._clearStencil;
        }
        setClearStencil(e) {
          this._clearStencil = e;
        }
        isOccluded(e) {
          let t = this._currentRenderContext;
          return t && this.backend.isOccluded(t, e);
        }
        clear(e = !0, t = !0, r = !0) {
          if (!1 === this._initialized)
            return (
              console.warn(
                "THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."
              ),
              this.clearAsync(e, t, r)
            );
          let i = this._renderTarget || this._getFrameBufferTarget(),
            s = null;
          if (null !== i) {
            this._textures.updateRenderTarget(i);
            let e = this._textures.get(i);
            ((s = this._renderContexts.getForClear(i)).textures = e.textures),
              (s.depthTexture = e.depthTexture),
              (s.width = e.width),
              (s.height = e.height),
              (s.renderTarget = i),
              (s.depth = i.depthBuffer),
              (s.stencil = i.stencilBuffer),
              (s.clearColorValue = this.backend.getClearColor());
          }
          this.backend.clear(e, t, r, s),
            null !== i && null === this._renderTarget && this._renderOutput(i);
        }
        clearColor() {
          return this.clear(!0, !1, !1);
        }
        clearDepth() {
          return this.clear(!1, !0, !1);
        }
        clearStencil() {
          return this.clear(!1, !1, !0);
        }
        async clearAsync(e = !0, t = !0, r = !0) {
          !1 === this._initialized && (await this.init()), this.clear(e, t, r);
        }
        async clearColorAsync() {
          this.clearAsync(!0, !1, !1);
        }
        async clearDepthAsync() {
          this.clearAsync(!1, !0, !1);
        }
        async clearStencilAsync() {
          this.clearAsync(!1, !1, !0);
        }
        get currentToneMapping() {
          return this.isOutputTarget ? this.toneMapping : u.y_p;
        }
        get currentColorSpace() {
          return this.isOutputTarget ? this.outputColorSpace : u.Zr2;
        }
        get isOutputTarget() {
          return (
            this._renderTarget === this._outputRenderTarget ||
            null === this._renderTarget
          );
        }
        dispose() {
          this.info.dispose(),
            this.backend.dispose(),
            this._animation.dispose(),
            this._objects.dispose(),
            this._pipelines.dispose(),
            this._nodes.dispose(),
            this._bindings.dispose(),
            this._renderLists.dispose(),
            this._renderContexts.dispose(),
            this._textures.dispose(),
            null !== this._frameBufferTarget &&
              this._frameBufferTarget.dispose(),
            Object.values(this.backend.timestampQueryPool).forEach((e) => {
              null !== e && e.dispose();
            }),
            this.setRenderTarget(null),
            this.setAnimationLoop(null);
        }
        setRenderTarget(e, t = 0, r = 0) {
          (this._renderTarget = e),
            (this._activeCubeFace = t),
            (this._activeMipmapLevel = r);
        }
        getRenderTarget() {
          return this._renderTarget;
        }
        setOutputRenderTarget(e) {
          this._outputRenderTarget = e;
        }
        getOutputRenderTarget() {
          return this._outputRenderTarget;
        }
        setRenderObjectFunction(e) {
          this._renderObjectFunction = e;
        }
        getRenderObjectFunction() {
          return this._renderObjectFunction;
        }
        compute(e) {
          if (!0 === this._isDeviceLost) return;
          if (!1 === this._initialized)
            return (
              console.warn(
                "THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."
              ),
              this.computeAsync(e)
            );
          let t = this._nodes.nodeFrame,
            r = t.renderId;
          this.info.calls++,
            this.info.compute.calls++,
            this.info.compute.frameCalls++,
            (t.renderId = this.info.calls);
          let i = this.backend,
            s = this._pipelines,
            n = this._bindings,
            a = this._nodes,
            o = Array.isArray(e) ? e : [e];
          if (void 0 === o[0] || !0 !== o[0].isComputeNode)
            throw Error("THREE.Renderer: .compute() expects a ComputeNode.");
          for (let t of (i.beginCompute(e), o)) {
            if (!1 === s.has(t)) {
              let e = () => {
                t.removeEventListener("dispose", e),
                  s.delete(t),
                  n.delete(t),
                  a.delete(t);
              };
              t.addEventListener("dispose", e);
              let r = t.onInitFunction;
              null !== r && r.call(t, { renderer: this });
            }
            a.updateForCompute(t), n.updateForCompute(t);
            let r = n.getForCompute(t),
              o = s.getForCompute(t, r);
            i.compute(e, t, r, o);
          }
          i.finishCompute(e), (t.renderId = r);
        }
        async computeAsync(e) {
          !1 === this._initialized && (await this.init()), this.compute(e);
        }
        async hasFeatureAsync(e) {
          return (
            !1 === this._initialized && (await this.init()),
            this.backend.hasFeature(e)
          );
        }
        async resolveTimestampsAsync(e = "render") {
          return (
            !1 === this._initialized && (await this.init()),
            this.backend.resolveTimestampsAsync(e)
          );
        }
        hasFeature(e) {
          return !1 === this._initialized
            ? (console.warn(
                "THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."
              ),
              !1)
            : this.backend.hasFeature(e);
        }
        hasInitialized() {
          return this._initialized;
        }
        async initTextureAsync(e) {
          !1 === this._initialized && (await this.init()),
            this._textures.updateTexture(e);
        }
        initTexture(e) {
          !1 === this._initialized &&
            console.warn(
              "THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."
            ),
            this._textures.updateTexture(e);
        }
        copyFramebufferToTexture(e, t = null) {
          let r;
          if (null !== t)
            if (t.isVector2)
              t = mp.set(t.x, t.y, e.image.width, e.image.height).floor();
            else {
              if (!t.isVector4)
                return void console.error(
                  "THREE.Renderer.copyFramebufferToTexture: Invalid rectangle."
                );
              t = mp.copy(t).floor();
            }
          else t = mp.set(0, 0, e.image.width, e.image.height);
          let i = this._currentRenderContext;
          null !== i
            ? (r = i.renderTarget)
            : null !==
                (r = this._renderTarget || this._getFrameBufferTarget()) &&
              (this._textures.updateRenderTarget(r),
              (i = this._textures.get(r))),
            this._textures.updateTexture(e, { renderTarget: r }),
            this.backend.copyFramebufferToTexture(e, i, t);
        }
        copyTextureToTexture(e, t, r = null, i = null, s = 0) {
          this._textures.updateTexture(e),
            this._textures.updateTexture(t),
            this.backend.copyTextureToTexture(e, t, r, i, s);
        }
        async readRenderTargetPixelsAsync(e, t, r, i, s, n = 0, a = 0) {
          return this.backend.copyTextureToBuffer(e.textures[n], t, r, i, s, a);
        }
        _projectObject(e, t, r, i, s) {
          if (!1 === e.visible) return;
          if (e.layers.test(t.layers)) {
            if (e.isGroup)
              (r = e.renderOrder),
                e.isClippingGroup && e.enabled && (s = s.getGroupContext(e));
            else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
            else if (e.isLight) i.pushLight(e);
            else if (e.isSprite) {
              if (!e.frustumCulled || mh.intersectsSprite(e)) {
                !0 === this.sortObjects &&
                  mp.setFromMatrixPosition(e.matrixWorld).applyMatrix4(mc);
                let { geometry: t, material: n } = e;
                n.visible && i.push(e, t, n, r, mp.z, null, s);
              }
            } else if (e.isLineLoop)
              console.error(
                "THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments."
              );
            else if (
              (e.isMesh || e.isLine || e.isPoints) &&
              (!e.frustumCulled || mh.intersectsObject(e))
            ) {
              let { geometry: t, material: n } = e;
              if (
                (!0 === this.sortObjects &&
                  (null === t.boundingSphere && t.computeBoundingSphere(),
                  mp
                    .copy(t.boundingSphere.center)
                    .applyMatrix4(e.matrixWorld)
                    .applyMatrix4(mc)),
                Array.isArray(n))
              ) {
                let a = t.groups;
                for (let o = 0, l = a.length; o < l; o++) {
                  let l = a[o],
                    u = n[l.materialIndex];
                  u && u.visible && i.push(e, t, u, r, mp.z, l, s);
                }
              } else n.visible && i.push(e, t, n, r, mp.z, null, s);
            }
          }
          if (!0 === e.isBundleGroup && void 0 !== this.backend.beginBundle) {
            let r = i;
            (i = this._renderLists.get(e, t)).begin(),
              r.pushBundle({ bundleGroup: e, camera: t, renderList: i }),
              i.finish();
          }
          let n = e.children;
          for (let e = 0, a = n.length; e < a; e++)
            this._projectObject(n[e], t, r, i, s);
        }
        _renderBundles(e, t, r) {
          for (let i of e) this._renderBundle(i, t, r);
        }
        _renderTransparents(e, t, r, i, s) {
          if (t.length > 0) {
            for (let { material: e } of t) e.side = u.hsX;
            for (let { material: e } of (this._renderObjects(
              t,
              r,
              i,
              s,
              "backSide"
            ),
            t))
              e.side = u.hB5;
            for (let { material: n } of (this._renderObjects(e, r, i, s), t))
              n.side = u.$EB;
          } else this._renderObjects(e, r, i, s);
        }
        _renderObjects(e, t, r, i, s = null) {
          for (let n = 0, a = e.length; n < a; n++) {
            let {
              object: a,
              geometry: o,
              material: l,
              group: u,
              clippingContext: d,
            } = e[n];
            this._currentRenderObjectFunction(a, r, t, o, l, u, i, d, s);
          }
        }
        renderObject(e, t, r, i, s, n, a, o = null, l = null) {
          let d, h, c;
          if (
            (e.onBeforeRender(this, t, r, i, s, n), null !== t.overrideMaterial)
          ) {
            let e = t.overrideMaterial;
            s.positionNode &&
              s.positionNode.isNode &&
              ((d = e.positionNode), (e.positionNode = s.positionNode)),
              (e.alphaTest = s.alphaTest),
              (e.alphaMap = s.alphaMap),
              (e.transparent = s.transparent || s.transmission > 0),
              e.isShadowPassMaterial &&
                ((e.side = null === s.shadowSide ? s.side : s.shadowSide),
                s.depthNode &&
                  s.depthNode.isNode &&
                  ((c = e.depthNode), (e.depthNode = s.depthNode)),
                s.castShadowNode &&
                  s.castShadowNode.isNode &&
                  ((h = e.colorNode), (e.colorNode = s.castShadowNode))),
              (s = e);
          }
          !0 === s.transparent && s.side === u.$EB && !1 === s.forceSinglePass
            ? ((s.side = u.hsX),
              this._handleObjectFunction(e, s, t, r, a, n, o, "backSide"),
              (s.side = u.hB5),
              this._handleObjectFunction(e, s, t, r, a, n, o, l),
              (s.side = u.$EB))
            : this._handleObjectFunction(e, s, t, r, a, n, o, l),
            void 0 !== d && (t.overrideMaterial.positionNode = d),
            void 0 !== c && (t.overrideMaterial.depthNode = c),
            void 0 !== h && (t.overrideMaterial.colorNode = h),
            e.onAfterRender(this, t, r, i, s, n);
        }
        _renderObjectDirect(e, t, r, i, s, n, a, o) {
          let l = this._objects.get(
            e,
            t,
            r,
            i,
            s,
            this._currentRenderContext,
            a,
            o
          );
          (l.drawRange = e.geometry.drawRange), (l.group = n);
          let u = this._nodes.needsRefresh(l);
          u &&
            (this._nodes.updateBefore(l),
            this._geometries.updateForRender(l),
            this._nodes.updateForRender(l),
            this._bindings.updateForRender(l)),
            this._pipelines.updateForRender(l),
            null !== this._currentRenderBundle &&
              (this.backend
                .get(this._currentRenderBundle)
                .renderObjects.push(l),
              (l.bundle = this._currentRenderBundle.bundleGroup)),
            this.backend.draw(l, this.info),
            u && this._nodes.updateAfter(l);
        }
        _createObjectPipeline(e, t, r, i, s, n, a, o) {
          let l = this._objects.get(
            e,
            t,
            r,
            i,
            s,
            this._currentRenderContext,
            a,
            o
          );
          (l.drawRange = e.geometry.drawRange),
            (l.group = n),
            this._nodes.updateBefore(l),
            this._geometries.updateForRender(l),
            this._nodes.updateForRender(l),
            this._bindings.updateForRender(l),
            this._pipelines.getForRender(l, this._compilationPromises),
            this._nodes.updateAfter(l);
        }
        get compile() {
          return this.compileAsync;
        }
      }
      class mm {
        constructor(e = "") {
          (this.name = e), (this.visibility = 0);
        }
        setVisibility(e) {
          this.visibility |= e;
        }
        clone() {
          return Object.assign(new this.constructor(), this);
        }
      }
      class mf extends mm {
        constructor(e, t = null) {
          super(e),
            (this.isBuffer = !0),
            (this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT),
            (this._buffer = t);
        }
        get byteLength() {
          var e;
          return (e = this._buffer.byteLength) + ((16 - (e % 16)) % 16);
        }
        get buffer() {
          return this._buffer;
        }
        update() {
          return !0;
        }
      }
      class my extends mf {
        constructor(e, t = null) {
          super(e, t), (this.isUniformBuffer = !0);
        }
      }
      let mx = 0;
      class mb extends my {
        constructor(e, t) {
          super("UniformBuffer_" + mx++, e ? e.value : null),
            (this.nodeUniform = e),
            (this.groupNode = t);
        }
        get buffer() {
          return this.nodeUniform.value;
        }
      }
      class mT extends my {
        constructor(e) {
          super(e),
            (this.isUniformsGroup = !0),
            (this._values = null),
            (this.uniforms = []);
        }
        addUniform(e) {
          return this.uniforms.push(e), this;
        }
        removeUniform(e) {
          let t = this.uniforms.indexOf(e);
          return -1 !== t && this.uniforms.splice(t, 1), this;
        }
        get values() {
          return (
            null === this._values && (this._values = Array.from(this.buffer)),
            this._values
          );
        }
        get buffer() {
          let e = this._buffer;
          return (
            null === e &&
              ((e = new Float32Array(new ArrayBuffer(this.byteLength))),
              (this._buffer = e)),
            e
          );
        }
        get byteLength() {
          let e = 0;
          for (let t = 0, r = this.uniforms.length; t < r; t++) {
            let r = this.uniforms[t],
              { boundary: i, itemSize: s } = r,
              n = e % 16,
              a = 16 - n;
            0 !== n && a - i < 0 ? (e += 16 - n) : n % i != 0 && (e += n % i),
              (r.offset = e / this.bytesPerElement),
              (e += s * this.bytesPerElement);
          }
          return 16 * Math.ceil(e / 16);
        }
        update() {
          let e = !1;
          for (let t of this.uniforms) !0 === this.updateByType(t) && (e = !0);
          return e;
        }
        updateByType(e) {
          return e.isNumberUniform
            ? this.updateNumber(e)
            : e.isVector2Uniform
            ? this.updateVector2(e)
            : e.isVector3Uniform
            ? this.updateVector3(e)
            : e.isVector4Uniform
            ? this.updateVector4(e)
            : e.isColorUniform
            ? this.updateColor(e)
            : e.isMatrix3Uniform
            ? this.updateMatrix3(e)
            : e.isMatrix4Uniform
            ? this.updateMatrix4(e)
            : void console.error(
                "THREE.WebGPUUniformsGroup: Unsupported uniform type.",
                e
              );
        }
        updateNumber(e) {
          let t = !1,
            r = this.values,
            i = e.getValue(),
            s = e.offset,
            n = e.getType();
          return (
            r[s] !== i && ((this._getBufferForType(n)[s] = r[s] = i), (t = !0)),
            t
          );
        }
        updateVector2(e) {
          let t = !1,
            r = this.values,
            i = e.getValue(),
            s = e.offset,
            n = e.getType();
          if (r[s + 0] !== i.x || r[s + 1] !== i.y) {
            let e = this._getBufferForType(n);
            (e[s + 0] = r[s + 0] = i.x), (e[s + 1] = r[s + 1] = i.y), (t = !0);
          }
          return t;
        }
        updateVector3(e) {
          let t = !1,
            r = this.values,
            i = e.getValue(),
            s = e.offset,
            n = e.getType();
          if (r[s + 0] !== i.x || r[s + 1] !== i.y || r[s + 2] !== i.z) {
            let e = this._getBufferForType(n);
            (e[s + 0] = r[s + 0] = i.x),
              (e[s + 1] = r[s + 1] = i.y),
              (e[s + 2] = r[s + 2] = i.z),
              (t = !0);
          }
          return t;
        }
        updateVector4(e) {
          let t = !1,
            r = this.values,
            i = e.getValue(),
            s = e.offset,
            n = e.getType();
          if (
            r[s + 0] !== i.x ||
            r[s + 1] !== i.y ||
            r[s + 2] !== i.z ||
            r[s + 4] !== i.w
          ) {
            let e = this._getBufferForType(n);
            (e[s + 0] = r[s + 0] = i.x),
              (e[s + 1] = r[s + 1] = i.y),
              (e[s + 2] = r[s + 2] = i.z),
              (e[s + 3] = r[s + 3] = i.w),
              (t = !0);
          }
          return t;
        }
        updateColor(e) {
          let t = !1,
            r = this.values,
            i = e.getValue(),
            s = e.offset;
          if (r[s + 0] !== i.r || r[s + 1] !== i.g || r[s + 2] !== i.b) {
            let e = this.buffer;
            (e[s + 0] = r[s + 0] = i.r),
              (e[s + 1] = r[s + 1] = i.g),
              (e[s + 2] = r[s + 2] = i.b),
              (t = !0);
          }
          return t;
        }
        updateMatrix3(e) {
          let t = !1,
            r = this.values,
            i = e.getValue().elements,
            s = e.offset;
          if (
            r[s + 0] !== i[0] ||
            r[s + 1] !== i[1] ||
            r[s + 2] !== i[2] ||
            r[s + 4] !== i[3] ||
            r[s + 5] !== i[4] ||
            r[s + 6] !== i[5] ||
            r[s + 8] !== i[6] ||
            r[s + 9] !== i[7] ||
            r[s + 10] !== i[8]
          ) {
            let e = this.buffer;
            (e[s + 0] = r[s + 0] = i[0]),
              (e[s + 1] = r[s + 1] = i[1]),
              (e[s + 2] = r[s + 2] = i[2]),
              (e[s + 4] = r[s + 4] = i[3]),
              (e[s + 5] = r[s + 5] = i[4]),
              (e[s + 6] = r[s + 6] = i[5]),
              (e[s + 8] = r[s + 8] = i[6]),
              (e[s + 9] = r[s + 9] = i[7]),
              (e[s + 10] = r[s + 10] = i[8]),
              (t = !0);
          }
          return t;
        }
        updateMatrix4(e) {
          let t = !1,
            r = this.values,
            i = e.getValue().elements,
            s = e.offset;
          return (
            !1 ===
              (function (e, t, r) {
                for (let i = 0, s = t.length; i < s; i++)
                  if (e[r + i] !== t[i]) return !1;
                return !0;
              })(r, i, s) &&
              (this.buffer.set(i, s),
              (function (e, t, r) {
                for (let i = 0, s = t.length; i < s; i++) e[r + i] = t[i];
              })(r, i, s),
              (t = !0)),
            t
          );
        }
        _getBufferForType(e) {
          return "int" === e || "ivec2" === e || "ivec3" === e || "ivec4" === e
            ? new Int32Array(this.buffer.buffer)
            : "uint" === e || "uvec2" === e || "uvec3" === e || "uvec4" === e
            ? new Uint32Array(this.buffer.buffer)
            : this.buffer;
        }
      }
      let m_ = 0;
      class mv extends mT {
        constructor(e, t) {
          super(e),
            (this.id = m_++),
            (this.groupNode = t),
            (this.isNodeUniformsGroup = !0);
        }
      }
      let mN = 0;
      class mS extends mm {
        constructor(e, t) {
          super(e),
            (this.id = mN++),
            (this.texture = t),
            (this.version = t ? t.version : 0),
            (this.store = !1),
            (this.generation = null),
            (this.isSampledTexture = !0);
        }
        needsBindingsUpdate(e) {
          let { texture: t } = this;
          return e !== this.generation
            ? ((this.generation = e), !0)
            : t.isVideoTexture;
        }
        update() {
          let { texture: e, version: t } = this;
          return t !== e.version && ((this.version = e.version), !0);
        }
      }
      class mR extends mS {
        constructor(e, t, r, i = null) {
          super(e, t ? t.value : null),
            (this.textureNode = t),
            (this.groupNode = r),
            (this.access = i);
        }
        needsBindingsUpdate(e) {
          return (
            this.textureNode.value !== this.texture ||
            super.needsBindingsUpdate(e)
          );
        }
        update() {
          let { textureNode: e } = this;
          return this.texture !== e.value
            ? ((this.texture = e.value), !0)
            : super.update();
        }
      }
      class mA extends mR {
        constructor(e, t, r, i = null) {
          super(e, t, r, i), (this.isSampledCubeTexture = !0);
        }
      }
      class mC extends mR {
        constructor(e, t, r, i = null) {
          super(e, t, r, i), (this.isSampledTexture3D = !0);
        }
      }
      let mE = { textureDimensions: "textureSize", equals: "equal" },
        mw = { low: "lowp", medium: "mediump", high: "highp" },
        mM = { swizzleAssign: !0, storageBuffer: !1 },
        mB = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
      class mF extends gw {
        constructor(e, t) {
          super(e, t, new gQ()),
            (this.uniformGroups = {}),
            (this.transforms = []),
            (this.extensions = {}),
            (this.builtins = { vertex: [], fragment: [], compute: [] }),
            (this.useComparisonMethod = !0);
        }
        needsToWorkingColorSpace(e) {
          return !0 === e.isVideoTexture && e.colorSpace !== u.jf0;
        }
        getMethod(e) {
          return mE[e] || e;
        }
        getOutputStructName() {
          return "";
        }
        buildFunctionCode(e) {
          let t = e.layout,
            r = this.flowShaderNode(e),
            i = [];
          for (let e of t.inputs) i.push(this.getType(e.type) + " " + e.name);
          return `${this.getType(t.type)} ${t.name}( ${i.join(", ")} ) {

	${r.vars}

${r.code}
	return ${r.result};

}`;
        }
        setupPBO(e) {
          let t = e.value;
          if (void 0 === t.pbo) {
            let e = t.array,
              r = t.count * t.itemSize,
              { itemSize: i } = t,
              s = t.array.constructor.name.toLowerCase().includes("int"),
              n = s ? u.ZQM : u.VT0;
            2 === i
              ? (n = s ? u.TkQ : u.paN)
              : 3 === i
              ? (n = s ? u.VGF : u.HIg)
              : 4 === i && (n = s ? u.c90 : u.GWd);
            let a = {
                Float32Array: u.RQf,
                Uint8Array: u.OUM,
                Uint16Array: u.cHt,
                Uint32Array: u.bkx,
                Int8Array: u.tJf,
                Int16Array: u.fBL,
                Int32Array: u.Yuy,
                Uint8ClampedArray: u.OUM,
              },
              o = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(r / i)))),
              l = Math.ceil(r / i / o);
            o * l * i < r && l++;
            let d = o * l * i,
              h = new e.constructor(d);
            h.set(e, 0), (t.array = h);
            let c = new u.GYF(
              t.array,
              o,
              l,
              n,
              a[t.array.constructor.name] || u.RQf
            );
            (c.needsUpdate = !0), (c.isPBOTexture = !0);
            let p = new i3(c, null, null);
            p.setPrecision("high"),
              (t.pboNode = p),
              (t.pbo = p.value),
              this.getUniformFromNode(
                t.pboNode,
                "texture",
                this.shaderStage,
                this.context.label
              );
          }
        }
        getPropertyName(e, t = this.shaderStage) {
          return e.isNodeUniform &&
            !0 !== e.node.isTextureNode &&
            !0 !== e.node.isBufferNode
            ? t.charAt(0) + "_" + e.name
            : super.getPropertyName(e, t);
        }
        generatePBO(e) {
          let { node: t, indexNode: r } = e,
            i = t.value;
          this.renderer.backend.has(i) &&
            (this.renderer.backend.get(i).pbo = i.pbo);
          let s = this.getUniformFromNode(
              i.pboNode,
              "texture",
              this.shaderStage,
              this.context.label
            ),
            n = this.getPropertyName(s);
          this.increaseUsage(r);
          let a = r.build(this, "uint"),
            o = this.getDataFromNode(e),
            l = o.propertyName;
          if (void 0 === l) {
            let r = this.getVarFromNode(e);
            l = this.getPropertyName(r);
            let s = this.getDataFromNode(t),
              d = s.propertySizeName;
            void 0 === d &&
              ((d = l + "Size"),
              this.getVarFromNode(t, d, "uint"),
              this.addLineFlowCode(
                `${d} = uint( textureSize( ${n}, 0 ).x )`,
                e
              ),
              (s.propertySizeName = d));
            let { itemSize: h } = i,
              c = "." + L.join("").slice(0, h),
              p = `ivec2(${a} % ${d}, ${a} / ${d})`,
              g = this.generateTextureLoad(null, n, p, null, "0"),
              m = "vec4";
            i.pbo.type === u.bkx
              ? (m = "uvec4")
              : i.pbo.type === u.Yuy && (m = "ivec4"),
              this.addLineFlowCode(`${l} = ${m}(${g})${c}`, e),
              (o.propertyName = l);
          }
          return l;
        }
        generateTextureLoad(e, t, r, i, s = "0") {
          return i
            ? `texelFetch( ${t}, ivec3( ${r}, ${i} ), ${s} )`
            : `texelFetch( ${t}, ${r}, ${s} )`;
        }
        generateTexture(e, t, r, i) {
          return e.isDepthTexture
            ? `texture( ${t}, ${r} ).x`
            : (i && (r = `vec3( ${r}, ${i} )`), `texture( ${t}, ${r} )`);
        }
        generateTextureLevel(e, t, r, i) {
          return `textureLod( ${t}, ${r}, ${i} )`;
        }
        generateTextureBias(e, t, r, i) {
          return `texture( ${t}, ${r}, ${i} )`;
        }
        generateTextureGrad(e, t, r, i) {
          return `textureGrad( ${t}, ${r}, ${i[0]}, ${i[1]} )`;
        }
        generateTextureCompare(e, t, r, i, s, n = this.shaderStage) {
          if ("fragment" === n) return `texture( ${t}, vec3( ${r}, ${i} ) )`;
          console.error(
            `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${n} shader.`
          );
        }
        getVars(e) {
          let t = [],
            r = this.vars[e];
          if (void 0 !== r)
            for (let e of r) t.push(`${this.getVar(e.type, e.name, e.count)};`);
          return t.join("\n	");
        }
        getUniforms(e) {
          let t = this.uniforms[e],
            r = [],
            i = {};
          for (let s of t) {
            let t = null,
              n = !1;
            if ("texture" === s.type || "texture3D" === s.type) {
              let e = s.node.value,
                r = "";
              (!0 === e.isDataTexture || !0 === e.isData3DTexture) &&
                (e.type === u.bkx ? (r = "u") : e.type === u.Yuy && (r = "i")),
                (t =
                  "texture3D" === s.type
                    ? `${r}sampler3D ${s.name};`
                    : e.compareFunction
                    ? `sampler2DShadow ${s.name};`
                    : !0 === e.isDataArrayTexture ||
                      !0 === e.isCompressedArrayTexture
                    ? `${r}sampler2DArray ${s.name};`
                    : `${r}sampler2D ${s.name};`);
            } else if ("cubeTexture" === s.type) t = `samplerCube ${s.name};`;
            else if ("buffer" === s.type) {
              let e = s.node,
                r = this.getType(e.bufferType),
                i = e.bufferCount,
                n = i > 0 ? i : "";
              t = `${e.name} {
	${r} ${s.name}[${n}];
};
`;
            } else {
              let r = this.getVectorType(s.type);
              (t = `${r} ${this.getPropertyName(s, e)};`), (n = !0);
            }
            let a = s.node.precision;
            if ((null !== a && (t = mw[a] + " " + t), n)) {
              t = "	" + t;
              let e = s.groupNode.name;
              (i[e] || (i[e] = [])).push(t);
            } else (t = "uniform " + t), r.push(t);
          }
          let s = "";
          for (let t in i) {
            let r = i[t];
            s += this._getGLSLUniformStruct(e + "_" + t, r.join("\n")) + "\n";
          }
          return s + r.join("\n");
        }
        getTypeFromAttribute(e) {
          let t = super.getTypeFromAttribute(e);
          if (/^[iu]/.test(t) && e.gpuType !== u.Yuy) {
            let r = e;
            e.isInterleavedBufferAttribute && (r = e.data);
            let i = r.array;
            !1 == (i instanceof Uint32Array || i instanceof Int32Array) &&
              (t = t.slice(1));
          }
          return t;
        }
        getAttributes(e) {
          let t = "";
          if ("vertex" === e || "compute" === e) {
            let e = this.getAttributesArray(),
              r = 0;
            for (let i of e)
              t += `layout( location = ${r++} ) in ${i.type} ${i.name};
`;
          }
          return t;
        }
        getStructMembers(e) {
          let t = [];
          for (let r of e.members) t.push(`	${r.type} ${r.name};`);
          return t.join("\n");
        }
        getStructs(e) {
          let t = [],
            r = this.structs[e],
            i = [];
          for (let e of r)
            if (e.output)
              for (let t of e.members)
                i.push(
                  `layout( location = ${t.index} ) out ${t.type} ${t.name};`
                );
            else {
              let r = "struct " + e.name + " {\n";
              (r += this.getStructMembers(e)), (r += "\n};\n"), t.push(r);
            }
          return (
            0 === i.length &&
              i.push("layout( location = 0 ) out vec4 fragColor;"),
            "\n" + i.join("\n") + "\n\n" + t.join("\n")
          );
        }
        getVaryings(e) {
          let t = "",
            r = this.varyings;
          if ("vertex" === e || "compute" === e)
            for (let i of r) {
              "compute" === e && (i.needsInterpolation = !0);
              let r = this.getType(i.type);
              if (i.needsInterpolation) {
                let e =
                  r.includes("int") || r.includes("uv") || r.includes("iv")
                    ? "flat "
                    : "";
                t += `${e} out ${r} ${i.name};
`;
              } else
                t += `${r} ${i.name};
`;
            }
          else if ("fragment" === e) {
            for (let e of r)
              if (e.needsInterpolation) {
                let r = this.getType(e.type),
                  i =
                    r.includes("int") || r.includes("uv") || r.includes("iv")
                      ? "flat "
                      : "";
                t += `${i}in ${r} ${e.name};
`;
              }
          }
          for (let r of this.builtins[e])
            t += `${r};
`;
          return t;
        }
        getVertexIndex() {
          return "uint( gl_VertexID )";
        }
        getInstanceIndex() {
          return "uint( gl_InstanceID )";
        }
        getInvocationLocalIndex() {
          let e = this.object.workgroupSize.reduce((e, t) => e * t, 1);
          return `uint( gl_InstanceID ) % ${e}u`;
        }
        getDrawIndex() {
          return this.renderer.backend.extensions.has("WEBGL_multi_draw")
            ? "uint( gl_DrawID )"
            : null;
        }
        getFrontFacing() {
          return "gl_FrontFacing";
        }
        getFragCoord() {
          return "gl_FragCoord.xy";
        }
        getFragDepth() {
          return "gl_FragDepth";
        }
        enableExtension(e, t, r = this.shaderStage) {
          let i = this.extensions[r] || (this.extensions[r] = new Map());
          !1 === i.has(e) && i.set(e, { name: e, behavior: t });
        }
        getExtensions(e) {
          let t = [];
          if ("vertex" === e) {
            let t = this.renderer.backend.extensions;
            this.object.isBatchedMesh &&
              t.has("WEBGL_multi_draw") &&
              this.enableExtension("GL_ANGLE_multi_draw", "require", e);
          }
          let r = this.extensions[e];
          if (void 0 !== r)
            for (let { name: e, behavior: i } of r.values())
              t.push(`#extension ${e} : ${i}`);
          return t.join("\n");
        }
        getClipDistance() {
          return "gl_ClipDistance";
        }
        isAvailable(e) {
          let t = mM[e];
          if (void 0 === t) {
            let r;
            switch (((t = !1), e)) {
              case "float32Filterable":
                r = "OES_texture_float_linear";
                break;
              case "clipDistance":
                r = "WEBGL_clip_cull_distance";
            }
            if (void 0 !== r) {
              let e = this.renderer.backend.extensions;
              e.has(r) && (e.get(r), (t = !0));
            }
            mM[e] = t;
          }
          return t;
        }
        isFlipY() {
          return !0;
        }
        enableHardwareClipping(e) {
          this.enableExtension("GL_ANGLE_clip_cull_distance", "require"),
            this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`);
        }
        registerTransform(e, t) {
          this.transforms.push({ varyingName: e, attributeNode: t });
        }
        getTransforms() {
          let e = this.transforms,
            t = "";
          for (let r = 0; r < e.length; r++) {
            let i = e[r],
              s = this.getPropertyName(i.attributeNode);
            t += `${i.varyingName} = ${s};
	`;
          }
          return t;
        }
        _getGLSLUniformStruct(e, t) {
          return `
layout( std140 ) uniform ${e} {
${t}
};`;
        }
        _getGLSLVertexCode(e) {
          return `#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${mB}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
        }
        _getGLSLFragmentCode(e) {
          return `#version 300 es

${this.getSignature()}

// precision
${mB}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

// structs
${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        buildCode() {
          let e =
            null !== this.material
              ? { fragment: {}, vertex: {} }
              : { compute: {} };
          for (let t in (this.sortBindingGroups(), e)) {
            let r = "// code\n\n";
            r += this.flowCode[t];
            let i = this.flowNodes[t],
              s = i[i.length - 1];
            for (let e of i) {
              let i = this.getFlowData(e),
                n = e.name;
              n &&
                (r.length > 0 && (r += "\n"),
                (r += `	// flow -> ${n}
	`)),
                (r += `${i.code}
	`),
                e === s &&
                  "compute" !== t &&
                  ((r += "// result\n	"),
                  "vertex" === t
                    ? ((r += "gl_Position = "), (r += `${i.result};`))
                    : "fragment" !== t ||
                      e.outputNode.isOutputStructNode ||
                      ((r += "fragColor = "), (r += `${i.result};`)));
            }
            let n = e[t];
            (n.extensions = this.getExtensions(t)),
              (n.uniforms = this.getUniforms(t)),
              (n.attributes = this.getAttributes(t)),
              (n.varyings = this.getVaryings(t)),
              (n.vars = this.getVars(t)),
              (n.structs = this.getStructs(t)),
              (n.codes = this.getCodes(t)),
              (n.transforms = this.getTransforms(t)),
              (n.flow = r);
          }
          null !== this.material
            ? ((this.vertexShader = this._getGLSLVertexCode(e.vertex)),
              (this.fragmentShader = this._getGLSLFragmentCode(e.fragment)))
            : (this.computeShader = this._getGLSLVertexCode(e.compute));
        }
        getUniformFromNode(e, t, r, i = null) {
          let s = super.getUniformFromNode(e, t, r, i),
            n = this.getDataFromNode(e, r, this.globalCache),
            a = n.uniformGPU;
          if (void 0 === a) {
            let i = e.groupNode,
              o = i.name,
              l = this.getBindGroupArray(o, r);
            if ("texture" === t) (a = new mR(s.name, s.node, i)), l.push(a);
            else if ("cubeTexture" === t)
              (a = new mA(s.name, s.node, i)), l.push(a);
            else if ("texture3D" === t)
              (a = new mC(s.name, s.node, i)), l.push(a);
            else if ("buffer" === t) {
              (e.name = `NodeBuffer_${e.id}`), (s.name = `buffer${e.id}`);
              let t = new mb(e, i);
              (t.name = e.name), l.push(t), (a = t);
            } else {
              let e = this.uniformGroups[r] || (this.uniformGroups[r] = {}),
                n = e[o];
              void 0 === n &&
                ((n = new mv(r + "_" + o, i)), (e[o] = n), l.push(n)),
                (a = this.getNodeUniform(s, t)),
                n.addUniform(a);
            }
            n.uniformGPU = a;
          }
          return s;
        }
      }
      let mU = null,
        mI = null;
      class mP {
        constructor(e = {}) {
          (this.parameters = Object.assign({}, e)),
            (this.data = new WeakMap()),
            (this.renderer = null),
            (this.domElement = null),
            (this.timestampQueryPool = { render: null, compute: null });
        }
        async init(e) {
          this.renderer = e;
        }
        get coordinateSystem() {}
        beginRender() {}
        finishRender() {}
        beginCompute() {}
        finishCompute() {}
        draw() {}
        compute() {}
        createProgram() {}
        destroyProgram() {}
        createBindings() {}
        updateBindings() {}
        updateBinding() {}
        createRenderPipeline() {}
        createComputePipeline() {}
        needsRenderUpdate() {}
        getRenderCacheKey() {}
        createNodeBuilder() {}
        createSampler() {}
        destroySampler() {}
        createDefaultTexture() {}
        createTexture() {}
        updateTexture() {}
        generateMipmaps() {}
        destroyTexture() {}
        async copyTextureToBuffer() {}
        copyTextureToTexture() {}
        copyFramebufferToTexture() {}
        createAttribute() {}
        createIndexAttribute() {}
        createStorageAttribute() {}
        updateAttribute() {}
        destroyAttribute() {}
        getContext() {}
        updateSize() {}
        updateViewport() {}
        isOccluded() {}
        async resolveTimestampsAsync(e = "render") {
          if (!this.trackTimestamp)
            return void (0, u.mcG)(
              "WebGPURenderer: Timestamp tracking is disabled."
            );
          let t = this.timestampQueryPool[e];
          if (!t)
            return void (0, u.mcG)(
              `WebGPURenderer: No timestamp query pool for type '${e}' found.`
            );
          let r = await t.resolveQueriesAsync();
          return (this.renderer.info[e].timestamp = r), r;
        }
        async waitForGPU() {}
        async getArrayBufferAsync() {}
        async hasFeatureAsync() {}
        hasFeature() {}
        getMaxAnisotropy() {}
        getDrawingBufferSize() {
          return (
            (mU = mU || new u.I9Y()), this.renderer.getDrawingBufferSize(mU)
          );
        }
        setScissorTest() {}
        getClearColor() {
          let e = this.renderer;
          return (mI = mI || new da()), e.getClearColor(mI), mI.getRGB(mI), mI;
        }
        getDomElement() {
          let e = this.domElement;
          return (
            null === e &&
              ("setAttribute" in
                (e =
                  void 0 !== this.parameters.canvas
                    ? this.parameters.canvas
                    : (0, u.lPF)()) &&
                e.setAttribute("data-engine", `three.js r${u.sPf} webgpu`),
              (this.domElement = e)),
            e
          );
        }
        set(e, t) {
          this.data.set(e, t);
        }
        get(e) {
          let t = this.data.get(e);
          return void 0 === t && ((t = {}), this.data.set(e, t)), t;
        }
        has(e) {
          return this.data.has(e);
        }
        delete(e) {
          this.data.delete(e);
        }
        dispose() {}
      }
      let mL = 0;
      class mD {
        constructor(e, t) {
          (this.buffers = [e.bufferGPU, t]),
            (this.type = e.type),
            (this.bufferType = e.bufferType),
            (this.pbo = e.pbo),
            (this.byteLength = e.byteLength),
            (this.bytesPerElement = e.BYTES_PER_ELEMENT),
            (this.version = e.version),
            (this.isInteger = e.isInteger),
            (this.activeBufferIndex = 0),
            (this.baseId = e.id);
        }
        get id() {
          return `${this.baseId}|${this.activeBufferIndex}`;
        }
        get bufferGPU() {
          return this.buffers[this.activeBufferIndex];
        }
        get transformBuffer() {
          return this.buffers[1 ^ this.activeBufferIndex];
        }
        switchBuffers() {
          this.activeBufferIndex ^= 1;
        }
      }
      class mV {
        constructor(e) {
          this.backend = e;
        }
        createAttribute(e, t) {
          let r,
            i = this.backend,
            { gl: s } = i,
            n = e.array,
            a = e.usage || s.STATIC_DRAW,
            o = e.isInterleavedBufferAttribute ? e.data : e,
            l = i.get(o),
            d = l.bufferGPU;
          if (
            (void 0 === d &&
              ((l.bufferGPU = d = this._createBuffer(s, t, n, a)),
              (l.bufferType = t),
              (l.version = o.version)),
            n instanceof Float32Array)
          )
            r = s.FLOAT;
          else if (n instanceof Uint16Array)
            r = e.isFloat16BufferAttribute ? s.HALF_FLOAT : s.UNSIGNED_SHORT;
          else if (n instanceof Int16Array) r = s.SHORT;
          else if (n instanceof Uint32Array) r = s.UNSIGNED_INT;
          else if (n instanceof Int32Array) r = s.INT;
          else if (n instanceof Int8Array) r = s.BYTE;
          else if (n instanceof Uint8Array) r = s.UNSIGNED_BYTE;
          else if (n instanceof Uint8ClampedArray) r = s.UNSIGNED_BYTE;
          else
            throw Error(
              "THREE.WebGLBackend: Unsupported buffer data format: " + n
            );
          let h = {
            bufferGPU: d,
            bufferType: t,
            type: r,
            byteLength: n.byteLength,
            bytesPerElement: n.BYTES_PER_ELEMENT,
            version: e.version,
            pbo: e.pbo,
            isInteger:
              r === s.INT || r === s.UNSIGNED_INT || e.gpuType === u.Yuy,
            id: mL++,
          };
          (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) &&
            (h = new mD(h, this._createBuffer(s, t, n, a))),
            i.set(e, h);
        }
        updateAttribute(e) {
          let t = this.backend,
            { gl: r } = t,
            i = e.array,
            s = e.isInterleavedBufferAttribute ? e.data : e,
            n = t.get(s),
            a = n.bufferType,
            o = e.isInterleavedBufferAttribute
              ? e.data.updateRanges
              : e.updateRanges;
          if ((r.bindBuffer(a, n.bufferGPU), 0 === o.length))
            r.bufferSubData(a, 0, i);
          else {
            for (let e = 0, t = o.length; e < t; e++) {
              let t = o[e];
              r.bufferSubData(
                a,
                t.start * i.BYTES_PER_ELEMENT,
                i,
                t.start,
                t.count
              );
            }
            s.clearUpdateRanges();
          }
          r.bindBuffer(a, null), (n.version = s.version);
        }
        destroyAttribute(e) {
          let t = this.backend,
            { gl: r } = t;
          e.isInterleavedBufferAttribute && t.delete(e.data);
          let i = t.get(e);
          r.deleteBuffer(i.bufferGPU), t.delete(e);
        }
        async getArrayBufferAsync(e) {
          let t = this.backend,
            { gl: r } = t,
            i = e.isInterleavedBufferAttribute ? e.data : e,
            { bufferGPU: s } = t.get(i),
            n = e.array,
            a = n.byteLength;
          r.bindBuffer(r.COPY_READ_BUFFER, s);
          let o = r.createBuffer();
          r.bindBuffer(r.COPY_WRITE_BUFFER, o),
            r.bufferData(r.COPY_WRITE_BUFFER, a, r.STREAM_READ),
            r.copyBufferSubData(
              r.COPY_READ_BUFFER,
              r.COPY_WRITE_BUFFER,
              0,
              0,
              a
            ),
            await t.utils._clientWaitAsync();
          let l = new e.array.constructor(n.length);
          return (
            r.bindBuffer(r.COPY_WRITE_BUFFER, o),
            r.getBufferSubData(r.COPY_WRITE_BUFFER, 0, l),
            r.deleteBuffer(o),
            r.bindBuffer(r.COPY_READ_BUFFER, null),
            r.bindBuffer(r.COPY_WRITE_BUFFER, null),
            l.buffer
          );
        }
        _createBuffer(e, t, r, i) {
          let s = e.createBuffer();
          return (
            e.bindBuffer(t, s), e.bufferData(t, r, i), e.bindBuffer(t, null), s
          );
        }
      }
      class mO {
        constructor(e) {
          (this.backend = e),
            (this.gl = this.backend.gl),
            (this.enabled = {}),
            (this.currentFlipSided = null),
            (this.currentCullFace = null),
            (this.currentProgram = null),
            (this.currentBlendingEnabled = !1),
            (this.currentBlending = null),
            (this.currentBlendSrc = null),
            (this.currentBlendDst = null),
            (this.currentBlendSrcAlpha = null),
            (this.currentBlendDstAlpha = null),
            (this.currentPremultipledAlpha = null),
            (this.currentPolygonOffsetFactor = null),
            (this.currentPolygonOffsetUnits = null),
            (this.currentColorMask = null),
            (this.currentDepthFunc = null),
            (this.currentDepthMask = null),
            (this.currentStencilFunc = null),
            (this.currentStencilRef = null),
            (this.currentStencilFuncMask = null),
            (this.currentStencilFail = null),
            (this.currentStencilZFail = null),
            (this.currentStencilZPass = null),
            (this.currentStencilMask = null),
            (this.currentLineWidth = null),
            (this.currentClippingPlanes = 0),
            (this.currentVAO = null),
            (this.currentIndex = null),
            (this.currentBoundFramebuffers = {}),
            (this.currentDrawbuffers = new WeakMap()),
            (this.maxTextures = this.gl.getParameter(
              this.gl.MAX_TEXTURE_IMAGE_UNITS
            )),
            (this.currentTextureSlot = null),
            (this.currentBoundTextures = {}),
            (this.currentBoundBufferBases = {}),
            this._init();
        }
        _init() {
          let e = this.gl;
          (o = {
            [u.gO9]: e.FUNC_ADD,
            [u.FXf]: e.FUNC_SUBTRACT,
            [u.nST]: e.FUNC_REVERSE_SUBTRACT,
          }),
            (l = {
              [u.ojh]: e.ZERO,
              [u.qad]: e.ONE,
              [u.f4X]: e.SRC_COLOR,
              [u.ie2]: e.SRC_ALPHA,
              [u.hgQ]: e.SRC_ALPHA_SATURATE,
              [u.wn6]: e.DST_COLOR,
              [u.hdd]: e.DST_ALPHA,
              [u.LiQ]: e.ONE_MINUS_SRC_COLOR,
              [u.OuU]: e.ONE_MINUS_SRC_ALPHA,
              [u.aEY]: e.ONE_MINUS_DST_COLOR,
              [u.Nt7]: e.ONE_MINUS_DST_ALPHA,
            });
          let t = e.getParameter(e.SCISSOR_BOX),
            r = e.getParameter(e.VIEWPORT);
          (this.currentScissor = new u.IUQ().fromArray(t)),
            (this.currentViewport = new u.IUQ().fromArray(r)),
            (this._tempVec4 = new u.IUQ());
        }
        enable(e) {
          let { enabled: t } = this;
          !0 !== t[e] && (this.gl.enable(e), (t[e] = !0));
        }
        disable(e) {
          let { enabled: t } = this;
          !1 !== t[e] && (this.gl.disable(e), (t[e] = !1));
        }
        setFlipSided(e) {
          if (this.currentFlipSided !== e) {
            let { gl: t } = this;
            e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
              (this.currentFlipSided = e);
          }
        }
        setCullFace(e) {
          let { gl: t } = this;
          e !== u.WNZ
            ? (this.enable(t.CULL_FACE),
              e !== this.currentCullFace &&
                (e === u.Vb5
                  ? t.cullFace(t.BACK)
                  : e === u.Jnc
                  ? t.cullFace(t.FRONT)
                  : t.cullFace(t.FRONT_AND_BACK)))
            : this.disable(t.CULL_FACE),
            (this.currentCullFace = e);
        }
        setLineWidth(e) {
          let { currentLineWidth: t, gl: r } = this;
          e !== t && (r.lineWidth(e), (this.currentLineWidth = e));
        }
        setBlending(e, t, r, i, s, n, a, d) {
          let { gl: h } = this;
          if (e === u.XIg) {
            !0 === this.currentBlendingEnabled &&
              (this.disable(h.BLEND), (this.currentBlendingEnabled = !1));
            return;
          }
          if (
            (!1 === this.currentBlendingEnabled &&
              (this.enable(h.BLEND), (this.currentBlendingEnabled = !0)),
            e !== u.bCz)
          ) {
            if (
              e !== this.currentBlending ||
              d !== this.currentPremultipledAlpha
            ) {
              if (
                ((this.currentBlendEquation !== u.gO9 ||
                  this.currentBlendEquationAlpha !== u.gO9) &&
                  (h.blendEquation(h.FUNC_ADD),
                  (this.currentBlendEquation = u.gO9),
                  (this.currentBlendEquationAlpha = u.gO9)),
                d)
              )
                switch (e) {
                  case u.NTi:
                    h.blendFuncSeparate(
                      h.ONE,
                      h.ONE_MINUS_SRC_ALPHA,
                      h.ONE,
                      h.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case u.EZo:
                    h.blendFunc(h.ONE, h.ONE);
                    break;
                  case u.Kwu:
                    h.blendFuncSeparate(
                      h.ZERO,
                      h.ONE_MINUS_SRC_COLOR,
                      h.ZERO,
                      h.ONE
                    );
                    break;
                  case u.EdD:
                    h.blendFuncSeparate(
                      h.ZERO,
                      h.SRC_COLOR,
                      h.ZERO,
                      h.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              else
                switch (e) {
                  case u.NTi:
                    h.blendFuncSeparate(
                      h.SRC_ALPHA,
                      h.ONE_MINUS_SRC_ALPHA,
                      h.ONE,
                      h.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case u.EZo:
                    h.blendFunc(h.SRC_ALPHA, h.ONE);
                    break;
                  case u.Kwu:
                    h.blendFuncSeparate(
                      h.ZERO,
                      h.ONE_MINUS_SRC_COLOR,
                      h.ZERO,
                      h.ONE
                    );
                    break;
                  case u.EdD:
                    h.blendFunc(h.ZERO, h.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              (this.currentBlendSrc = null),
                (this.currentBlendDst = null),
                (this.currentBlendSrcAlpha = null),
                (this.currentBlendDstAlpha = null),
                (this.currentBlending = e),
                (this.currentPremultipledAlpha = d);
            }
            return;
          }
          (s = s || t),
            (n = n || r),
            (a = a || i),
            (t !== this.currentBlendEquation ||
              s !== this.currentBlendEquationAlpha) &&
              (h.blendEquationSeparate(o[t], o[s]),
              (this.currentBlendEquation = t),
              (this.currentBlendEquationAlpha = s)),
            (r !== this.currentBlendSrc ||
              i !== this.currentBlendDst ||
              n !== this.currentBlendSrcAlpha ||
              a !== this.currentBlendDstAlpha) &&
              (h.blendFuncSeparate(l[r], l[i], l[n], l[a]),
              (this.currentBlendSrc = r),
              (this.currentBlendDst = i),
              (this.currentBlendSrcAlpha = n),
              (this.currentBlendDstAlpha = a)),
            (this.currentBlending = e),
            (this.currentPremultipledAlpha = !1);
        }
        setColorMask(e) {
          this.currentColorMask !== e &&
            (this.gl.colorMask(e, e, e, e), (this.currentColorMask = e));
        }
        setDepthTest(e) {
          let { gl: t } = this;
          e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST);
        }
        setDepthMask(e) {
          this.currentDepthMask !== e &&
            (this.gl.depthMask(e), (this.currentDepthMask = e));
        }
        setDepthFunc(e) {
          if (this.currentDepthFunc !== e) {
            let { gl: t } = this;
            switch (e) {
              case u.eHc:
                t.depthFunc(t.NEVER);
                break;
              case u.lGu:
                t.depthFunc(t.ALWAYS);
                break;
              case u.brA:
                t.depthFunc(t.LESS);
                break;
              case u.xSv:
                t.depthFunc(t.LEQUAL);
                break;
              case u.U3G:
                t.depthFunc(t.EQUAL);
                break;
              case u.Gwm:
                t.depthFunc(t.GEQUAL);
                break;
              case u.K52:
                t.depthFunc(t.GREATER);
                break;
              case u.bw0:
                t.depthFunc(t.NOTEQUAL);
                break;
              default:
                t.depthFunc(t.LEQUAL);
            }
            this.currentDepthFunc = e;
          }
        }
        scissor(e, t, r, i) {
          let s = this._tempVec4.set(e, t, r, i);
          if (!1 === this.currentScissor.equals(s)) {
            let { gl: e } = this;
            e.scissor(s.x, s.y, s.z, s.w), this.currentScissor.copy(s);
          }
        }
        viewport(e, t, r, i) {
          let s = this._tempVec4.set(e, t, r, i);
          if (!1 === this.currentViewport.equals(s)) {
            let { gl: e } = this;
            e.viewport(s.x, s.y, s.z, s.w), this.currentViewport.copy(s);
          }
        }
        setScissorTest(e) {
          let t = this.gl;
          e ? t.enable(t.SCISSOR_TEST) : t.disable(t.SCISSOR_TEST);
        }
        setStencilTest(e) {
          let { gl: t } = this;
          e ? this.enable(t.STENCIL_TEST) : this.disable(t.STENCIL_TEST);
        }
        setStencilMask(e) {
          this.currentStencilMask !== e &&
            (this.gl.stencilMask(e), (this.currentStencilMask = e));
        }
        setStencilFunc(e, t, r) {
          (this.currentStencilFunc !== e ||
            this.currentStencilRef !== t ||
            this.currentStencilFuncMask !== r) &&
            (this.gl.stencilFunc(e, t, r),
            (this.currentStencilFunc = e),
            (this.currentStencilRef = t),
            (this.currentStencilFuncMask = r));
        }
        setStencilOp(e, t, r) {
          (this.currentStencilFail !== e ||
            this.currentStencilZFail !== t ||
            this.currentStencilZPass !== r) &&
            (this.gl.stencilOp(e, t, r),
            (this.currentStencilFail = e),
            (this.currentStencilZFail = t),
            (this.currentStencilZPass = r));
        }
        setMaterial(e, t, r) {
          let { gl: i } = this;
          e.side === u.$EB
            ? this.disable(i.CULL_FACE)
            : this.enable(i.CULL_FACE);
          let s = e.side === u.hsX;
          t && (s = !s),
            this.setFlipSided(s),
            e.blending === u.NTi && !1 === e.transparent
              ? this.setBlending(u.XIg)
              : this.setBlending(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            this.setDepthFunc(e.depthFunc),
            this.setDepthTest(e.depthTest),
            this.setDepthMask(e.depthWrite),
            this.setColorMask(e.colorWrite);
          let n = e.stencilWrite;
          if (
            (this.setStencilTest(n),
            n &&
              (this.setStencilMask(e.stencilWriteMask),
              this.setStencilFunc(
                e.stencilFunc,
                e.stencilRef,
                e.stencilFuncMask
              ),
              this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            this.setPolygonOffset(
              e.polygonOffset,
              e.polygonOffsetFactor,
              e.polygonOffsetUnits
            ),
            !0 === e.alphaToCoverage && this.backend.renderer.samples > 1
              ? this.enable(i.SAMPLE_ALPHA_TO_COVERAGE)
              : this.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
            r > 0 && this.currentClippingPlanes !== r)
          )
            for (let e = 0; e < 8; e++)
              e < r ? this.enable(12288 + e) : this.disable(12288 + e);
        }
        setPolygonOffset(e, t, r) {
          let { gl: i } = this;
          e
            ? (this.enable(i.POLYGON_OFFSET_FILL),
              (this.currentPolygonOffsetFactor !== t ||
                this.currentPolygonOffsetUnits !== r) &&
                (i.polygonOffset(t, r),
                (this.currentPolygonOffsetFactor = t),
                (this.currentPolygonOffsetUnits = r)))
            : this.disable(i.POLYGON_OFFSET_FILL);
        }
        useProgram(e) {
          return (
            this.currentProgram !== e &&
            (this.gl.useProgram(e), (this.currentProgram = e), !0)
          );
        }
        setVertexState(e, t = null) {
          let r = this.gl;
          return (
            (this.currentVAO !== e || this.currentIndex !== t) &&
            (r.bindVertexArray(e),
            null !== t && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t),
            (this.currentVAO = e),
            (this.currentIndex = t),
            !0)
          );
        }
        resetVertexState() {
          let e = this.gl;
          e.bindVertexArray(null),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null),
            (this.currentVAO = null),
            (this.currentIndex = null);
        }
        bindFramebuffer(e, t) {
          let { gl: r, currentBoundFramebuffers: i } = this;
          return (
            i[e] !== t &&
            (r.bindFramebuffer(e, t),
            (i[e] = t),
            e === r.DRAW_FRAMEBUFFER && (i[r.FRAMEBUFFER] = t),
            e === r.FRAMEBUFFER && (i[r.DRAW_FRAMEBUFFER] = t),
            !0)
          );
        }
        drawBuffers(e, t) {
          let { gl: r } = this,
            i = [],
            s = !1;
          if (null !== e.textures) {
            void 0 === (i = this.currentDrawbuffers.get(t)) &&
              ((i = []), this.currentDrawbuffers.set(t, i));
            let n = e.textures;
            if (i.length !== n.length || i[0] !== r.COLOR_ATTACHMENT0) {
              for (let e = 0, t = n.length; e < t; e++)
                i[e] = r.COLOR_ATTACHMENT0 + e;
              (i.length = n.length), (s = !0);
            }
          } else i[0] !== r.BACK && ((i[0] = r.BACK), (s = !0));
          s && r.drawBuffers(i);
        }
        activeTexture(e) {
          let { gl: t, currentTextureSlot: r, maxTextures: i } = this;
          void 0 === e && (e = t.TEXTURE0 + i - 1),
            r !== e && (t.activeTexture(e), (this.currentTextureSlot = e));
        }
        bindTexture(e, t, r) {
          let {
            gl: i,
            currentTextureSlot: s,
            currentBoundTextures: n,
            maxTextures: a,
          } = this;
          void 0 === r && (r = null === s ? i.TEXTURE0 + a - 1 : s);
          let o = n[r];
          void 0 === o && ((o = { type: void 0, texture: void 0 }), (n[r] = o)),
            (o.type !== e || o.texture !== t) &&
              (s !== r && (i.activeTexture(r), (this.currentTextureSlot = r)),
              i.bindTexture(e, t),
              (o.type = e),
              (o.texture = t));
        }
        bindBufferBase(e, t, r) {
          let { gl: i } = this,
            s = `${e}-${t}`;
          return (
            this.currentBoundBufferBases[s] !== r &&
            (i.bindBufferBase(e, t, r),
            (this.currentBoundBufferBases[s] = r),
            !0)
          );
        }
        unbindTexture() {
          let { gl: e, currentTextureSlot: t, currentBoundTextures: r } = this,
            i = r[t];
          void 0 !== i &&
            void 0 !== i.type &&
            (e.bindTexture(i.type, null),
            (i.type = void 0),
            (i.texture = void 0));
        }
      }
      class mG {
        constructor(e) {
          (this.backend = e),
            (this.gl = this.backend.gl),
            (this.extensions = e.extensions);
        }
        convert(e, t = u.jf0) {
          let r,
            { gl: i, extensions: s } = this;
          if (e === u.OUM) return i.UNSIGNED_BYTE;
          if (e === u.Wew) return i.UNSIGNED_SHORT_4_4_4_4;
          if (e === u.gJ2) return i.UNSIGNED_SHORT_5_5_5_1;
          if (e === u.Dmk) return i.UNSIGNED_INT_5_9_9_9_REV;
          if (e === u.tJf) return i.BYTE;
          if (e === u.fBL) return i.SHORT;
          if (e === u.cHt) return i.UNSIGNED_SHORT;
          if (e === u.Yuy) return i.INT;
          if (e === u.bkx) return i.UNSIGNED_INT;
          if (e === u.RQf) return i.FLOAT;
          if (e === u.ix0) return i.HALF_FLOAT;
          if (e === u.wrO) return i.ALPHA;
          if (e === u.HIg) return i.RGB;
          if (e === u.GWd) return i.RGBA;
          if (e === u.Kzv) return i.LUMINANCE;
          if (e === u.CMB) return i.LUMINANCE_ALPHA;
          if (e === u.zdS) return i.DEPTH_COMPONENT;
          if (e === u.dcC) return i.DEPTH_STENCIL;
          if (e === u.VT0) return i.RED;
          if (e === u.ZQM) return i.RED_INTEGER;
          if (e === u.paN) return i.RG;
          if (e === u.TkQ) return i.RG_INTEGER;
          if (e === u.c90) return i.RGBA_INTEGER;
          if (e === u.IE4 || e === u.Nz6 || e === u.jR7 || e === u.BXX)
            if (t === u.er$) {
              if (null === (r = s.get("WEBGL_compressed_texture_s3tc_srgb")))
                return null;
              if (e === u.IE4) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (e === u.Nz6) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (e === u.jR7) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (e === u.BXX) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (null === (r = s.get("WEBGL_compressed_texture_s3tc")))
                return null;
              if (e === u.IE4) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (e === u.Nz6) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (e === u.jR7) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (e === u.BXX) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
          if (e === u.k6Q || e === u.kTp || e === u.HXV || e === u.pBf) {
            if (null === (r = s.get("WEBGL_compressed_texture_pvrtc")))
              return null;
            if (e === u.k6Q) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (e === u.kTp) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (e === u.HXV) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (e === u.pBf) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (e === u.CVz || e === u.Riy || e === u.KDk) {
            if (null === (r = s.get("WEBGL_compressed_texture_etc")))
              return null;
            if (e === u.CVz || e === u.Riy)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ETC2
                : r.COMPRESSED_RGB8_ETC2;
            if (e === u.KDk)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                : r.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            e === u.qa3 ||
            e === u.B_h ||
            e === u.czI ||
            e === u.rSH ||
            e === u.Qrf ||
            e === u.psI ||
            e === u.a5J ||
            e === u._QJ ||
            e === u.uB5 ||
            e === u.lyL ||
            e === u.bC7 ||
            e === u.y3Z ||
            e === u.ojs ||
            e === u.S$4
          ) {
            if (null === (r = s.get("WEBGL_compressed_texture_astc")))
              return null;
            if (e === u.qa3)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (e === u.B_h)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (e === u.czI)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (e === u.rSH)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (e === u.Qrf)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (e === u.psI)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (e === u.a5J)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (e === u._QJ)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (e === u.uB5)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (e === u.lyL)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (e === u.bC7)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (e === u.y3Z)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (e === u.ojs)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (e === u.S$4)
              return t === u.er$
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }
          if (e === u.Fn) {
            if (null === (r = s.get("EXT_texture_compression_bptc")))
              return null;
            if (e === u.Fn)
              return t === u.er$
                ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }
          if (e === u.Kef || e === u.XG_ || e === u.HO_ || e === u.CWW) {
            if (null === (r = s.get("EXT_texture_compression_rgtc")))
              return null;
            if (e === u.Fn) return r.COMPRESSED_RED_RGTC1_EXT;
            if (e === u.XG_) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (e === u.HO_) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (e === u.CWW) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          }
          return e === u.V3x
            ? i.UNSIGNED_INT_24_8
            : void 0 !== i[e]
            ? i[e]
            : null;
        }
        _clientWaitAsync() {
          let { gl: e } = this,
            t = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return (
            e.flush(),
            new Promise((r, i) => {
              !(function s() {
                let n = e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0);
                if (n === e.WAIT_FAILED) {
                  e.deleteSync(t), i();
                  return;
                }
                if (n === e.TIMEOUT_EXPIRED)
                  return void requestAnimationFrame(s);
                e.deleteSync(t), r();
              })();
            })
          );
        }
      }
      let mk = !1,
        mz,
        m$,
        mW;
      class mH {
        constructor(e) {
          (this.backend = e),
            (this.gl = e.gl),
            (this.extensions = e.extensions),
            (this.defaultTextures = {}),
            !1 === mk && (this._init(), (mk = !0));
        }
        _init() {
          let e = this.gl;
          (mz = {
            [u.GJx]: e.REPEAT,
            [u.ghU]: e.CLAMP_TO_EDGE,
            [u.kTW]: e.MIRRORED_REPEAT,
          }),
            (m$ = {
              [u.hxR]: e.NEAREST,
              [u.pHI]: e.NEAREST_MIPMAP_NEAREST,
              [u.Cfg]: e.NEAREST_MIPMAP_LINEAR,
              [u.k6q]: e.LINEAR,
              [u.kRr]: e.LINEAR_MIPMAP_NEAREST,
              [u.$_I]: e.LINEAR_MIPMAP_LINEAR,
            }),
            (mW = {
              [u.amv]: e.NEVER,
              [u.FFZ]: e.ALWAYS,
              [u.vim]: e.LESS,
              [u.TiK]: e.LEQUAL,
              [u.kO0]: e.EQUAL,
              [u.gWB]: e.GEQUAL,
              [u.eoi]: e.GREATER,
              [u.jzd]: e.NOTEQUAL,
            });
        }
        getGLTextureType(e) {
          let t,
            { gl: r } = this;
          return !0 === e.isCubeTexture
            ? r.TEXTURE_CUBE_MAP
            : !0 === e.isDataArrayTexture || !0 === e.isCompressedArrayTexture
            ? r.TEXTURE_2D_ARRAY
            : !0 === e.isData3DTexture
            ? r.TEXTURE_3D
            : r.TEXTURE_2D;
        }
        getInternalFormat(e, t, r, i, s = !1) {
          let { gl: n, extensions: a } = this;
          if (null !== e) {
            if (void 0 !== n[e]) return n[e];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                e +
                "'"
            );
          }
          let o = t;
          return (
            t === n.RED &&
              (r === n.FLOAT && (o = n.R32F),
              r === n.HALF_FLOAT && (o = n.R16F),
              r === n.UNSIGNED_BYTE && (o = n.R8),
              r === n.UNSIGNED_SHORT && (o = n.R16),
              r === n.UNSIGNED_INT && (o = n.R32UI),
              r === n.BYTE && (o = n.R8I),
              r === n.SHORT && (o = n.R16I),
              r === n.INT && (o = n.R32I)),
            t === n.RED_INTEGER &&
              (r === n.UNSIGNED_BYTE && (o = n.R8UI),
              r === n.UNSIGNED_SHORT && (o = n.R16UI),
              r === n.UNSIGNED_INT && (o = n.R32UI),
              r === n.BYTE && (o = n.R8I),
              r === n.SHORT && (o = n.R16I),
              r === n.INT && (o = n.R32I)),
            t === n.RG &&
              (r === n.FLOAT && (o = n.RG32F),
              r === n.HALF_FLOAT && (o = n.RG16F),
              r === n.UNSIGNED_BYTE && (o = n.RG8),
              r === n.UNSIGNED_SHORT && (o = n.RG16),
              r === n.UNSIGNED_INT && (o = n.RG32UI),
              r === n.BYTE && (o = n.RG8I),
              r === n.SHORT && (o = n.RG16I),
              r === n.INT && (o = n.RG32I)),
            t === n.RG_INTEGER &&
              (r === n.UNSIGNED_BYTE && (o = n.RG8UI),
              r === n.UNSIGNED_SHORT && (o = n.RG16UI),
              r === n.UNSIGNED_INT && (o = n.RG32UI),
              r === n.BYTE && (o = n.RG8I),
              r === n.SHORT && (o = n.RG16I),
              r === n.INT && (o = n.RG32I)),
            t === n.RGB &&
              (r === n.FLOAT && (o = n.RGB32F),
              r === n.HALF_FLOAT && (o = n.RGB16F),
              r === n.UNSIGNED_BYTE && (o = n.RGB8),
              r === n.UNSIGNED_SHORT && (o = n.RGB16),
              r === n.UNSIGNED_INT && (o = n.RGB32UI),
              r === n.BYTE && (o = n.RGB8I),
              r === n.SHORT && (o = n.RGB16I),
              r === n.INT && (o = n.RGB32I),
              r === n.UNSIGNED_BYTE &&
                (o = i === u.er$ && !1 === s ? n.SRGB8 : n.RGB8),
              r === n.UNSIGNED_SHORT_5_6_5 && (o = n.RGB565),
              r === n.UNSIGNED_SHORT_5_5_5_1 && (o = n.RGB5_A1),
              r === n.UNSIGNED_SHORT_4_4_4_4 && (o = n.RGB4),
              r === n.UNSIGNED_INT_5_9_9_9_REV && (o = n.RGB9_E5)),
            t === n.RGB_INTEGER &&
              (r === n.UNSIGNED_BYTE && (o = n.RGB8UI),
              r === n.UNSIGNED_SHORT && (o = n.RGB16UI),
              r === n.UNSIGNED_INT && (o = n.RGB32UI),
              r === n.BYTE && (o = n.RGB8I),
              r === n.SHORT && (o = n.RGB16I),
              r === n.INT && (o = n.RGB32I)),
            t === n.RGBA &&
              (r === n.FLOAT && (o = n.RGBA32F),
              r === n.HALF_FLOAT && (o = n.RGBA16F),
              r === n.UNSIGNED_BYTE && (o = n.RGBA8),
              r === n.UNSIGNED_SHORT && (o = n.RGBA16),
              r === n.UNSIGNED_INT && (o = n.RGBA32UI),
              r === n.BYTE && (o = n.RGBA8I),
              r === n.SHORT && (o = n.RGBA16I),
              r === n.INT && (o = n.RGBA32I),
              r === n.UNSIGNED_BYTE &&
                (o = i === u.er$ && !1 === s ? n.SRGB8_ALPHA8 : n.RGBA8),
              r === n.UNSIGNED_SHORT_4_4_4_4 && (o = n.RGBA4),
              r === n.UNSIGNED_SHORT_5_5_5_1 && (o = n.RGB5_A1)),
            t === n.RGBA_INTEGER &&
              (r === n.UNSIGNED_BYTE && (o = n.RGBA8UI),
              r === n.UNSIGNED_SHORT && (o = n.RGBA16UI),
              r === n.UNSIGNED_INT && (o = n.RGBA32UI),
              r === n.BYTE && (o = n.RGBA8I),
              r === n.SHORT && (o = n.RGBA16I),
              r === n.INT && (o = n.RGBA32I)),
            t === n.DEPTH_COMPONENT &&
              (r === n.UNSIGNED_SHORT && (o = n.DEPTH_COMPONENT16),
              r === n.UNSIGNED_INT && (o = n.DEPTH_COMPONENT24),
              r === n.FLOAT && (o = n.DEPTH_COMPONENT32F)),
            t === n.DEPTH_STENCIL &&
              r === n.UNSIGNED_INT_24_8 &&
              (o = n.DEPTH24_STENCIL8),
            (o === n.R16F ||
              o === n.R32F ||
              o === n.RG16F ||
              o === n.RG32F ||
              o === n.RGBA16F ||
              o === n.RGBA32F) &&
              a.get("EXT_color_buffer_float"),
            o
          );
        }
        setTextureParameters(e, t) {
          let { gl: r, extensions: i, backend: s } = this;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, t.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, t.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE),
            r.texParameteri(e, r.TEXTURE_WRAP_S, mz[t.wrapS]),
            r.texParameteri(e, r.TEXTURE_WRAP_T, mz[t.wrapT]),
            (e === r.TEXTURE_3D || e === r.TEXTURE_2D_ARRAY) &&
              r.texParameteri(e, r.TEXTURE_WRAP_R, mz[t.wrapR]),
            r.texParameteri(e, r.TEXTURE_MAG_FILTER, m$[t.magFilter]);
          let n = void 0 !== t.mipmaps && t.mipmaps.length > 0,
            a = t.minFilter === u.k6q && n ? u.$_I : t.minFilter;
          if (
            (r.texParameteri(e, r.TEXTURE_MIN_FILTER, m$[a]),
            t.compareFunction &&
              (r.texParameteri(
                e,
                r.TEXTURE_COMPARE_MODE,
                r.COMPARE_REF_TO_TEXTURE
              ),
              r.texParameteri(
                e,
                r.TEXTURE_COMPARE_FUNC,
                mW[t.compareFunction]
              )),
            !0 === i.has("EXT_texture_filter_anisotropic"))
          ) {
            if (
              t.magFilter === u.hxR ||
              (t.minFilter !== u.Cfg && t.minFilter !== u.$_I) ||
              (t.type === u.RQf && !1 === i.has("OES_texture_float_linear"))
            )
              return;
            if (t.anisotropy > 1) {
              let n = i.get("EXT_texture_filter_anisotropic");
              r.texParameterf(
                e,
                n.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(t.anisotropy, s.getMaxAnisotropy())
              );
            }
          }
        }
        createDefaultTexture(e) {
          let { gl: t, backend: r, defaultTextures: i } = this,
            s = this.getGLTextureType(e),
            n = i[s];
          void 0 === n &&
            ((n = t.createTexture()),
            r.state.bindTexture(s, n),
            t.texParameteri(s, t.TEXTURE_MIN_FILTER, t.NEAREST),
            t.texParameteri(s, t.TEXTURE_MAG_FILTER, t.NEAREST),
            (i[s] = n)),
            r.set(e, { textureGPU: n, glTextureType: s, isDefault: !0 });
        }
        createTexture(e, t) {
          let { gl: r, backend: i } = this,
            { levels: s, width: n, height: a, depth: o } = t,
            l = i.utils.convert(e.format, e.colorSpace),
            u = i.utils.convert(e.type),
            d = this.getInternalFormat(
              e.internalFormat,
              l,
              u,
              e.colorSpace,
              e.isVideoTexture
            ),
            h = r.createTexture(),
            c = this.getGLTextureType(e);
          i.state.bindTexture(c, h),
            this.setTextureParameters(c, e),
            e.isDataArrayTexture || e.isCompressedArrayTexture
              ? r.texStorage3D(r.TEXTURE_2D_ARRAY, s, d, n, a, o)
              : e.isData3DTexture
              ? r.texStorage3D(r.TEXTURE_3D, s, d, n, a, o)
              : e.isVideoTexture || r.texStorage2D(c, s, d, n, a),
            i.set(e, {
              textureGPU: h,
              glTextureType: c,
              glFormat: l,
              glType: u,
              glInternalFormat: d,
            });
        }
        copyBufferToTexture(e, t) {
          let { gl: r, backend: i } = this,
            {
              textureGPU: s,
              glTextureType: n,
              glFormat: a,
              glType: o,
            } = i.get(t),
            { width: l, height: u } = t.source.data;
          r.bindBuffer(r.PIXEL_UNPACK_BUFFER, e),
            i.state.bindTexture(n, s),
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            r.texSubImage2D(n, 0, 0, 0, l, u, a, o, 0),
            r.bindBuffer(r.PIXEL_UNPACK_BUFFER, null),
            i.state.unbindTexture();
        }
        updateTexture(e, t) {
          let { gl: r } = this,
            { width: i, height: s } = t,
            {
              textureGPU: n,
              glTextureType: a,
              glFormat: o,
              glType: l,
              glInternalFormat: u,
            } = this.backend.get(e);
          if (e.isRenderTargetTexture || void 0 === n) return;
          let d = (e) =>
            e.isDataTexture
              ? e.image.data
              : ("undefined" != typeof HTMLImageElement &&
                  e instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement &&
                  e instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap &&
                  e instanceof ImageBitmap) ||
                e instanceof OffscreenCanvas
              ? e
              : e.data;
          if (
            (this.backend.state.bindTexture(a, n),
            this.setTextureParameters(a, e),
            e.isCompressedTexture)
          ) {
            let i = e.mipmaps,
              s = t.image;
            for (let t = 0; t < i.length; t++) {
              let n = i[t];
              e.isCompressedArrayTexture
                ? e.format !== r.RGBA
                  ? null !== o
                    ? r.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        t,
                        0,
                        0,
                        0,
                        n.width,
                        n.height,
                        s.depth,
                        o,
                        n.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : r.texSubImage3D(
                      r.TEXTURE_2D_ARRAY,
                      t,
                      0,
                      0,
                      0,
                      n.width,
                      n.height,
                      s.depth,
                      o,
                      l,
                      n.data
                    )
                : null !== o
                ? r.compressedTexSubImage2D(
                    r.TEXTURE_2D,
                    t,
                    0,
                    0,
                    n.width,
                    n.height,
                    o,
                    n.data
                  )
                : console.warn("Unsupported compressed texture format");
            }
          } else if (e.isCubeTexture) {
            let e = t.images;
            for (let t = 0; t < 6; t++) {
              let n = d(e[t]);
              r.texSubImage2D(
                r.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                0,
                0,
                0,
                i,
                s,
                o,
                l,
                n
              );
            }
          } else if (e.isDataArrayTexture) {
            let e = t.image;
            r.texSubImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              e.width,
              e.height,
              e.depth,
              o,
              l,
              e.data
            );
          } else if (e.isData3DTexture) {
            let e = t.image;
            r.texSubImage3D(
              r.TEXTURE_3D,
              0,
              0,
              0,
              0,
              e.width,
              e.height,
              e.depth,
              o,
              l,
              e.data
            );
          } else if (e.isVideoTexture)
            e.update(), r.texImage2D(a, 0, u, o, l, t.image);
          else {
            let e = d(t.image);
            r.texSubImage2D(a, 0, 0, 0, i, s, o, l, e);
          }
        }
        generateMipmaps(e) {
          let { gl: t, backend: r } = this,
            { textureGPU: i, glTextureType: s } = r.get(e);
          r.state.bindTexture(s, i), t.generateMipmap(s);
        }
        deallocateRenderBuffers(e) {
          let { gl: t, backend: r } = this;
          if (e) {
            let i = r.get(e);
            if (((i.renderBufferStorageSetup = void 0), i.framebuffers)) {
              for (let e in i.framebuffers)
                t.deleteFramebuffer(i.framebuffers[e]);
              delete i.framebuffers;
            }
            if (
              (i.depthRenderbuffer &&
                (t.deleteRenderbuffer(i.depthRenderbuffer),
                delete i.depthRenderbuffer),
              i.stencilRenderbuffer &&
                (t.deleteRenderbuffer(i.stencilRenderbuffer),
                delete i.stencilRenderbuffer),
              i.msaaFrameBuffer &&
                (t.deleteFramebuffer(i.msaaFrameBuffer),
                delete i.msaaFrameBuffer),
              i.msaaRenderbuffers)
            ) {
              for (let e = 0; e < i.msaaRenderbuffers.length; e++)
                t.deleteRenderbuffer(i.msaaRenderbuffers[e]);
              delete i.msaaRenderbuffers;
            }
          }
        }
        destroyTexture(e) {
          let { gl: t, backend: r } = this,
            { textureGPU: i, renderTarget: s } = r.get(e);
          this.deallocateRenderBuffers(s), t.deleteTexture(i), r.delete(e);
        }
        copyTextureToTexture(e, t, r = null, i = null, s = 0) {
          let n,
            a,
            o,
            l,
            u,
            d,
            { gl: h, backend: c } = this,
            { state: p } = this.backend,
            {
              textureGPU: g,
              glTextureType: m,
              glType: f,
              glFormat: y,
            } = c.get(t);
          null !== r
            ? ((n = r.max.x - r.min.x),
              (a = r.max.y - r.min.y),
              (o = r.min.x),
              (l = r.min.y))
            : ((n = e.image.width), (a = e.image.height), (o = 0), (l = 0)),
            null !== i ? ((u = i.x), (d = i.y)) : ((u = 0), (d = 0)),
            p.bindTexture(m, g),
            h.pixelStorei(h.UNPACK_ALIGNMENT, t.unpackAlignment),
            h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, t.flipY),
            h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
            h.pixelStorei(h.UNPACK_ALIGNMENT, t.unpackAlignment);
          let x = h.getParameter(h.UNPACK_ROW_LENGTH),
            b = h.getParameter(h.UNPACK_IMAGE_HEIGHT),
            T = h.getParameter(h.UNPACK_SKIP_PIXELS),
            _ = h.getParameter(h.UNPACK_SKIP_ROWS),
            v = h.getParameter(h.UNPACK_SKIP_IMAGES),
            N = e.isCompressedTexture ? e.mipmaps[s] : e.image;
          if (
            (h.pixelStorei(h.UNPACK_ROW_LENGTH, N.width),
            h.pixelStorei(h.UNPACK_IMAGE_HEIGHT, N.height),
            h.pixelStorei(h.UNPACK_SKIP_PIXELS, o),
            h.pixelStorei(h.UNPACK_SKIP_ROWS, l),
            e.isRenderTargetTexture || e.isDepthTexture)
          ) {
            let r = c.get(e),
              i = c.get(t),
              s = c.get(r.renderTarget),
              g = c.get(i.renderTarget),
              m = s.framebuffers[r.cacheKey],
              f = g.framebuffers[i.cacheKey];
            p.bindFramebuffer(h.READ_FRAMEBUFFER, m),
              p.bindFramebuffer(h.DRAW_FRAMEBUFFER, f);
            let y = h.COLOR_BUFFER_BIT;
            e.isDepthTexture && (y = h.DEPTH_BUFFER_BIT),
              h.blitFramebuffer(o, l, n, a, u, d, n, a, y, h.NEAREST),
              p.bindFramebuffer(h.READ_FRAMEBUFFER, null),
              p.bindFramebuffer(h.DRAW_FRAMEBUFFER, null);
          } else
            e.isDataTexture
              ? h.texSubImage2D(h.TEXTURE_2D, s, u, d, n, a, y, f, N.data)
              : e.isCompressedTexture
              ? h.compressedTexSubImage2D(
                  h.TEXTURE_2D,
                  s,
                  u,
                  d,
                  N.width,
                  N.height,
                  y,
                  N.data
                )
              : h.texSubImage2D(h.TEXTURE_2D, s, u, d, n, a, y, f, N);
          h.pixelStorei(h.UNPACK_ROW_LENGTH, x),
            h.pixelStorei(h.UNPACK_IMAGE_HEIGHT, b),
            h.pixelStorei(h.UNPACK_SKIP_PIXELS, T),
            h.pixelStorei(h.UNPACK_SKIP_ROWS, _),
            h.pixelStorei(h.UNPACK_SKIP_IMAGES, v),
            0 === s && t.generateMipmaps && h.generateMipmap(h.TEXTURE_2D),
            p.unbindTexture();
        }
        copyFramebufferToTexture(e, t, r) {
          let { gl: i } = this,
            { state: s } = this.backend,
            { textureGPU: n } = this.backend.get(e),
            { x: a, y: o, z: l, w: u } = r,
            d =
              !0 === e.isDepthTexture ||
              (t.renderTarget && t.renderTarget.samples > 0),
            h = t.renderTarget
              ? t.renderTarget.height
              : this.backend.getDrawingBufferSize().y;
          if (d) {
            let r,
              d,
              c = 0 !== a || 0 !== o;
            if (
              (!0 === e.isDepthTexture
                ? ((r = i.DEPTH_BUFFER_BIT),
                  (d = i.DEPTH_ATTACHMENT),
                  t.stencil && (r |= i.STENCIL_BUFFER_BIT))
                : ((r = i.COLOR_BUFFER_BIT), (d = i.COLOR_ATTACHMENT0)),
              c)
            ) {
              let e = this.backend.get(t.renderTarget),
                d = e.framebuffers[t.getCacheKey()],
                c = e.msaaFrameBuffer;
              s.bindFramebuffer(i.DRAW_FRAMEBUFFER, d),
                s.bindFramebuffer(i.READ_FRAMEBUFFER, c);
              let p = h - o - u;
              i.blitFramebuffer(
                a,
                p,
                a + l,
                p + u,
                a,
                p,
                a + l,
                p + u,
                r,
                i.NEAREST
              ),
                s.bindFramebuffer(i.READ_FRAMEBUFFER, d),
                s.bindTexture(i.TEXTURE_2D, n),
                i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, a, p, l, u),
                s.unbindTexture();
            } else {
              let e = i.createFramebuffer();
              s.bindFramebuffer(i.DRAW_FRAMEBUFFER, e),
                i.framebufferTexture2D(
                  i.DRAW_FRAMEBUFFER,
                  d,
                  i.TEXTURE_2D,
                  n,
                  0
                ),
                i.blitFramebuffer(0, 0, l, u, 0, 0, l, u, r, i.NEAREST),
                i.deleteFramebuffer(e);
            }
          } else
            s.bindTexture(i.TEXTURE_2D, n),
              i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, a, h - u - o, l, u),
              s.unbindTexture();
          e.generateMipmaps && this.generateMipmaps(e),
            this.backend._setFramebuffer(t);
        }
        setupRenderBufferStorage(e, t, r, i = !1) {
          let { gl: s } = this,
            n = t.renderTarget,
            {
              depthTexture: a,
              depthBuffer: o,
              stencilBuffer: l,
              width: u,
              height: d,
            } = n;
          if ((s.bindRenderbuffer(s.RENDERBUFFER, e), o && !l)) {
            let t = s.DEPTH_COMPONENT24;
            !0 === i
              ? this.extensions
                  .get("WEBGL_multisampled_render_to_texture")
                  .renderbufferStorageMultisampleEXT(
                    s.RENDERBUFFER,
                    n.samples,
                    t,
                    u,
                    d
                  )
              : r > 0
              ? (a &&
                  a.isDepthTexture &&
                  a.type === s.FLOAT &&
                  (t = s.DEPTH_COMPONENT32F),
                s.renderbufferStorageMultisample(s.RENDERBUFFER, r, t, u, d))
              : s.renderbufferStorage(s.RENDERBUFFER, t, u, d),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.DEPTH_ATTACHMENT,
                s.RENDERBUFFER,
                e
              );
          } else
            o &&
              l &&
              (r > 0
                ? s.renderbufferStorageMultisample(
                    s.RENDERBUFFER,
                    r,
                    s.DEPTH24_STENCIL8,
                    u,
                    d
                  )
                : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, u, d),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.DEPTH_STENCIL_ATTACHMENT,
                s.RENDERBUFFER,
                e
              ));
        }
        async copyTextureToBuffer(e, t, r, i, s, n) {
          let { backend: a, gl: o } = this,
            { textureGPU: l, glFormat: u, glType: d } = this.backend.get(e),
            h = o.createFramebuffer();
          o.bindFramebuffer(o.READ_FRAMEBUFFER, h);
          let c = e.isCubeTexture
            ? o.TEXTURE_CUBE_MAP_POSITIVE_X + n
            : o.TEXTURE_2D;
          o.framebufferTexture2D(
            o.READ_FRAMEBUFFER,
            o.COLOR_ATTACHMENT0,
            c,
            l,
            0
          );
          let p = this._getTypedArrayType(d),
            g = i * s * this._getBytesPerTexel(d, u),
            m = o.createBuffer();
          o.bindBuffer(o.PIXEL_PACK_BUFFER, m),
            o.bufferData(o.PIXEL_PACK_BUFFER, g, o.STREAM_READ),
            o.readPixels(t, r, i, s, u, d, 0),
            o.bindBuffer(o.PIXEL_PACK_BUFFER, null),
            await a.utils._clientWaitAsync();
          let f = new p(g / p.BYTES_PER_ELEMENT);
          return (
            o.bindBuffer(o.PIXEL_PACK_BUFFER, m),
            o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, f),
            o.bindBuffer(o.PIXEL_PACK_BUFFER, null),
            o.deleteFramebuffer(h),
            f
          );
        }
        _getTypedArrayType(e) {
          let { gl: t } = this;
          if (e === t.UNSIGNED_BYTE) return Uint8Array;
          if (
            e === t.UNSIGNED_SHORT_4_4_4_4 ||
            e === t.UNSIGNED_SHORT_5_5_5_1 ||
            e === t.UNSIGNED_SHORT_5_6_5 ||
            e === t.UNSIGNED_SHORT
          )
            return Uint16Array;
          if (e === t.UNSIGNED_INT) return Uint32Array;
          if (e === t.HALF_FLOAT) return Uint16Array;
          if (e === t.FLOAT) return Float32Array;
          throw Error(`Unsupported WebGL type: ${e}`);
        }
        _getBytesPerTexel(e, t) {
          let { gl: r } = this,
            i = 0;
          return (e === r.UNSIGNED_BYTE && (i = 1),
          (e === r.UNSIGNED_SHORT_4_4_4_4 ||
            e === r.UNSIGNED_SHORT_5_5_5_1 ||
            e === r.UNSIGNED_SHORT_5_6_5 ||
            e === r.UNSIGNED_SHORT ||
            e === r.HALF_FLOAT) &&
            (i = 2),
          (e === r.UNSIGNED_INT || e === r.FLOAT) && (i = 4),
          t === r.RGBA)
            ? 4 * i
            : t === r.RGB
            ? 3 * i
            : t === r.ALPHA
            ? i
            : void 0;
        }
      }
      class mq {
        constructor(e) {
          (this.backend = e),
            (this.gl = this.backend.gl),
            (this.availableExtensions = this.gl.getSupportedExtensions()),
            (this.extensions = {});
        }
        get(e) {
          let t = this.extensions[e];
          return (
            void 0 === t &&
              ((t = this.gl.getExtension(e)), (this.extensions[e] = t)),
            t
          );
        }
        has(e) {
          return this.availableExtensions.includes(e);
        }
      }
      class mj {
        constructor(e) {
          (this.backend = e), (this.maxAnisotropy = null);
        }
        getMaxAnisotropy() {
          if (null !== this.maxAnisotropy) return this.maxAnisotropy;
          let e = this.backend.gl,
            t = this.backend.extensions;
          if (!0 === t.has("EXT_texture_filter_anisotropic")) {
            let r = t.get("EXT_texture_filter_anisotropic");
            this.maxAnisotropy = e.getParameter(
              r.MAX_TEXTURE_MAX_ANISOTROPY_EXT
            );
          } else this.maxAnisotropy = 0;
          return this.maxAnisotropy;
        }
      }
      let mX = {
        WEBGL_multi_draw: "WEBGL_multi_draw",
        WEBGL_compressed_texture_astc: "texture-compression-astc",
        WEBGL_compressed_texture_etc: "texture-compression-etc2",
        WEBGL_compressed_texture_etc1: "texture-compression-etc1",
        WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
        WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
        WEBGL_compressed_texture_s3tc: "texture-compression-bc",
        EXT_texture_compression_bptc: "texture-compression-bptc",
        EXT_disjoint_timer_query_webgl2: "timestamp-query",
      };
      class mQ {
        constructor(e) {
          (this.gl = e.gl),
            (this.extensions = e.extensions),
            (this.info = e.renderer.info),
            (this.mode = null),
            (this.index = 0),
            (this.type = null),
            (this.object = null);
        }
        render(e, t) {
          let { gl: r, mode: i, object: s, type: n, info: a, index: o } = this;
          0 !== o ? r.drawElements(i, t, n, e) : r.drawArrays(i, e, t),
            a.update(s, t, 1);
        }
        renderInstances(e, t, r) {
          let { gl: i, mode: s, type: n, index: a, object: o, info: l } = this;
          0 !== r &&
            (0 !== a
              ? i.drawElementsInstanced(s, t, n, e, r)
              : i.drawArraysInstanced(s, e, t, r),
            l.update(o, t, r));
        }
        renderMultiDraw(e, t, r) {
          let { extensions: i, mode: s, object: n, info: a } = this;
          if (0 === r) return;
          let o = i.get("WEBGL_multi_draw");
          if (null === o) for (let i = 0; i < r; i++) this.render(e[i], t[i]);
          else {
            0 !== this.index
              ? o.multiDrawElementsWEBGL(s, t, 0, this.type, e, 0, r)
              : o.multiDrawArraysWEBGL(s, e, 0, t, 0, r);
            let i = 0;
            for (let e = 0; e < r; e++) i += t[e];
            a.update(n, i, 1);
          }
        }
        renderMultiDrawInstances(e, t, r, i) {
          let { extensions: s, mode: n, object: a, info: o } = this;
          if (0 === r) return;
          let l = s.get("WEBGL_multi_draw");
          if (null === l)
            for (let s = 0; s < r; s++) this.renderInstances(e[s], t[s], i[s]);
          else {
            0 !== this.index
              ? l.multiDrawElementsInstancedWEBGL(
                  n,
                  t,
                  0,
                  this.type,
                  e,
                  0,
                  i,
                  0,
                  r
                )
              : l.multiDrawArraysInstancedWEBGL(n, e, 0, t, 0, i, 0, r);
            let s = 0;
            for (let e = 0; e < r; e++) s += t[e] * i[e];
            o.update(a, s, 1);
          }
        }
      }
      class mK {
        constructor(e = 256) {
          (this.trackTimestamp = !0),
            (this.maxQueries = e),
            (this.currentQueryIndex = 0),
            (this.queryOffsets = new Map()),
            (this.isDisposed = !1),
            (this.lastValue = 0),
            (this.pendingResolve = !1);
        }
        allocateQueriesForContext() {}
        async resolveQueriesAsync() {}
        dispose() {}
      }
      class mY extends mK {
        constructor(e, t, r = 2048) {
          if (
            (super(r),
            (this.gl = e),
            (this.type = t),
            (this.ext =
              e.getExtension("EXT_disjoint_timer_query_webgl2") ||
              e.getExtension("EXT_disjoint_timer_query")),
            !this.ext)
          ) {
            console.warn(
              "EXT_disjoint_timer_query not supported; timestamps will be disabled."
            ),
              (this.trackTimestamp = !1);
            return;
          }
          this.queries = [];
          for (let t = 0; t < this.maxQueries; t++)
            this.queries.push(e.createQuery());
          (this.activeQuery = null), (this.queryStates = new Map());
        }
        allocateQueriesForContext(e) {
          if (!this.trackTimestamp) return null;
          if (this.currentQueryIndex + 2 > this.maxQueries)
            return (
              (0, u.mcG)(
                `WebGPUTimestampQueryPool [${
                  this.type
                }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`
              ),
              null
            );
          let t = this.currentQueryIndex;
          return (
            (this.currentQueryIndex += 2),
            this.queryStates.set(t, "inactive"),
            this.queryOffsets.set(e.id, t),
            t
          );
        }
        beginQuery(e) {
          if (!this.trackTimestamp || this.isDisposed) return;
          let t = this.queryOffsets.get(e.id);
          if (null == t || null !== this.activeQuery) return;
          let r = this.queries[t];
          if (r)
            try {
              "inactive" === this.queryStates.get(t) &&
                (this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, r),
                (this.activeQuery = t),
                this.queryStates.set(t, "started"));
            } catch (e) {
              console.error("Error in beginQuery:", e),
                (this.activeQuery = null),
                this.queryStates.set(t, "inactive");
            }
        }
        endQuery(e) {
          if (!this.trackTimestamp || this.isDisposed) return;
          let t = this.queryOffsets.get(e.id);
          if (null != t && this.activeQuery === t)
            try {
              this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),
                this.queryStates.set(t, "ended"),
                (this.activeQuery = null);
            } catch (e) {
              console.error("Error in endQuery:", e),
                this.queryStates.set(t, "inactive"),
                (this.activeQuery = null);
            }
        }
        async resolveQueriesAsync() {
          if (!this.trackTimestamp || this.pendingResolve)
            return this.lastValue;
          this.pendingResolve = !0;
          try {
            let e = [];
            for (let [t, r] of this.queryStates)
              if ("ended" === r) {
                let r = this.queries[t];
                e.push(this.resolveQuery(r));
              }
            if (0 === e.length) return this.lastValue;
            let t = (await Promise.all(e)).reduce((e, t) => e + t, 0);
            return (
              (this.lastValue = t),
              (this.currentQueryIndex = 0),
              this.queryOffsets.clear(),
              this.queryStates.clear(),
              (this.activeQuery = null),
              t
            );
          } catch (e) {
            return console.error("Error resolving queries:", e), this.lastValue;
          } finally {
            this.pendingResolve = !1;
          }
        }
        async resolveQuery(e) {
          return new Promise((t) => {
            let r;
            if (this.isDisposed) return void t(this.lastValue);
            let i = !1,
              s = () => {
                r && (clearTimeout(r), (r = null));
              },
              n = (e) => {
                i || ((i = !0), s(), t(e));
              },
              a = () => {
                if (this.isDisposed) return void n(this.lastValue);
                try {
                  if (this.gl.getParameter(this.ext.GPU_DISJOINT_EXT))
                    return void n(this.lastValue);
                  if (
                    !this.gl.getQueryParameter(
                      e,
                      this.gl.QUERY_RESULT_AVAILABLE
                    )
                  ) {
                    r = setTimeout(a, 1);
                    return;
                  }
                  let i = this.gl.getQueryParameter(e, this.gl.QUERY_RESULT);
                  t(Number(i) / 1e6);
                } catch (e) {
                  console.error("Error checking query:", e), t(this.lastValue);
                }
              };
            a();
          });
        }
        dispose() {
          if (
            !this.isDisposed &&
            ((this.isDisposed = !0), this.trackTimestamp)
          ) {
            for (let e of this.queries) this.gl.deleteQuery(e);
            (this.queries = []),
              this.queryStates.clear(),
              this.queryOffsets.clear(),
              (this.lastValue = 0),
              (this.activeQuery = null);
          }
        }
      }
      class mZ extends mP {
        constructor(e = {}) {
          super(e),
            (this.isWebGLBackend = !0),
            (this.attributeUtils = null),
            (this.extensions = null),
            (this.capabilities = null),
            (this.textureUtils = null),
            (this.bufferRenderer = null),
            (this.gl = null),
            (this.state = null),
            (this.utils = null),
            (this.vaoCache = {}),
            (this.transformFeedbackCache = {}),
            (this.discard = !1),
            (this.disjoint = null),
            (this.parallel = null),
            (this.trackTimestamp = !0 === e.trackTimestamp),
            (this._currentContext = null),
            (this._knownBindings = new WeakSet()),
            (this._supportsInvalidateFramebuffer =
              "undefined" != typeof navigator &&
              /OculusBrowser/g.test(navigator.userAgent)),
            (this._xrFramebuffer = null);
        }
        init(e) {
          super.init(e);
          let t = this.parameters,
            r = {
              antialias: e.samples > 0,
              alpha: !0,
              depth: e.depth,
              stencil: e.stencil,
            },
            i =
              void 0 !== t.context
                ? t.context
                : e.domElement.getContext("webgl2", r);
          function s(t) {
            t.preventDefault();
            let r = {
              api: "WebGL",
              message: t.statusMessage || "Unknown reason",
              reason: null,
              originalEvent: t,
            };
            e.onDeviceLost(r);
          }
          (this._onContextLost = s),
            e.domElement.addEventListener("webglcontextlost", s, !1),
            (this.gl = i),
            (this.extensions = new mq(this)),
            (this.capabilities = new mj(this)),
            (this.attributeUtils = new mV(this)),
            (this.textureUtils = new mH(this)),
            (this.bufferRenderer = new mQ(this)),
            (this.state = new mO(this)),
            (this.utils = new mG(this)),
            this.extensions.get("EXT_color_buffer_float"),
            this.extensions.get("WEBGL_clip_cull_distance"),
            this.extensions.get("OES_texture_float_linear"),
            this.extensions.get("EXT_color_buffer_half_float"),
            this.extensions.get("WEBGL_multisampled_render_to_texture"),
            this.extensions.get("WEBGL_render_shared_exponent"),
            this.extensions.get("WEBGL_multi_draw"),
            (this.disjoint = this.extensions.get(
              "EXT_disjoint_timer_query_webgl2"
            )),
            (this.parallel = this.extensions.get(
              "KHR_parallel_shader_compile"
            ));
        }
        get coordinateSystem() {
          return u.TdN;
        }
        async getArrayBufferAsync(e) {
          return await this.attributeUtils.getArrayBufferAsync(e);
        }
        async waitForGPU() {
          await this.utils._clientWaitAsync();
        }
        async makeXRCompatible() {
          !0 !== this.gl.getContextAttributes().xrCompatible &&
            (await this.gl.makeXRCompatible());
        }
        setXRTarget(e) {
          this._xrFramebuffer = e;
        }
        setXRRenderTargetTextures(e, t, r = null) {
          let i = this.gl;
          if (
            (this.set(e.texture, { textureGPU: t, glInternalFormat: i.RGBA8 }),
            null !== r)
          ) {
            let t = e.stencilBuffer ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24;
            this.set(e.depthTexture, { textureGPU: r, glInternalFormat: t }),
              (e.autoAllocateDepthBuffer = !1),
              !0 ===
                this.extensions.has("WEBGL_multisampled_render_to_texture") &&
                console.warn(
                  "THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"
                );
          }
        }
        initTimestampQuery(e) {
          if (!this.disjoint || !this.trackTimestamp) return;
          let t = e.isComputeNode ? "compute" : "render";
          this.timestampQueryPool[t] ||
            (this.timestampQueryPool[t] = new mY(this.gl, t, 2048));
          let r = this.timestampQueryPool[t];
          null !== r.allocateQueriesForContext(e) && r.beginQuery(e);
        }
        prepareTimestampBuffer(e) {
          if (!this.disjoint || !this.trackTimestamp) return;
          let t = e.isComputeNode ? "compute" : "render";
          this.timestampQueryPool[t].endQuery(e);
        }
        getContext() {
          return this.gl;
        }
        beginRender(e) {
          let { state: t, gl: r } = this,
            i = this.get(e);
          if (
            (e.viewport
              ? this.updateViewport(e)
              : t.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight),
            e.scissor)
          ) {
            let { x: r, y: i, width: s, height: n } = e.scissorValue;
            t.scissor(r, e.height - n - i, s, n);
          }
          this.initTimestampQuery(e),
            (i.previousContext = this._currentContext),
            (this._currentContext = e),
            this._setFramebuffer(e),
            this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1);
          let s = e.occlusionQueryCount;
          s > 0 &&
            ((i.currentOcclusionQueries = i.occlusionQueries),
            (i.currentOcclusionQueryObjects = i.occlusionQueryObjects),
            (i.lastOcclusionObject = null),
            (i.occlusionQueries = Array(s)),
            (i.occlusionQueryObjects = Array(s)),
            (i.occlusionQueryIndex = 0));
        }
        finishRender(e) {
          let { gl: t, state: r } = this,
            i = this.get(e),
            s = i.previousContext;
          r.resetVertexState();
          let n = e.occlusionQueryCount;
          n > 0 &&
            (n > i.occlusionQueryIndex && t.endQuery(t.ANY_SAMPLES_PASSED),
            this.resolveOccludedAsync(e));
          let a = e.textures;
          if (null !== a)
            for (let e = 0; e < a.length; e++) {
              let t = a[e];
              t.generateMipmaps && this.generateMipmaps(t);
            }
          if (
            ((this._currentContext = s), null !== e.textures && e.renderTarget)
          ) {
            let i = this.get(e.renderTarget),
              { samples: s } = e.renderTarget;
            if (s > 0 && !1 === this._useMultisampledRTT(e.renderTarget)) {
              let s = i.framebuffers[e.getCacheKey()],
                n = t.COLOR_BUFFER_BIT,
                a = i.msaaFrameBuffer,
                o = e.textures;
              r.bindFramebuffer(t.READ_FRAMEBUFFER, a),
                r.bindFramebuffer(t.DRAW_FRAMEBUFFER, s);
              for (let r = 0; r < o.length; r++)
                if (e.scissor) {
                  let { x: r, y: s, width: a, height: o } = e.scissorValue,
                    l = e.height - o - s;
                  t.blitFramebuffer(
                    r,
                    l,
                    r + a,
                    l + o,
                    r,
                    l,
                    r + a,
                    l + o,
                    n,
                    t.NEAREST
                  ),
                    !0 === this._supportsInvalidateFramebuffer &&
                      t.invalidateSubFramebuffer(
                        t.READ_FRAMEBUFFER,
                        i.invalidationArray,
                        r,
                        l,
                        a,
                        o
                      );
                } else
                  t.blitFramebuffer(
                    0,
                    0,
                    e.width,
                    e.height,
                    0,
                    0,
                    e.width,
                    e.height,
                    n,
                    t.NEAREST
                  ),
                    !0 === this._supportsInvalidateFramebuffer &&
                      t.invalidateFramebuffer(
                        t.READ_FRAMEBUFFER,
                        i.invalidationArray
                      );
            }
          }
          null !== s &&
            (this._setFramebuffer(s),
            s.viewport
              ? this.updateViewport(s)
              : r.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight)),
            this.prepareTimestampBuffer(e);
        }
        resolveOccludedAsync(e) {
          let t = this.get(e),
            { currentOcclusionQueries: r, currentOcclusionQueryObjects: i } = t;
          if (r && i) {
            let e = new WeakSet(),
              { gl: s } = this;
            (t.currentOcclusionQueryObjects = null),
              (t.currentOcclusionQueries = null);
            let n = () => {
              let a = 0;
              for (let t = 0; t < r.length; t++) {
                let n = r[t];
                null !== n &&
                  s.getQueryParameter(n, s.QUERY_RESULT_AVAILABLE) &&
                  (0 === s.getQueryParameter(n, s.QUERY_RESULT) && e.add(i[t]),
                  (r[t] = null),
                  s.deleteQuery(n),
                  a++);
              }
              a < r.length ? requestAnimationFrame(n) : (t.occluded = e);
            };
            n();
          }
        }
        isOccluded(e, t) {
          let r = this.get(e);
          return r.occluded && r.occluded.has(t);
        }
        updateViewport(e) {
          let { state: t } = this,
            { x: r, y: i, width: s, height: n } = e.viewportValue;
          t.viewport(r, e.height - n - i, s, n);
        }
        setScissorTest(e) {
          this.state.setScissorTest(e);
        }
        getClearColor() {
          let e = super.getClearColor();
          return (e.r *= e.a), (e.g *= e.a), (e.b *= e.a), e;
        }
        clear(e, t, r, i = null, s = !0) {
          let { gl: n, renderer: a } = this;
          null === i &&
            (i = { textures: null, clearColorValue: this.getClearColor() });
          let o = 0;
          if (
            (e && (o |= n.COLOR_BUFFER_BIT),
            t && (o |= n.DEPTH_BUFFER_BIT),
            r && (o |= n.STENCIL_BUFFER_BIT),
            0 !== o)
          ) {
            let l;
            l = i.clearColorValue ? i.clearColorValue : this.getClearColor();
            let u = a.getClearDepth(),
              d = a.getClearStencil();
            if ((t && this.state.setDepthMask(!0), null === i.textures))
              n.clearColor(l.r, l.g, l.b, l.a), n.clear(o);
            else {
              if ((s && this._setFramebuffer(i), e))
                for (let e = 0; e < i.textures.length; e++)
                  0 === e
                    ? n.clearBufferfv(n.COLOR, e, [l.r, l.g, l.b, l.a])
                    : n.clearBufferfv(n.COLOR, e, [0, 0, 0, 1]);
              t && r
                ? n.clearBufferfi(n.DEPTH_STENCIL, 0, u, d)
                : t
                ? n.clearBufferfv(n.DEPTH, 0, [u])
                : r && n.clearBufferiv(n.STENCIL, 0, [d]);
            }
          }
        }
        beginCompute(e) {
          let { state: t, gl: r } = this;
          t.bindFramebuffer(r.FRAMEBUFFER, null), this.initTimestampQuery(e);
        }
        compute(e, t, r, i) {
          let { state: s, gl: n } = this;
          !1 === this.discard &&
            (n.enable(n.RASTERIZER_DISCARD), (this.discard = !0));
          let {
              programGPU: a,
              transformBuffers: o,
              attributes: l,
            } = this.get(i),
            u = this._getVaoKey(l),
            d = this.vaoCache[u];
          void 0 === d ? this._createVao(l) : s.setVertexState(d),
            s.useProgram(a),
            this._bindUniforms(r);
          let h = this._getTransformFeedback(o);
          n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, h),
            n.beginTransformFeedback(n.POINTS),
            l[0].isStorageInstancedBufferAttribute
              ? n.drawArraysInstanced(n.POINTS, 0, 1, t.count)
              : n.drawArrays(n.POINTS, 0, t.count),
            n.endTransformFeedback(),
            n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, null);
          for (let e = 0; e < o.length; e++) {
            let t = o[e];
            t.pbo &&
              this.textureUtils.copyBufferToTexture(t.transformBuffer, t.pbo),
              t.switchBuffers();
          }
        }
        finishCompute(e) {
          let t = this.gl;
          (this.discard = !1),
            t.disable(t.RASTERIZER_DISCARD),
            this.prepareTimestampBuffer(e),
            this._currentContext && this._setFramebuffer(this._currentContext);
        }
        draw(e) {
          let {
              object: t,
              pipeline: r,
              material: i,
              context: s,
              hardwareClippingPlanes: n,
            } = e,
            { programGPU: a } = this.get(r),
            { gl: o, state: l } = this,
            d = this.get(s),
            h = e.getDrawParameters();
          if (null === h) return;
          this._bindUniforms(e.getBindings());
          let c = t.isMesh && 0 > t.matrixWorld.determinant();
          l.setMaterial(i, c, n), l.useProgram(a);
          let p = this.get(e),
            g = p.staticVao;
          if (void 0 === g || p.geometryId !== e.geometry.id) {
            let t = this._getVaoKey(e.getAttributes());
            if (void 0 === (g = this.vaoCache[t])) {
              let t;
              ({ vaoGPU: g, staticVao: t } = this._createVao(
                e.getAttributes()
              )),
                t && ((p.staticVao = g), (p.geometryId = e.geometry.id));
            }
          }
          let m = e.getIndex(),
            f = null !== m ? this.get(m).bufferGPU : null;
          l.setVertexState(g, f);
          let y = d.lastOcclusionObject;
          if (y !== t && void 0 !== y) {
            if (
              (null !== y &&
                !0 === y.occlusionTest &&
                (o.endQuery(o.ANY_SAMPLES_PASSED), d.occlusionQueryIndex++),
              !0 === t.occlusionTest)
            ) {
              let e = o.createQuery();
              o.beginQuery(o.ANY_SAMPLES_PASSED, e),
                (d.occlusionQueries[d.occlusionQueryIndex] = e),
                (d.occlusionQueryObjects[d.occlusionQueryIndex] = t);
            }
            d.lastOcclusionObject = t;
          }
          let x = this.bufferRenderer;
          t.isPoints
            ? (x.mode = o.POINTS)
            : t.isLineSegments
            ? (x.mode = o.LINES)
            : t.isLine
            ? (x.mode = o.LINE_STRIP)
            : t.isLineLoop
            ? (x.mode = o.LINE_LOOP)
            : !0 === i.wireframe
            ? (l.setLineWidth(
                i.wireframeLinewidth * this.renderer.getPixelRatio()
              ),
              (x.mode = o.LINES))
            : (x.mode = o.TRIANGLES);
          let { vertexCount: b, instanceCount: T } = h,
            { firstVertex: _ } = h;
          if (((x.object = t), null !== m)) {
            _ *= m.array.BYTES_PER_ELEMENT;
            let e = this.get(m);
            (x.index = m.count), (x.type = e.type);
          } else x.index = 0;
          let v = () => {
            t.isBatchedMesh
              ? null !== t._multiDrawInstances
                ? ((0, u.mcG)(
                    "THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
                  ),
                  x.renderMultiDrawInstances(
                    t._multiDrawStarts,
                    t._multiDrawCounts,
                    t._multiDrawCount,
                    t._multiDrawInstances
                  ))
                : this.hasFeature("WEBGL_multi_draw")
                ? x.renderMultiDraw(
                    t._multiDrawStarts,
                    t._multiDrawCounts,
                    t._multiDrawCount
                  )
                : (0, u.mcG)(
                    "THREE.WebGLRenderer: WEBGL_multi_draw not supported."
                  )
              : T > 1
              ? x.renderInstances(_, b, T)
              : x.render(_, b);
          };
          if (e.camera.isArrayCamera && e.camera.cameras.length > 0) {
            let r = this.get(e.camera),
              i = e.camera.cameras,
              s = e.getBindingGroup("cameraIndex").bindings[0];
            if (void 0 === r.indexesGPU || r.indexesGPU.length !== i.length) {
              let e = new Uint32Array([0, 0, 0, 0]),
                t = [];
              for (let r = 0, s = i.length; r < s; r++) {
                let i = o.createBuffer();
                (e[0] = r),
                  o.bindBuffer(o.UNIFORM_BUFFER, i),
                  o.bufferData(o.UNIFORM_BUFFER, e, o.STATIC_DRAW),
                  t.push(i);
              }
              r.indexesGPU = t;
            }
            let n = this.get(s),
              a = this.renderer.getPixelRatio();
            for (let s = 0, u = i.length; s < u; s++) {
              let u = i[s];
              if (t.layers.test(u.layers)) {
                let t = u.viewport,
                  i = t.x * a,
                  d = t.y * a,
                  h = t.width * a,
                  c = t.height * a;
                l.viewport(
                  Math.floor(i),
                  Math.floor(e.context.height - c - d),
                  Math.floor(h),
                  Math.floor(c)
                ),
                  l.bindBufferBase(o.UNIFORM_BUFFER, n.index, r.indexesGPU[s]),
                  v();
              }
            }
          } else v();
        }
        needsRenderUpdate() {
          return !1;
        }
        getRenderCacheKey() {
          return "";
        }
        createDefaultTexture(e) {
          this.textureUtils.createDefaultTexture(e);
        }
        createTexture(e, t) {
          this.textureUtils.createTexture(e, t);
        }
        updateTexture(e, t) {
          this.textureUtils.updateTexture(e, t);
        }
        generateMipmaps(e) {
          this.textureUtils.generateMipmaps(e);
        }
        destroyTexture(e) {
          this.textureUtils.destroyTexture(e);
        }
        async copyTextureToBuffer(e, t, r, i, s, n) {
          return this.textureUtils.copyTextureToBuffer(e, t, r, i, s, n);
        }
        createSampler() {}
        destroySampler() {}
        createNodeBuilder(e, t) {
          return new mF(e, t);
        }
        createProgram(e) {
          let t = this.gl,
            { stage: r, code: i } = e,
            s =
              "fragment" === r
                ? t.createShader(t.FRAGMENT_SHADER)
                : t.createShader(t.VERTEX_SHADER);
          t.shaderSource(s, i),
            t.compileShader(s),
            this.set(e, { shaderGPU: s });
        }
        destroyProgram(e) {
          this.delete(e);
        }
        createRenderPipeline(e, t) {
          let r = this.gl,
            i = e.pipeline,
            { fragmentProgram: s, vertexProgram: n } = i,
            a = r.createProgram(),
            o = this.get(s).shaderGPU,
            l = this.get(n).shaderGPU;
          if (
            (r.attachShader(a, o),
            r.attachShader(a, l),
            r.linkProgram(a),
            this.set(i, { programGPU: a, fragmentShader: o, vertexShader: l }),
            null !== t && this.parallel)
          ) {
            let s = new Promise((t) => {
              let s = this.parallel,
                n = () => {
                  r.getProgramParameter(a, s.COMPLETION_STATUS_KHR)
                    ? (this._completeCompile(e, i), t())
                    : requestAnimationFrame(n);
                };
              n();
            });
            t.push(s);
            return;
          }
          this._completeCompile(e, i);
        }
        _handleSource(e, t) {
          let r = e.split("\n"),
            i = [],
            s = Math.max(t - 6, 0),
            n = Math.min(t + 6, r.length);
          for (let e = s; e < n; e++) {
            let s = e + 1;
            i.push(`${s === t ? ">" : " "} ${s}: ${r[e]}`);
          }
          return i.join("\n");
        }
        _getShaderErrors(e, t, r) {
          let i = e.getShaderParameter(t, e.COMPILE_STATUS),
            s = e.getShaderInfoLog(t).trim();
          if (i && "" === s) return "";
          let n = /ERROR: 0:(\d+)/.exec(s);
          if (!n) return s;
          {
            let i = parseInt(n[1]);
            return (
              r.toUpperCase() +
              "\n\n" +
              s +
              "\n\n" +
              this._handleSource(e.getShaderSource(t), i)
            );
          }
        }
        _logProgramError(e, t, r) {
          if (this.renderer.debug.checkShaderErrors) {
            let i = this.gl,
              s = i.getProgramInfoLog(e).trim();
            if (!1 === i.getProgramParameter(e, i.LINK_STATUS))
              if ("function" == typeof this.renderer.debug.onShaderError)
                this.renderer.debug.onShaderError(i, e, r, t);
              else {
                let n = this._getShaderErrors(i, r, "vertex"),
                  a = this._getShaderErrors(i, t, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    i.getError() +
                    " - VALIDATE_STATUS " +
                    i.getProgramParameter(e, i.VALIDATE_STATUS) +
                    "\n\nProgram Info Log: " +
                    s +
                    "\n" +
                    n +
                    "\n" +
                    a
                );
              }
            else
              "" !== s &&
                console.warn("THREE.WebGLProgram: Program Info Log:", s);
          }
        }
        _completeCompile(e, t) {
          let { state: r, gl: i } = this,
            { programGPU: s, fragmentShader: n, vertexShader: a } = this.get(t);
          !1 === i.getProgramParameter(s, i.LINK_STATUS) &&
            this._logProgramError(s, n, a),
            r.useProgram(s);
          let o = e.getBindings();
          this._setupBindings(o, s), this.set(t, { programGPU: s });
        }
        createComputePipeline(e, t) {
          let { state: r, gl: i } = this,
            s = {
              stage: "fragment",
              code: "#version 300 es\nprecision highp float;\nvoid main() {}",
            };
          this.createProgram(s);
          let { computeProgram: n } = e,
            a = i.createProgram(),
            o = this.get(s).shaderGPU,
            l = this.get(n).shaderGPU,
            u = n.transforms,
            d = [],
            h = [];
          for (let e = 0; e < u.length; e++) {
            let t = u[e];
            d.push(t.varyingName), h.push(t.attributeNode);
          }
          i.attachShader(a, o),
            i.attachShader(a, l),
            i.transformFeedbackVaryings(a, d, i.SEPARATE_ATTRIBS),
            i.linkProgram(a),
            !1 === i.getProgramParameter(a, i.LINK_STATUS) &&
              this._logProgramError(a, o, l),
            r.useProgram(a),
            this._setupBindings(t, a);
          let c = n.attributes,
            p = [],
            g = [];
          for (let e = 0; e < c.length; e++) {
            let t = c[e].node.attribute;
            p.push(t),
              this.has(t) ||
                this.attributeUtils.createAttribute(t, i.ARRAY_BUFFER);
          }
          for (let e = 0; e < h.length; e++) {
            let t = h[e].attribute;
            this.has(t) ||
              this.attributeUtils.createAttribute(t, i.ARRAY_BUFFER);
            let r = this.get(t);
            g.push(r);
          }
          this.set(e, { programGPU: a, transformBuffers: g, attributes: p });
        }
        createBindings(e, t) {
          if (!1 === this._knownBindings.has(t)) {
            this._knownBindings.add(t);
            let e = 0,
              r = 0;
            for (let i of t)
              for (let t of (this.set(i, { textures: r, uniformBuffers: e }),
              i.bindings))
                t.isUniformBuffer && e++, t.isSampledTexture && r++;
          }
          this.updateBindings(e, t);
        }
        updateBindings(e) {
          let { gl: t } = this,
            r = this.get(e),
            i = r.uniformBuffers,
            s = r.textures;
          for (let r of e.bindings)
            if (r.isUniformsGroup || r.isUniformBuffer) {
              let e = r.buffer,
                s = t.createBuffer();
              t.bindBuffer(t.UNIFORM_BUFFER, s),
                t.bufferData(t.UNIFORM_BUFFER, e, t.DYNAMIC_DRAW),
                this.set(r, { index: i++, bufferGPU: s });
            } else if (r.isSampledTexture) {
              let { textureGPU: e, glTextureType: t } = this.get(r.texture);
              this.set(r, { index: s++, textureGPU: e, glTextureType: t });
            }
        }
        updateBinding(e) {
          let t = this.gl;
          if (e.isUniformsGroup || e.isUniformBuffer) {
            let r = this.get(e).bufferGPU,
              i = e.buffer;
            t.bindBuffer(t.UNIFORM_BUFFER, r),
              t.bufferData(t.UNIFORM_BUFFER, i, t.DYNAMIC_DRAW);
          }
        }
        createIndexAttribute(e) {
          let t = this.gl;
          this.attributeUtils.createAttribute(e, t.ELEMENT_ARRAY_BUFFER);
        }
        createAttribute(e) {
          if (this.has(e)) return;
          let t = this.gl;
          this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
        }
        createStorageAttribute(e) {
          if (this.has(e)) return;
          let t = this.gl;
          this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
        }
        updateAttribute(e) {
          this.attributeUtils.updateAttribute(e);
        }
        destroyAttribute(e) {
          this.attributeUtils.destroyAttribute(e);
        }
        hasFeature(e) {
          let t = Object.keys(mX).filter((t) => mX[t] === e),
            r = this.extensions;
          for (let e = 0; e < t.length; e++) if (r.has(t[e])) return !0;
          return !1;
        }
        getMaxAnisotropy() {
          return this.capabilities.getMaxAnisotropy();
        }
        copyTextureToTexture(e, t, r = null, i = null, s = 0) {
          this.textureUtils.copyTextureToTexture(e, t, r, i, s);
        }
        copyFramebufferToTexture(e, t, r) {
          this.textureUtils.copyFramebufferToTexture(e, t, r);
        }
        _setFramebuffer(e) {
          let { gl: t, state: r } = this,
            i = null;
          if (null !== e.textures) {
            let s,
              n = e.renderTarget,
              a = this.get(n),
              { samples: o, depthBuffer: l, stencilBuffer: u } = n,
              d = !0 === n.isWebGLCubeRenderTarget,
              h = !0 === n.isRenderTarget3D,
              c = !0 === n.isRenderTargetArray,
              p = !0 === n.isXRRenderTarget,
              g = !0 === p && !0 === n.hasExternalTextures,
              m = a.msaaFrameBuffer,
              f = a.depthRenderbuffer,
              y = this.extensions.get("WEBGL_multisampled_render_to_texture"),
              x = this._useMultisampledRTT(n),
              b = u7(e);
            if (
              (d
                ? (a.cubeFramebuffers || (a.cubeFramebuffers = {}),
                  (s = a.cubeFramebuffers[b]))
                : p && !1 === g
                ? (s = this._xrFramebuffer)
                : (a.framebuffers || (a.framebuffers = {}),
                  (s = a.framebuffers[b])),
              void 0 === s)
            ) {
              (s = t.createFramebuffer()), r.bindFramebuffer(t.FRAMEBUFFER, s);
              let i = e.textures;
              if (d) {
                a.cubeFramebuffers[b] = s;
                let { textureGPU: e } = this.get(i[0]),
                  r = this.renderer._activeCubeFace;
                t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + r,
                  e,
                  0
                );
              } else {
                a.framebuffers[b] = s;
                for (let r = 0; r < i.length; r++) {
                  let s = i[r],
                    n = this.get(s);
                  (n.renderTarget = e.renderTarget), (n.cacheKey = b);
                  let a = t.COLOR_ATTACHMENT0 + r;
                  if (h || c) {
                    let e = this.renderer._activeCubeFace;
                    t.framebufferTextureLayer(
                      t.FRAMEBUFFER,
                      a,
                      n.textureGPU,
                      0,
                      e
                    );
                  } else
                    x
                      ? y.framebufferTexture2DMultisampleEXT(
                          t.FRAMEBUFFER,
                          a,
                          t.TEXTURE_2D,
                          n.textureGPU,
                          0,
                          o
                        )
                      : t.framebufferTexture2D(
                          t.FRAMEBUFFER,
                          a,
                          t.TEXTURE_2D,
                          n.textureGPU,
                          0
                        );
                }
                r.drawBuffers(e, s);
              }
              if (n.isXRRenderTarget && !0 === n.autoAllocateDepthBuffer) {
                let r = t.createRenderbuffer();
                this.textureUtils.setupRenderBufferStorage(r, e, 0, x),
                  (a.xrDepthRenderbuffer = r);
              } else if (null !== e.depthTexture) {
                let r = this.get(e.depthTexture),
                  i = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                (r.renderTarget = e.renderTarget),
                  (r.cacheKey = b),
                  x
                    ? y.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        i,
                        t.TEXTURE_2D,
                        r.textureGPU,
                        0,
                        o
                      )
                    : t.framebufferTexture2D(
                        t.FRAMEBUFFER,
                        i,
                        t.TEXTURE_2D,
                        r.textureGPU,
                        0
                      );
              }
            } else if (p && g) {
              r.bindFramebuffer(t.FRAMEBUFFER, s);
              let i = this.get(e.textures[0]);
              x
                ? y.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_2D,
                    i.textureGPU,
                    0,
                    o
                  )
                : t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_2D,
                    i.textureGPU,
                    0
                  );
              let l = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
              if (!0 === n.autoAllocateDepthBuffer) {
                let e = a.xrDepthRenderbuffer;
                t.bindRenderbuffer(t.RENDERBUFFER, e),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    l,
                    t.RENDERBUFFER,
                    e
                  );
              } else {
                let r = this.get(e.depthTexture);
                x
                  ? y.framebufferTexture2DMultisampleEXT(
                      t.FRAMEBUFFER,
                      l,
                      t.TEXTURE_2D,
                      r.textureGPU,
                      0,
                      o
                    )
                  : t.framebufferTexture2D(
                      t.FRAMEBUFFER,
                      l,
                      t.TEXTURE_2D,
                      r.textureGPU,
                      0
                    );
              }
            }
            if (o > 0 && !1 === x) {
              if (void 0 === m) {
                let i = [];
                (m = t.createFramebuffer()),
                  r.bindFramebuffer(t.FRAMEBUFFER, m);
                let s = [],
                  n = e.textures;
                for (let r = 0; r < n.length; r++) {
                  if (
                    ((s[r] = t.createRenderbuffer()),
                    t.bindRenderbuffer(t.RENDERBUFFER, s[r]),
                    i.push(t.COLOR_ATTACHMENT0 + r),
                    l)
                  ) {
                    let e = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                    i.push(e);
                  }
                  let n = e.textures[r],
                    a = this.get(n);
                  t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    o,
                    a.glInternalFormat,
                    e.width,
                    e.height
                  ),
                    t.framebufferRenderbuffer(
                      t.FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + r,
                      t.RENDERBUFFER,
                      s[r]
                    );
                }
                if (
                  ((a.msaaFrameBuffer = m),
                  (a.msaaRenderbuffers = s),
                  void 0 === f)
                ) {
                  (f = t.createRenderbuffer()),
                    this.textureUtils.setupRenderBufferStorage(f, e, o),
                    (a.depthRenderbuffer = f);
                  let r = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                  i.push(r);
                }
                a.invalidationArray = i;
              }
              i = a.msaaFrameBuffer;
            } else i = s;
          }
          r.bindFramebuffer(t.FRAMEBUFFER, i);
        }
        _getVaoKey(e) {
          let t = "";
          for (let r = 0; r < e.length; r++) t += ":" + this.get(e[r]).id;
          return t;
        }
        _createVao(e) {
          let { gl: t } = this,
            r = t.createVertexArray(),
            i = "",
            s = !0;
          t.bindVertexArray(r);
          for (let r = 0; r < e.length; r++) {
            let n,
              a,
              o = e[r],
              l = this.get(o);
            (i += ":" + l.id),
              t.bindBuffer(t.ARRAY_BUFFER, l.bufferGPU),
              t.enableVertexAttribArray(r),
              (o.isStorageBufferAttribute ||
                o.isStorageInstancedBufferAttribute) &&
                (s = !1),
              !0 === o.isInterleavedBufferAttribute
                ? ((n = o.data.stride * l.bytesPerElement),
                  (a = o.offset * l.bytesPerElement))
                : ((n = 0), (a = 0)),
              l.isInteger
                ? t.vertexAttribIPointer(r, o.itemSize, l.type, n, a)
                : t.vertexAttribPointer(
                    r,
                    o.itemSize,
                    l.type,
                    o.normalized,
                    n,
                    a
                  ),
              o.isInstancedBufferAttribute && !o.isInterleavedBufferAttribute
                ? t.vertexAttribDivisor(r, o.meshPerAttribute)
                : o.isInterleavedBufferAttribute &&
                  o.data.isInstancedInterleavedBuffer &&
                  t.vertexAttribDivisor(r, o.data.meshPerAttribute);
          }
          return (
            t.bindBuffer(t.ARRAY_BUFFER, null),
            (this.vaoCache[i] = r),
            { vaoGPU: r, staticVao: s }
          );
        }
        _getTransformFeedback(e) {
          let t = "";
          for (let r = 0; r < e.length; r++) t += ":" + e[r].id;
          let r = this.transformFeedbackCache[t];
          if (void 0 !== r) return r;
          let { gl: i } = this;
          (r = i.createTransformFeedback()),
            i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, r);
          for (let t = 0; t < e.length; t++) {
            let r = e[t];
            i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, t, r.transformBuffer);
          }
          return (
            i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, null),
            (this.transformFeedbackCache[t] = r),
            r
          );
        }
        _setupBindings(e, t) {
          let r = this.gl;
          for (let i of e)
            for (let e of i.bindings) {
              let i = this.get(e).index;
              if (e.isUniformsGroup || e.isUniformBuffer) {
                let s = r.getUniformBlockIndex(t, e.name);
                r.uniformBlockBinding(t, s, i);
              } else if (e.isSampledTexture) {
                let s = r.getUniformLocation(t, e.name);
                r.uniform1i(s, i);
              }
            }
        }
        _bindUniforms(e) {
          let { gl: t, state: r } = this;
          for (let i of e)
            for (let e of i.bindings) {
              let i = this.get(e),
                s = i.index;
              e.isUniformsGroup || e.isUniformBuffer
                ? r.bindBufferBase(t.UNIFORM_BUFFER, s, i.bufferGPU)
                : e.isSampledTexture &&
                  r.bindTexture(i.glTextureType, i.textureGPU, t.TEXTURE0 + s);
            }
        }
        _useMultisampledRTT(e) {
          return (
            e.samples > 0 &&
            !0 ===
              this.extensions.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== e.autoAllocateDepthBuffer
          );
        }
        dispose() {
          let e = this.extensions.get("WEBGL_lose_context");
          e && e.loseContext(),
            this.renderer.domElement.removeEventListener(
              "webglcontextlost",
              this._onContextLost
            );
        }
      }
      let mJ = {
          PointList: "point-list",
          LineList: "line-list",
          LineStrip: "line-strip",
          TriangleList: "triangle-list",
          TriangleStrip: "triangle-strip",
        },
        m0 = {
          Never: "never",
          Less: "less",
          Equal: "equal",
          LessEqual: "less-equal",
          Greater: "greater",
          NotEqual: "not-equal",
          GreaterEqual: "greater-equal",
          Always: "always",
        },
        m1 = { Store: "store" },
        m2 = { Load: "load", Clear: "clear" },
        m3 = { CCW: "ccw" },
        m4 = { None: "none", Front: "front", Back: "back" },
        m6 = { Uint16: "uint16", Uint32: "uint32" },
        m5 = {
          R8Unorm: "r8unorm",
          R8Snorm: "r8snorm",
          R8Uint: "r8uint",
          R8Sint: "r8sint",
          R16Uint: "r16uint",
          R16Sint: "r16sint",
          R16Float: "r16float",
          RG8Unorm: "rg8unorm",
          RG8Snorm: "rg8snorm",
          RG8Uint: "rg8uint",
          RG8Sint: "rg8sint",
          R32Uint: "r32uint",
          R32Sint: "r32sint",
          R32Float: "r32float",
          RG16Uint: "rg16uint",
          RG16Sint: "rg16sint",
          RG16Float: "rg16float",
          RGBA8Unorm: "rgba8unorm",
          RGBA8UnormSRGB: "rgba8unorm-srgb",
          RGBA8Snorm: "rgba8snorm",
          RGBA8Uint: "rgba8uint",
          RGBA8Sint: "rgba8sint",
          BGRA8Unorm: "bgra8unorm",
          BGRA8UnormSRGB: "bgra8unorm-srgb",
          RGB9E5UFloat: "rgb9e5ufloat",
          RGB10A2Unorm: "rgb10a2unorm",
          RG11B10uFloat: "rgb10a2unorm",
          RG32Uint: "rg32uint",
          RG32Sint: "rg32sint",
          RG32Float: "rg32float",
          RGBA16Uint: "rgba16uint",
          RGBA16Sint: "rgba16sint",
          RGBA16Float: "rgba16float",
          RGBA32Uint: "rgba32uint",
          RGBA32Sint: "rgba32sint",
          RGBA32Float: "rgba32float",
          Stencil8: "stencil8",
          Depth16Unorm: "depth16unorm",
          Depth24Plus: "depth24plus",
          Depth24PlusStencil8: "depth24plus-stencil8",
          Depth32Float: "depth32float",
          Depth32FloatStencil8: "depth32float-stencil8",
          BC1RGBAUnorm: "bc1-rgba-unorm",
          BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
          BC2RGBAUnorm: "bc2-rgba-unorm",
          BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
          BC3RGBAUnorm: "bc3-rgba-unorm",
          BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
          BC4RUnorm: "bc4-r-unorm",
          BC4RSnorm: "bc4-r-snorm",
          BC5RGUnorm: "bc5-rg-unorm",
          BC5RGSnorm: "bc5-rg-snorm",
          BC6HRGBUFloat: "bc6h-rgb-ufloat",
          BC6HRGBFloat: "bc6h-rgb-float",
          BC7RGBAUnorm: "bc7-rgba-unorm",
          BC7RGBAUnormSRGB: "bc7-rgba-srgb",
          ETC2RGB8Unorm: "etc2-rgb8unorm",
          ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
          ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
          ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
          ETC2RGBA8Unorm: "etc2-rgba8unorm",
          ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
          EACR11Unorm: "eac-r11unorm",
          EACR11Snorm: "eac-r11snorm",
          EACRG11Unorm: "eac-rg11unorm",
          EACRG11Snorm: "eac-rg11snorm",
          ASTC4x4Unorm: "astc-4x4-unorm",
          ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
          ASTC5x4Unorm: "astc-5x4-unorm",
          ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
          ASTC5x5Unorm: "astc-5x5-unorm",
          ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
          ASTC6x5Unorm: "astc-6x5-unorm",
          ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
          ASTC6x6Unorm: "astc-6x6-unorm",
          ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
          ASTC8x5Unorm: "astc-8x5-unorm",
          ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
          ASTC8x6Unorm: "astc-8x6-unorm",
          ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
          ASTC8x8Unorm: "astc-8x8-unorm",
          ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
          ASTC10x5Unorm: "astc-10x5-unorm",
          ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
          ASTC10x6Unorm: "astc-10x6-unorm",
          ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
          ASTC10x8Unorm: "astc-10x8-unorm",
          ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
          ASTC10x10Unorm: "astc-10x10-unorm",
          ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
          ASTC12x10Unorm: "astc-12x10-unorm",
          ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
          ASTC12x12Unorm: "astc-12x12-unorm",
          ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb",
        },
        m8 = {
          ClampToEdge: "clamp-to-edge",
          Repeat: "repeat",
          MirrorRepeat: "mirror-repeat",
        },
        m9 = { Linear: "linear", Nearest: "nearest" },
        m7 = {
          Zero: "zero",
          One: "one",
          Src: "src",
          OneMinusSrc: "one-minus-src",
          SrcAlpha: "src-alpha",
          OneMinusSrcAlpha: "one-minus-src-alpha",
          Dst: "dst",
          OneMinusDstColor: "one-minus-dst",
          DstAlpha: "dst-alpha",
          OneMinusDstAlpha: "one-minus-dst-alpha",
          SrcAlphaSaturated: "src-alpha-saturated",
          Constant: "constant",
          OneMinusConstant: "one-minus-constant",
        },
        fe = {
          Add: "add",
          Subtract: "subtract",
          ReverseSubtract: "reverse-subtract",
          Min: "min",
          Max: "max",
        },
        ft = { None: 0, All: 15 },
        fr = {
          Keep: "keep",
          Zero: "zero",
          Replace: "replace",
          Invert: "invert",
          IncrementClamp: "increment-clamp",
          DecrementClamp: "decrement-clamp",
          IncrementWrap: "increment-wrap",
          DecrementWrap: "decrement-wrap",
        },
        fi = { Storage: "storage", ReadOnlyStorage: "read-only-storage" },
        fs = {
          WriteOnly: "write-only",
          ReadOnly: "read-only",
          ReadWrite: "read-write",
        },
        fn = {
          Float: "float",
          UnfilterableFloat: "unfilterable-float",
          Depth: "depth",
          SInt: "sint",
          UInt: "uint",
        },
        fa = { TwoD: "2d", ThreeD: "3d" },
        fo = { TwoD: "2d", TwoDArray: "2d-array", Cube: "cube", ThreeD: "3d" },
        fl = { All: "all" },
        fu = { Vertex: "vertex", Instance: "instance" },
        fd = {
          DepthClipControl: "depth-clip-control",
          Depth32FloatStencil8: "depth32float-stencil8",
          TextureCompressionBC: "texture-compression-bc",
          TextureCompressionETC2: "texture-compression-etc2",
          TextureCompressionASTC: "texture-compression-astc",
          TimestampQuery: "timestamp-query",
          IndirectFirstInstance: "indirect-first-instance",
          ShaderF16: "shader-f16",
          RG11B10UFloat: "rg11b10ufloat-renderable",
          BGRA8UNormStorage: "bgra8unorm-storage",
          Float32Filterable: "float32-filterable",
          ClipDistances: "clip-distances",
          DualSourceBlending: "dual-source-blending",
          Subgroups: "subgroups",
        };
      class fh extends mm {
        constructor(e, t) {
          super(e),
            (this.texture = t),
            (this.version = t ? t.version : 0),
            (this.isSampler = !0);
        }
      }
      class fc extends fh {
        constructor(e, t, r) {
          super(e, t ? t.value : null),
            (this.textureNode = t),
            (this.groupNode = r);
        }
        update() {
          this.texture = this.textureNode.value;
        }
      }
      class fp extends mf {
        constructor(e, t) {
          super(e, t ? t.array : null),
            (this.attribute = t),
            (this.isStorageBuffer = !0);
        }
      }
      let fg = 0;
      class fm extends fp {
        constructor(e, t) {
          super("StorageBuffer_" + fg++, e ? e.value : null),
            (this.nodeUniform = e),
            (this.access = e ? e.access : F.READ_WRITE),
            (this.groupNode = t);
        }
        get buffer() {
          return this.nodeUniform.value;
        }
      }
      class ff extends uk {
        constructor(e) {
          super(), (this.device = e);
          let t = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`,
            r = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`,
            i = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
          (this.mipmapSampler = e.createSampler({ minFilter: m9.Linear })),
            (this.flipYSampler = e.createSampler({ minFilter: m9.Nearest })),
            (this.transferPipelines = {}),
            (this.flipYPipelines = {}),
            (this.mipmapVertexShaderModule = e.createShaderModule({
              label: "mipmapVertex",
              code: t,
            })),
            (this.mipmapFragmentShaderModule = e.createShaderModule({
              label: "mipmapFragment",
              code: r,
            })),
            (this.flipYFragmentShaderModule = e.createShaderModule({
              label: "flipYFragment",
              code: i,
            }));
        }
        getTransferPipeline(e) {
          let t = this.transferPipelines[e];
          return (
            void 0 === t &&
              ((t = this.device.createRenderPipeline({
                label: `mipmap-${e}`,
                vertex: {
                  module: this.mipmapVertexShaderModule,
                  entryPoint: "main",
                },
                fragment: {
                  module: this.mipmapFragmentShaderModule,
                  entryPoint: "main",
                  targets: [{ format: e }],
                },
                primitive: {
                  topology: mJ.TriangleStrip,
                  stripIndexFormat: m6.Uint32,
                },
                layout: "auto",
              })),
              (this.transferPipelines[e] = t)),
            t
          );
        }
        getFlipYPipeline(e) {
          let t = this.flipYPipelines[e];
          return (
            void 0 === t &&
              ((t = this.device.createRenderPipeline({
                label: `flipY-${e}`,
                vertex: {
                  module: this.mipmapVertexShaderModule,
                  entryPoint: "main",
                },
                fragment: {
                  module: this.flipYFragmentShaderModule,
                  entryPoint: "main",
                  targets: [{ format: e }],
                },
                primitive: {
                  topology: mJ.TriangleStrip,
                  stripIndexFormat: m6.Uint32,
                },
                layout: "auto",
              })),
              (this.flipYPipelines[e] = t)),
            t
          );
        }
        flipY(e, t, r = 0) {
          let i = t.format,
            { width: s, height: n } = t.size,
            a = this.getTransferPipeline(i),
            o = this.getFlipYPipeline(i),
            l = this.device.createTexture({
              size: { width: s, height: n, depthOrArrayLayers: 1 },
              format: i,
              usage:
                GPUTextureUsage.RENDER_ATTACHMENT |
                GPUTextureUsage.TEXTURE_BINDING,
            }),
            u = e.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: fo.TwoD,
              baseArrayLayer: r,
            }),
            d = l.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: fo.TwoD,
              baseArrayLayer: 0,
            }),
            h = this.device.createCommandEncoder({}),
            c = (e, t, r) => {
              let i = e.getBindGroupLayout(0),
                s = this.device.createBindGroup({
                  layout: i,
                  entries: [
                    { binding: 0, resource: this.flipYSampler },
                    { binding: 1, resource: t },
                  ],
                }),
                n = h.beginRenderPass({
                  colorAttachments: [
                    {
                      view: r,
                      loadOp: m2.Clear,
                      storeOp: m1.Store,
                      clearValue: [0, 0, 0, 0],
                    },
                  ],
                });
              n.setPipeline(e),
                n.setBindGroup(0, s),
                n.draw(4, 1, 0, 0),
                n.end();
            };
          c(a, u, d),
            c(o, d, u),
            this.device.queue.submit([h.finish()]),
            l.destroy();
        }
        generateMipmaps(e, t, r = 0) {
          let i = this.get(e);
          void 0 === i.useCount && ((i.useCount = 0), (i.layers = []));
          let s = i.layers[r] || this._mipmapCreateBundles(e, t, r),
            n = this.device.createCommandEncoder({});
          this._mipmapRunBundles(n, s),
            this.device.queue.submit([n.finish()]),
            0 !== i.useCount && (i.layers[r] = s),
            i.useCount++;
        }
        _mipmapCreateBundles(e, t, r) {
          let i = this.getTransferPipeline(t.format),
            s = i.getBindGroupLayout(0),
            n = e.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: fo.TwoD,
              baseArrayLayer: r,
            }),
            a = [];
          for (let o = 1; o < t.mipLevelCount; o++) {
            let l = this.device.createBindGroup({
                layout: s,
                entries: [
                  { binding: 0, resource: this.mipmapSampler },
                  { binding: 1, resource: n },
                ],
              }),
              u = e.createView({
                baseMipLevel: o,
                mipLevelCount: 1,
                dimension: fo.TwoD,
                baseArrayLayer: r,
              }),
              d = {
                colorAttachments: [
                  {
                    view: u,
                    loadOp: m2.Clear,
                    storeOp: m1.Store,
                    clearValue: [0, 0, 0, 0],
                  },
                ],
              },
              h = this.device.createRenderBundleEncoder({
                colorFormats: [t.format],
              });
            h.setPipeline(i),
              h.setBindGroup(0, l),
              h.draw(4, 1, 0, 0),
              a.push({ renderBundles: [h.finish()], passDescriptor: d }),
              (n = u);
          }
          return a;
        }
        _mipmapRunBundles(e, t) {
          let r = t.length;
          for (let i = 0; i < r; i++) {
            let r = t[i],
              s = e.beginRenderPass(r.passDescriptor);
            s.executeBundles(r.renderBundles), s.end();
          }
        }
      }
      let fy = {
          [u.amv]: "never",
          [u.vim]: "less",
          [u.kO0]: "equal",
          [u.TiK]: "less-equal",
          [u.eoi]: "greater",
          [u.gWB]: "greater-equal",
          [u.FFZ]: "always",
          [u.jzd]: "not-equal",
        },
        fx = [0, 1, 3, 2, 4, 5];
      class fb {
        constructor(e) {
          (this.backend = e),
            (this._passUtils = null),
            (this.defaultTexture = {}),
            (this.defaultCubeTexture = {}),
            (this.defaultVideoFrame = null),
            (this.colorBuffer = null),
            (this.depthTexture = new u.VCu()),
            (this.depthTexture.name = "depthBuffer");
        }
        createSampler(e) {
          let t = this.backend,
            r = t.device,
            i = t.get(e),
            s = {
              addressModeU: this._convertAddressMode(e.wrapS),
              addressModeV: this._convertAddressMode(e.wrapT),
              addressModeW: this._convertAddressMode(e.wrapR),
              magFilter: this._convertFilterMode(e.magFilter),
              minFilter: this._convertFilterMode(e.minFilter),
              mipmapFilter: this._convertFilterMode(e.minFilter),
              maxAnisotropy: 1,
            };
          s.magFilter === m9.Linear &&
            s.minFilter === m9.Linear &&
            s.mipmapFilter === m9.Linear &&
            (s.maxAnisotropy = e.anisotropy),
            e.isDepthTexture &&
              null !== e.compareFunction &&
              (s.compare = fy[e.compareFunction]),
            (i.sampler = r.createSampler(s));
        }
        createDefaultTexture(e) {
          let t,
            r = fT(e);
          e.isCubeTexture
            ? (t = this._getDefaultCubeTextureGPU(r))
            : e.isVideoTexture
            ? (this.backend.get(e).externalTexture =
                this._getDefaultVideoFrame())
            : (t = this._getDefaultTextureGPU(r)),
            (this.backend.get(e).texture = t);
        }
        createTexture(e, t = {}) {
          let r = this.backend,
            i = r.get(e);
          if (i.initialized)
            throw Error("WebGPUTextureUtils: Texture already initialized.");
          void 0 === t.needsMipmaps && (t.needsMipmaps = !1),
            void 0 === t.levels && (t.levels = 1),
            void 0 === t.depth && (t.depth = 1);
          let { width: s, height: n, depth: a, levels: o } = t;
          e.isFramebufferTexture &&
            (t.renderTarget
              ? (t.format = this.backend.utils.getCurrentColorFormat(
                  t.renderTarget
                ))
              : (t.format = this.backend.utils.getPreferredCanvasFormat()));
          let l = this._getDimension(e),
            u = e.internalFormat || t.format || fT(e, r.device);
          i.format = u;
          let {
              samples: d,
              primarySamples: h,
              isMSAA: c,
            } = r.utils.getTextureSampleData(e),
            p =
              GPUTextureUsage.TEXTURE_BINDING |
              GPUTextureUsage.COPY_DST |
              GPUTextureUsage.COPY_SRC;
          !0 === e.isStorageTexture && (p |= GPUTextureUsage.STORAGE_BINDING),
            !0 !== e.isCompressedTexture &&
              !0 !== e.isCompressedArrayTexture &&
              (p |= GPUTextureUsage.RENDER_ATTACHMENT);
          let g = {
            label: e.name,
            size: { width: s, height: n, depthOrArrayLayers: a },
            mipLevelCount: o,
            sampleCount: h,
            dimension: l,
            format: u,
            usage: p,
          };
          if (e.isVideoTexture) {
            let t = e.source.data,
              r = new VideoFrame(t);
            (g.size.width = r.displayWidth),
              (g.size.height = r.displayHeight),
              r.close(),
              (i.externalTexture = t);
          } else {
            if (void 0 === u) {
              console.warn("WebGPURenderer: Texture format not supported."),
                this.createDefaultTexture(e);
              return;
            }
            i.texture = r.device.createTexture(g);
          }
          if (c) {
            let e = Object.assign({}, g);
            (e.label = e.label + "-msaa"),
              (e.sampleCount = d),
              (i.msaaTexture = r.device.createTexture(e));
          }
          (i.initialized = !0), (i.textureDescriptorGPU = g);
        }
        destroyTexture(e) {
          let t = this.backend,
            r = t.get(e);
          void 0 !== r.texture && r.texture.destroy(),
            void 0 !== r.msaaTexture && r.msaaTexture.destroy(),
            t.delete(e);
        }
        destroySampler(e) {
          let t = this.backend.get(e);
          delete t.sampler;
        }
        generateMipmaps(e) {
          let t = this.backend.get(e);
          if (e.isCubeTexture)
            for (let e = 0; e < 6; e++)
              this._generateMipmaps(t.texture, t.textureDescriptorGPU, e);
          else {
            let r = e.image.depth || 1;
            for (let e = 0; e < r; e++)
              this._generateMipmaps(t.texture, t.textureDescriptorGPU, e);
          }
        }
        getColorBuffer() {
          this.colorBuffer && this.colorBuffer.destroy();
          let e = this.backend,
            { width: t, height: r } = e.getDrawingBufferSize();
          return (
            (this.colorBuffer = e.device.createTexture({
              label: "colorBuffer",
              size: { width: t, height: r, depthOrArrayLayers: 1 },
              sampleCount: e.utils.getSampleCount(e.renderer.samples),
              format: e.utils.getPreferredCanvasFormat(),
              usage:
                GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            })),
            this.colorBuffer
          );
        }
        getDepthBuffer(e = !0, t = !1) {
          let r,
            i,
            s = this.backend,
            { width: n, height: a } = s.getDrawingBufferSize(),
            o = this.depthTexture,
            l = s.get(o).texture;
          if (
            (t ? ((r = u.dcC), (i = u.V3x)) : e && ((r = u.zdS), (i = u.bkx)),
            void 0 !== l)
          ) {
            if (
              o.image.width === n &&
              o.image.height === a &&
              o.format === r &&
              o.type === i
            )
              return l;
            this.destroyTexture(o);
          }
          return (
            (o.name = "depthBuffer"),
            (o.format = r),
            (o.type = i),
            (o.image.width = n),
            (o.image.height = a),
            this.createTexture(o, { width: n, height: a }),
            s.get(o).texture
          );
        }
        updateTexture(e, t) {
          let r = this.backend.get(e),
            { textureDescriptorGPU: i } = r;
          if (!e.isRenderTargetTexture && void 0 !== i) {
            if (e.isDataTexture)
              this._copyBufferToTexture(t.image, r.texture, i, 0, e.flipY);
            else if (e.isDataArrayTexture || e.isData3DTexture)
              for (let s = 0; s < t.image.depth; s++)
                this._copyBufferToTexture(t.image, r.texture, i, s, e.flipY, s);
            else
              e.isCompressedTexture || e.isCompressedArrayTexture
                ? this._copyCompressedBufferToTexture(e.mipmaps, r.texture, i)
                : e.isCubeTexture
                ? this._copyCubeMapToTexture(t.images, r.texture, i, e.flipY)
                : e.isVideoTexture
                ? (r.externalTexture = e.source.data)
                : this._copyImageToTexture(t.image, r.texture, i, 0, e.flipY);
            (r.version = e.version), e.onUpdate && e.onUpdate(e);
          }
        }
        async copyTextureToBuffer(e, t, r, i, s, n) {
          let a = this.backend.device,
            o = this.backend.get(e),
            l = o.texture,
            u = o.textureDescriptorGPU.format,
            d = this._getBytesPerTexel(u),
            h = i * d;
          h = 256 * Math.ceil(h / 256);
          let c = a.createBuffer({
              size: i * s * d,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            }),
            p = a.createCommandEncoder();
          p.copyTextureToBuffer(
            { texture: l, origin: { x: t, y: r, z: n } },
            { buffer: c, bytesPerRow: h },
            { width: i, height: s }
          );
          let g = this._getTypedArrayType(u);
          return (
            a.queue.submit([p.finish()]),
            await c.mapAsync(GPUMapMode.READ),
            new g(c.getMappedRange())
          );
        }
        _isEnvironmentTexture(e) {
          let t = e.mapping;
          return t === u.wfO || t === u.uV5 || t === u.hy7 || t === u.xFO;
        }
        _getDefaultTextureGPU(e) {
          let t = this.defaultTexture[e];
          if (void 0 === t) {
            let r = new u.gPd();
            (r.minFilter = u.hxR),
              (r.magFilter = u.hxR),
              this.createTexture(r, { width: 1, height: 1, format: e }),
              (this.defaultTexture[e] = t = r);
          }
          return this.backend.get(t).texture;
        }
        _getDefaultCubeTextureGPU(e) {
          let t = this.defaultTexture[e];
          if (void 0 === t) {
            let r = new u.b4q();
            (r.minFilter = u.hxR),
              (r.magFilter = u.hxR),
              this.createTexture(r, { width: 1, height: 1, depth: 6 }),
              (this.defaultCubeTexture[e] = t = r);
          }
          return this.backend.get(t).texture;
        }
        _getDefaultVideoFrame() {
          let e = this.defaultVideoFrame;
          return (
            null === e &&
              (this.defaultVideoFrame = e =
                new VideoFrame(new Uint8Array([0, 0, 0, 255]), {
                  timestamp: 0,
                  codedWidth: 1,
                  codedHeight: 1,
                  format: "RGBA",
                })),
            e
          );
        }
        _copyCubeMapToTexture(e, t, r, i) {
          for (let s = 0; s < 6; s++) {
            let n = e[s],
              a = !0 === i ? fx[s] : s;
            n.isDataTexture
              ? this._copyBufferToTexture(n.image, t, r, a, i)
              : this._copyImageToTexture(n, t, r, a, i);
          }
        }
        _copyImageToTexture(e, t, r, i, s) {
          this.backend.device.queue.copyExternalImageToTexture(
            { source: e, flipY: s },
            { texture: t, mipLevel: 0, origin: { x: 0, y: 0, z: i } },
            { width: e.width, height: e.height, depthOrArrayLayers: 1 }
          );
        }
        _getPassUtils() {
          let e = this._passUtils;
          return (
            null === e && (this._passUtils = e = new ff(this.backend.device)), e
          );
        }
        _generateMipmaps(e, t, r = 0) {
          this._getPassUtils().generateMipmaps(e, t, r);
        }
        _flipY(e, t, r = 0) {
          this._getPassUtils().flipY(e, t, r);
        }
        _copyBufferToTexture(e, t, r, i, s, n = 0) {
          let a = this.backend.device,
            o = e.data,
            l = this._getBytesPerTexel(r.format),
            u = e.width * l;
          a.queue.writeTexture(
            { texture: t, mipLevel: 0, origin: { x: 0, y: 0, z: i } },
            o,
            { offset: e.width * e.height * l * n, bytesPerRow: u },
            { width: e.width, height: e.height, depthOrArrayLayers: 1 }
          ),
            !0 === s && this._flipY(t, r, i);
        }
        _copyCompressedBufferToTexture(e, t, r) {
          let i = this.backend.device,
            s = this._getBlockData(r.format),
            n = r.size.depthOrArrayLayers > 1;
          for (let a = 0; a < e.length; a++) {
            let o = e[a],
              l = o.width,
              u = o.height,
              d = n ? r.size.depthOrArrayLayers : 1,
              h = Math.ceil(l / s.width) * s.byteLength,
              c = h * Math.ceil(u / s.height);
            for (let e = 0; e < d; e++)
              i.queue.writeTexture(
                { texture: t, mipLevel: a, origin: { x: 0, y: 0, z: e } },
                o.data,
                {
                  offset: e * c,
                  bytesPerRow: h,
                  rowsPerImage: Math.ceil(u / s.height),
                },
                {
                  width: Math.ceil(l / s.width) * s.width,
                  height: Math.ceil(u / s.height) * s.height,
                  depthOrArrayLayers: 1,
                }
              );
          }
        }
        _getBlockData(e) {
          return e === m5.BC1RGBAUnorm || e === m5.BC1RGBAUnormSRGB
            ? { byteLength: 8, width: 4, height: 4 }
            : e === m5.BC2RGBAUnorm ||
              e === m5.BC2RGBAUnormSRGB ||
              e === m5.BC3RGBAUnorm ||
              e === m5.BC3RGBAUnormSRGB
            ? { byteLength: 16, width: 4, height: 4 }
            : e === m5.BC4RUnorm || e === m5.BC4RSNorm
            ? { byteLength: 8, width: 4, height: 4 }
            : e === m5.BC5RGUnorm ||
              e === m5.BC5RGSnorm ||
              e === m5.BC6HRGBUFloat ||
              e === m5.BC6HRGBFloat ||
              e === m5.BC7RGBAUnorm ||
              e === m5.BC7RGBAUnormSRGB
            ? { byteLength: 16, width: 4, height: 4 }
            : e === m5.ETC2RGB8Unorm ||
              e === m5.ETC2RGB8UnormSRGB ||
              e === m5.ETC2RGB8A1Unorm ||
              e === m5.ETC2RGB8A1UnormSRGB
            ? { byteLength: 8, width: 4, height: 4 }
            : e === m5.ETC2RGBA8Unorm || e === m5.ETC2RGBA8UnormSRGB
            ? { byteLength: 16, width: 4, height: 4 }
            : e === m5.EACR11Unorm || e === m5.EACR11Snorm
            ? { byteLength: 8, width: 4, height: 4 }
            : e === m5.EACRG11Unorm ||
              e === m5.EACRG11Snorm ||
              e === m5.ASTC4x4Unorm ||
              e === m5.ASTC4x4UnormSRGB
            ? { byteLength: 16, width: 4, height: 4 }
            : e === m5.ASTC5x4Unorm || e === m5.ASTC5x4UnormSRGB
            ? { byteLength: 16, width: 5, height: 4 }
            : e === m5.ASTC5x5Unorm || e === m5.ASTC5x5UnormSRGB
            ? { byteLength: 16, width: 5, height: 5 }
            : e === m5.ASTC6x5Unorm || e === m5.ASTC6x5UnormSRGB
            ? { byteLength: 16, width: 6, height: 5 }
            : e === m5.ASTC6x6Unorm || e === m5.ASTC6x6UnormSRGB
            ? { byteLength: 16, width: 6, height: 6 }
            : e === m5.ASTC8x5Unorm || e === m5.ASTC8x5UnormSRGB
            ? { byteLength: 16, width: 8, height: 5 }
            : e === m5.ASTC8x6Unorm || e === m5.ASTC8x6UnormSRGB
            ? { byteLength: 16, width: 8, height: 6 }
            : e === m5.ASTC8x8Unorm || e === m5.ASTC8x8UnormSRGB
            ? { byteLength: 16, width: 8, height: 8 }
            : e === m5.ASTC10x5Unorm || e === m5.ASTC10x5UnormSRGB
            ? { byteLength: 16, width: 10, height: 5 }
            : e === m5.ASTC10x6Unorm || e === m5.ASTC10x6UnormSRGB
            ? { byteLength: 16, width: 10, height: 6 }
            : e === m5.ASTC10x8Unorm || e === m5.ASTC10x8UnormSRGB
            ? { byteLength: 16, width: 10, height: 8 }
            : e === m5.ASTC10x10Unorm || e === m5.ASTC10x10UnormSRGB
            ? { byteLength: 16, width: 10, height: 10 }
            : e === m5.ASTC12x10Unorm || e === m5.ASTC12x10UnormSRGB
            ? { byteLength: 16, width: 12, height: 10 }
            : e === m5.ASTC12x12Unorm || e === m5.ASTC12x12UnormSRGB
            ? { byteLength: 16, width: 12, height: 12 }
            : void 0;
        }
        _convertAddressMode(e) {
          let t = m8.ClampToEdge;
          return (
            e === u.GJx
              ? (t = m8.Repeat)
              : e === u.kTW && (t = m8.MirrorRepeat),
            t
          );
        }
        _convertFilterMode(e) {
          let t = m9.Linear;
          return (
            (e === u.hxR || e === u.pHI || e === u.Cfg) && (t = m9.Nearest), t
          );
        }
        _getBytesPerTexel(e) {
          return e === m5.R8Unorm ||
            e === m5.R8Snorm ||
            e === m5.R8Uint ||
            e === m5.R8Sint
            ? 1
            : e === m5.R16Uint ||
              e === m5.R16Sint ||
              e === m5.R16Float ||
              e === m5.RG8Unorm ||
              e === m5.RG8Snorm ||
              e === m5.RG8Uint ||
              e === m5.RG8Sint
            ? 2
            : e === m5.R32Uint ||
              e === m5.R32Sint ||
              e === m5.R32Float ||
              e === m5.RG16Uint ||
              e === m5.RG16Sint ||
              e === m5.RG16Float ||
              e === m5.RGBA8Unorm ||
              e === m5.RGBA8UnormSRGB ||
              e === m5.RGBA8Snorm ||
              e === m5.RGBA8Uint ||
              e === m5.RGBA8Sint ||
              e === m5.BGRA8Unorm ||
              e === m5.BGRA8UnormSRGB ||
              e === m5.RGB9E5UFloat ||
              e === m5.RGB10A2Unorm ||
              e === m5.RG11B10UFloat ||
              e === m5.Depth32Float ||
              e === m5.Depth24Plus ||
              e === m5.Depth24PlusStencil8 ||
              e === m5.Depth32FloatStencil8
            ? 4
            : e === m5.RG32Uint ||
              e === m5.RG32Sint ||
              e === m5.RG32Float ||
              e === m5.RGBA16Uint ||
              e === m5.RGBA16Sint ||
              e === m5.RGBA16Float
            ? 8
            : e === m5.RGBA32Uint || e === m5.RGBA32Sint || e === m5.RGBA32Float
            ? 16
            : void 0;
        }
        _getTypedArrayType(e) {
          return e === m5.R8Uint
            ? Uint8Array
            : e === m5.R8Sint
            ? Int8Array
            : e === m5.R8Unorm
            ? Uint8Array
            : e === m5.R8Snorm
            ? Int8Array
            : e === m5.RG8Uint
            ? Uint8Array
            : e === m5.RG8Sint
            ? Int8Array
            : e === m5.RG8Unorm
            ? Uint8Array
            : e === m5.RG8Snorm
            ? Int8Array
            : e === m5.RGBA8Uint
            ? Uint8Array
            : e === m5.RGBA8Sint
            ? Int8Array
            : e === m5.RGBA8Unorm
            ? Uint8Array
            : e === m5.RGBA8Snorm
            ? Int8Array
            : e === m5.R16Uint
            ? Uint16Array
            : e === m5.R16Sint
            ? Int16Array
            : e === m5.RG16Uint
            ? Uint16Array
            : e === m5.RG16Sint
            ? Int16Array
            : e === m5.RGBA16Uint
            ? Uint16Array
            : e === m5.RGBA16Sint
            ? Int16Array
            : e === m5.R16Float || e === m5.RG16Float || e === m5.RGBA16Float
            ? Uint16Array
            : e === m5.R32Uint
            ? Uint32Array
            : e === m5.R32Sint
            ? Int32Array
            : e === m5.R32Float
            ? Float32Array
            : e === m5.RG32Uint
            ? Uint32Array
            : e === m5.RG32Sint
            ? Int32Array
            : e === m5.RG32Float
            ? Float32Array
            : e === m5.RGBA32Uint
            ? Uint32Array
            : e === m5.RGBA32Sint
            ? Int32Array
            : e === m5.RGBA32Float
            ? Float32Array
            : e === m5.BGRA8Unorm || e === m5.BGRA8UnormSRGB
            ? Uint8Array
            : e === m5.RGB10A2Unorm ||
              e === m5.RGB9E5UFloat ||
              e === m5.RG11B10UFloat
            ? Uint32Array
            : e === m5.Depth32Float
            ? Float32Array
            : e === m5.Depth24Plus || e === m5.Depth24PlusStencil8
            ? Uint32Array
            : e === m5.Depth32FloatStencil8
            ? Float32Array
            : void 0;
        }
        _getDimension(e) {
          let t;
          return e.isData3DTexture ? fa.ThreeD : fa.TwoD;
        }
      }
      function fT(e, t = null) {
        let r,
          i = e.format,
          s = e.type,
          n = e.colorSpace;
        if (!0 === e.isCompressedTexture || !0 === e.isCompressedArrayTexture)
          switch (i) {
            case u.Nz6:
              r = n === u.er$ ? m5.BC1RGBAUnormSRGB : m5.BC1RGBAUnorm;
              break;
            case u.jR7:
              r = n === u.er$ ? m5.BC2RGBAUnormSRGB : m5.BC2RGBAUnorm;
              break;
            case u.BXX:
              r = n === u.er$ ? m5.BC3RGBAUnormSRGB : m5.BC3RGBAUnorm;
              break;
            case u.Riy:
              r = n === u.er$ ? m5.ETC2RGB8UnormSRGB : m5.ETC2RGB8Unorm;
              break;
            case u.KDk:
              r = n === u.er$ ? m5.ETC2RGBA8UnormSRGB : m5.ETC2RGBA8Unorm;
              break;
            case u.qa3:
              r = n === u.er$ ? m5.ASTC4x4UnormSRGB : m5.ASTC4x4Unorm;
              break;
            case u.B_h:
              r = n === u.er$ ? m5.ASTC5x4UnormSRGB : m5.ASTC5x4Unorm;
              break;
            case u.czI:
              r = n === u.er$ ? m5.ASTC5x5UnormSRGB : m5.ASTC5x5Unorm;
              break;
            case u.rSH:
              r = n === u.er$ ? m5.ASTC6x5UnormSRGB : m5.ASTC6x5Unorm;
              break;
            case u.Qrf:
              r = n === u.er$ ? m5.ASTC6x6UnormSRGB : m5.ASTC6x6Unorm;
              break;
            case u.psI:
              r = n === u.er$ ? m5.ASTC8x5UnormSRGB : m5.ASTC8x5Unorm;
              break;
            case u.a5J:
              r = n === u.er$ ? m5.ASTC8x6UnormSRGB : m5.ASTC8x6Unorm;
              break;
            case u._QJ:
              r = n === u.er$ ? m5.ASTC8x8UnormSRGB : m5.ASTC8x8Unorm;
              break;
            case u.uB5:
              r = n === u.er$ ? m5.ASTC10x5UnormSRGB : m5.ASTC10x5Unorm;
              break;
            case u.lyL:
              r = n === u.er$ ? m5.ASTC10x6UnormSRGB : m5.ASTC10x6Unorm;
              break;
            case u.bC7:
              r = n === u.er$ ? m5.ASTC10x8UnormSRGB : m5.ASTC10x8Unorm;
              break;
            case u.y3Z:
              r = n === u.er$ ? m5.ASTC10x10UnormSRGB : m5.ASTC10x10Unorm;
              break;
            case u.ojs:
              r = n === u.er$ ? m5.ASTC12x10UnormSRGB : m5.ASTC12x10Unorm;
              break;
            case u.S$4:
              r = n === u.er$ ? m5.ASTC12x12UnormSRGB : m5.ASTC12x12Unorm;
              break;
            case u.GWd:
              r = n === u.er$ ? m5.RGBA8UnormSRGB : m5.RGBA8Unorm;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture format.", i);
          }
        else
          switch (i) {
            case u.GWd:
              switch (s) {
                case u.tJf:
                  r = m5.RGBA8Snorm;
                  break;
                case u.fBL:
                  r = m5.RGBA16Sint;
                  break;
                case u.cHt:
                  r = m5.RGBA16Uint;
                  break;
                case u.bkx:
                  r = m5.RGBA32Uint;
                  break;
                case u.Yuy:
                  r = m5.RGBA32Sint;
                  break;
                case u.OUM:
                  r = n === u.er$ ? m5.RGBA8UnormSRGB : m5.RGBA8Unorm;
                  break;
                case u.ix0:
                  r = m5.RGBA16Float;
                  break;
                case u.RQf:
                  r = m5.RGBA32Float;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RGBAFormat.",
                    s
                  );
              }
              break;
            case u.HIg:
              s === u.Dmk
                ? (r = m5.RGB9E5UFloat)
                : console.error(
                    "WebGPURenderer: Unsupported texture type with RGBFormat.",
                    s
                  );
              break;
            case u.VT0:
              switch (s) {
                case u.tJf:
                  r = m5.R8Snorm;
                  break;
                case u.fBL:
                  r = m5.R16Sint;
                  break;
                case u.cHt:
                  r = m5.R16Uint;
                  break;
                case u.bkx:
                  r = m5.R32Uint;
                  break;
                case u.Yuy:
                  r = m5.R32Sint;
                  break;
                case u.OUM:
                  r = m5.R8Unorm;
                  break;
                case u.ix0:
                  r = m5.R16Float;
                  break;
                case u.RQf:
                  r = m5.R32Float;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RedFormat.",
                    s
                  );
              }
              break;
            case u.paN:
              switch (s) {
                case u.tJf:
                  r = m5.RG8Snorm;
                  break;
                case u.fBL:
                  r = m5.RG16Sint;
                  break;
                case u.cHt:
                  r = m5.RG16Uint;
                  break;
                case u.bkx:
                  r = m5.RG32Uint;
                  break;
                case u.Yuy:
                  r = m5.RG32Sint;
                  break;
                case u.OUM:
                  r = m5.RG8Unorm;
                  break;
                case u.ix0:
                  r = m5.RG16Float;
                  break;
                case u.RQf:
                  r = m5.RG32Float;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RGFormat.",
                    s
                  );
              }
              break;
            case u.zdS:
              switch (s) {
                case u.cHt:
                  r = m5.Depth16Unorm;
                  break;
                case u.bkx:
                  r = m5.Depth24Plus;
                  break;
                case u.RQf:
                  r = m5.Depth32Float;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with DepthFormat.",
                    s
                  );
              }
              break;
            case u.dcC:
              switch (s) {
                case u.V3x:
                  r = m5.Depth24PlusStencil8;
                  break;
                case u.RQf:
                  t &&
                    !1 === t.features.has(fd.Depth32FloatStencil8) &&
                    console.error(
                      'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'
                    ),
                    (r = m5.Depth32FloatStencil8);
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with DepthStencilFormat.",
                    s
                  );
              }
              break;
            case u.ZQM:
              switch (s) {
                case u.Yuy:
                  r = m5.R32Sint;
                  break;
                case u.bkx:
                  r = m5.R32Uint;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RedIntegerFormat.",
                    s
                  );
              }
              break;
            case u.TkQ:
              switch (s) {
                case u.Yuy:
                  r = m5.RG32Sint;
                  break;
                case u.bkx:
                  r = m5.RG32Uint;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RGIntegerFormat.",
                    s
                  );
              }
              break;
            case u.c90:
              switch (s) {
                case u.Yuy:
                  r = m5.RGBA32Sint;
                  break;
                case u.bkx:
                  r = m5.RGBA32Uint;
                  break;
                default:
                  console.error(
                    "WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.",
                    s
                  );
              }
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture format.", i);
          }
        return r;
      }
      let f_ =
          /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,
        fv = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi,
        fN = {
          f32: "float",
          i32: "int",
          u32: "uint",
          bool: "bool",
          "vec2<f32>": "vec2",
          "vec2<i32>": "ivec2",
          "vec2<u32>": "uvec2",
          "vec2<bool>": "bvec2",
          vec2f: "vec2",
          vec2i: "ivec2",
          vec2u: "uvec2",
          vec2b: "bvec2",
          "vec3<f32>": "vec3",
          "vec3<i32>": "ivec3",
          "vec3<u32>": "uvec3",
          "vec3<bool>": "bvec3",
          vec3f: "vec3",
          vec3i: "ivec3",
          vec3u: "uvec3",
          vec3b: "bvec3",
          "vec4<f32>": "vec4",
          "vec4<i32>": "ivec4",
          "vec4<u32>": "uvec4",
          "vec4<bool>": "bvec4",
          vec4f: "vec4",
          vec4i: "ivec4",
          vec4u: "uvec4",
          vec4b: "bvec4",
          "mat2x2<f32>": "mat2",
          mat2x2f: "mat2",
          "mat3x3<f32>": "mat3",
          mat3x3f: "mat3",
          "mat4x4<f32>": "mat4",
          mat4x4f: "mat4",
          sampler: "sampler",
          texture_1d: "texture",
          texture_2d: "texture",
          texture_2d_array: "texture",
          texture_multisampled_2d: "cubeTexture",
          texture_depth_2d: "depthTexture",
          texture_depth_multisampled_2d: "depthTexture",
          texture_3d: "texture3D",
          texture_cube: "cubeTexture",
          texture_cube_array: "cubeTexture",
          texture_storage_1d: "storageTexture",
          texture_storage_2d: "storageTexture",
          texture_storage_2d_array: "storageTexture",
          texture_storage_3d: "storageTexture",
        },
        fS = (e) => {
          let t = (e = e.trim()).match(f_);
          if (null !== t && 4 === t.length) {
            let r = t[2],
              i = [],
              s = null;
            for (; null !== (s = fv.exec(r)); )
              i.push({ name: s[1], type: s[2] });
            let n = [];
            for (let e = 0; e < i.length; e++) {
              let { name: t, type: r } = i[e],
                s = r;
              s.startsWith("ptr")
                ? (s = "pointer")
                : (s.startsWith("texture") && (s = r.split("<")[0]),
                  (s = fN[s])),
                n.push(new gB(s, t));
            }
            let a = e.substring(t[0].length),
              o = t[3] || "void",
              l = void 0 !== t[1] ? t[1] : "";
            return {
              type: fN[o] || o,
              inputs: n,
              name: l,
              inputsCode: r,
              blockCode: a,
              outputType: o,
            };
          }
          throw Error("FunctionNode: Function is not a WGSL code.");
        };
      class fR extends g$ {
        constructor(e) {
          let {
            type: t,
            inputs: r,
            name: i,
            inputsCode: s,
            blockCode: n,
            outputType: a,
          } = fS(e);
          super(t, r, i),
            (this.inputsCode = s),
            (this.blockCode = n),
            (this.outputType = a);
        }
        getCode(e = this.name) {
          let t = "void" !== this.outputType ? "-> " + this.outputType : "";
          return `fn ${e} ( ${this.inputsCode.trim()} ) ${t}` + this.blockCode;
        }
      }
      class fA extends gz {
        parseFunction(e) {
          return new fR(e);
        }
      }
      let fC =
          "undefined" != typeof self
            ? self.GPUShaderStage
            : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 },
        fE = {
          [F.READ_ONLY]: "read",
          [F.WRITE_ONLY]: "write",
          [F.READ_WRITE]: "read_write",
        },
        fw = { [u.GJx]: "repeat", [u.ghU]: "clamp", [u.kTW]: "mirror" },
        fM = {
          vertex: fC ? fC.VERTEX : 1,
          fragment: fC ? fC.FRAGMENT : 2,
          compute: fC ? fC.COMPUTE : 4,
        },
        fB = { instance: !0, swizzleAssign: !1, storageBuffer: !0 },
        fF = { "^^": "tsl_xor" },
        fU = {
          float: "f32",
          int: "i32",
          uint: "u32",
          bool: "bool",
          color: "vec3<f32>",
          vec2: "vec2<f32>",
          ivec2: "vec2<i32>",
          uvec2: "vec2<u32>",
          bvec2: "vec2<bool>",
          vec3: "vec3<f32>",
          ivec3: "vec3<i32>",
          uvec3: "vec3<u32>",
          bvec3: "vec3<bool>",
          vec4: "vec4<f32>",
          ivec4: "vec4<i32>",
          uvec4: "vec4<u32>",
          bvec4: "vec4<bool>",
          mat2: "mat2x2<f32>",
          mat3: "mat3x3<f32>",
          mat4: "mat4x4<f32>",
        },
        fI = {},
        fP = {
          tsl_xor: new hJ(
            "fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"
          ),
          mod_float: new hJ(
            "fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"
          ),
          mod_vec2: new hJ(
            "fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"
          ),
          mod_vec3: new hJ(
            "fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"
          ),
          mod_vec4: new hJ(
            "fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"
          ),
          equals_bool: new hJ(
            "fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"
          ),
          equals_bvec2: new hJ(
            "fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"
          ),
          equals_bvec3: new hJ(
            "fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"
          ),
          equals_bvec4: new hJ(
            "fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"
          ),
          repeatWrapping_float: new hJ(
            "fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"
          ),
          mirrorWrapping_float: new hJ(
            "fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"
          ),
          clampWrapping_float: new hJ(
            "fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"
          ),
          biquadraticTexture: new hJ(`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`),
        },
        fL = {
          dFdx: "dpdx",
          dFdy: "- dpdy",
          mod_float: "tsl_mod_float",
          mod_vec2: "tsl_mod_vec2",
          mod_vec3: "tsl_mod_vec3",
          mod_vec4: "tsl_mod_vec4",
          equals_bool: "tsl_equals_bool",
          equals_bvec2: "tsl_equals_bvec2",
          equals_bvec3: "tsl_equals_bvec3",
          equals_bvec4: "tsl_equals_bvec4",
          inversesqrt: "inverseSqrt",
          bitcast: "bitcast<f32>",
        };
      "undefined" != typeof navigator &&
        /Windows/g.test(navigator.userAgent) &&
        ((fP.pow_float = new hJ(
          "fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"
        )),
        (fP.pow_vec2 = new hJ(
          "fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",
          [fP.pow_float]
        )),
        (fP.pow_vec3 = new hJ(
          "fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",
          [fP.pow_float]
        )),
        (fP.pow_vec4 = new hJ(
          "fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",
          [fP.pow_float]
        )),
        (fL.pow_float = "tsl_pow_float"),
        (fL.pow_vec2 = "tsl_pow_vec2"),
        (fL.pow_vec3 = "tsl_pow_vec3"),
        (fL.pow_vec4 = "tsl_pow_vec4"));
      let fD = "";
      !0 !==
        ("undefined" != typeof navigator &&
          /Firefox|Deno/g.test(navigator.userAgent)) &&
        (fD += "diagnostic( off, derivative_uniformity );\n");
      class fV extends gw {
        constructor(e, t) {
          super(e, t, new fA()),
            (this.uniformGroups = {}),
            (this.builtins = {}),
            (this.directives = {}),
            (this.scopedArrays = new Map());
        }
        needsToWorkingColorSpace(e) {
          return !0 === e.isVideoTexture && e.colorSpace !== u.jf0;
        }
        _generateTextureSample(e, t, r, i, s = this.shaderStage) {
          if ("fragment" === s)
            if (i) return `textureSample( ${t}, ${t}_sampler, ${r}, ${i} )`;
            else return `textureSample( ${t}, ${t}_sampler, ${r} )`;
          return this.isFilteredTexture(e)
            ? this.generateFilteredTexture(e, t, r)
            : this.generateTextureLod(e, t, r, i, "0");
        }
        _generateVideoSample(e, t, r = this.shaderStage) {
          if ("fragment" === r)
            return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;
          console.error(
            `WebGPURenderer: THREE.VideoTexture does not support ${r} shader.`
          );
        }
        _generateTextureSampleLevel(e, t, r, i, s, n = this.shaderStage) {
          return ("fragment" === n || "compute" === n) &&
            !1 === this.isUnfilterable(e)
            ? `textureSampleLevel( ${t}, ${t}_sampler, ${r}, ${i} )`
            : this.isFilteredTexture(e)
            ? this.generateFilteredTexture(e, t, r, i)
            : this.generateTextureLod(e, t, r, s, i);
        }
        generateWrapFunction(e) {
          let t = `tsl_coord_${fw[e.wrapS]}S_${fw[e.wrapT]}_${
              e.isData3DTexture ? "3d" : "2d"
            }T`,
            r = fI[t];
          if (void 0 === r) {
            let i = [],
              s = e.isData3DTexture ? "vec3f" : "vec2f",
              n = `fn ${t}( coord : ${s} ) -> ${s} {

	return ${s}(
`,
              a = (e, t) => {
                e === u.GJx
                  ? (i.push(fP.repeatWrapping_float),
                    (n += `		tsl_repeatWrapping_float( coord.${t} )`))
                  : e === u.ghU
                  ? (i.push(fP.clampWrapping_float),
                    (n += `		tsl_clampWrapping_float( coord.${t} )`))
                  : e === u.kTW
                  ? (i.push(fP.mirrorWrapping_float),
                    (n += `		tsl_mirrorWrapping_float( coord.${t} )`))
                  : ((n += `		coord.${t}`),
                    console.warn(
                      `WebGPURenderer: Unsupported texture wrap type "${e}" for vertex shader.`
                    ));
              };
            a(e.wrapS, "x"),
              (n += ",\n"),
              a(e.wrapT, "y"),
              e.isData3DTexture && ((n += ",\n"), a(e.wrapR, "z")),
              (n += "\n	);\n\n}\n"),
              (fI[t] = r = new hJ(n, i));
          }
          return r.build(this), t;
        }
        generateArrayDeclaration(e, t) {
          return `array< ${this.getType(e)}, ${t} >`;
        }
        generateTextureDimension(e, t, r) {
          let i = this.getDataFromNode(e, this.shaderStage, this.globalCache);
          void 0 === i.dimensionsSnippet && (i.dimensionsSnippet = {});
          let s = i.dimensionsSnippet[r];
          if (void 0 === i.dimensionsSnippet[r]) {
            let n,
              a,
              { primarySamples: o } =
                this.renderer.backend.utils.getTextureSampleData(e);
            (a = e.isData3DTexture ? "vec3<u32>" : "vec2<u32>"),
              (n =
                o > 1 || e.isVideoTexture || e.isStorageTexture
                  ? t
                  : `${t}${r ? `, u32( ${r} )` : ""}`),
              (s = new is(new iH(`textureDimensions( ${n} )`, a))),
              (i.dimensionsSnippet[r] = s),
              (e.isDataArrayTexture || e.isData3DTexture) &&
                (i.arrayLayerCount = new is(
                  new iH(`textureNumLayers(${t})`, "u32")
                )),
              e.isTextureCube &&
                (i.cubeFaceCount = new is(new iH("6u", "u32")));
          }
          return s.build(this);
        }
        generateFilteredTexture(e, t, r, i = "0u") {
          this._include("biquadraticTexture");
          let s = this.generateWrapFunction(e),
            n = this.generateTextureDimension(e, t, i);
          return `tsl_biquadraticTexture( ${t}, ${s}( ${r} ), ${n}, u32( ${i} ) )`;
        }
        generateTextureLod(e, t, r, i, s = "0u") {
          let n = this.generateWrapFunction(e),
            a = this.generateTextureDimension(e, t, s),
            o = e.isData3DTexture ? "vec3" : "vec2",
            l = `${o}<u32>(${n}(${r}) * ${o}<f32>(${a}))`;
          return this.generateTextureLoad(e, t, l, i, s);
        }
        generateTextureLoad(e, t, r, i, s = "0u") {
          return !0 === e.isVideoTexture || !0 === e.isStorageTexture
            ? `textureLoad( ${t}, ${r} )`
            : i
            ? `textureLoad( ${t}, ${r}, ${i}, u32( ${s} ) )`
            : `textureLoad( ${t}, ${r}, u32( ${s} ) )`;
        }
        generateTextureStore(e, t, r, i) {
          return `textureStore( ${t}, ${r}, ${i} )`;
        }
        isSampleCompare(e) {
          return !0 === e.isDepthTexture && null !== e.compareFunction;
        }
        isUnfilterable(e) {
          return (
            "float" !== this.getComponentTypeFromTexture(e) ||
            (!this.isAvailable("float32Filterable") &&
              !0 === e.isDataTexture &&
              e.type === u.RQf) ||
            (!1 === this.isSampleCompare(e) &&
              e.minFilter === u.hxR &&
              e.magFilter === u.hxR) ||
            this.renderer.backend.utils.getTextureSampleData(e).primarySamples >
              1
          );
        }
        generateTexture(e, t, r, i, s = this.shaderStage) {
          let n = null;
          return !0 === e.isVideoTexture
            ? this._generateVideoSample(t, r, s)
            : this.isUnfilterable(e)
            ? this.generateTextureLod(e, t, r, i, "0", s)
            : this._generateTextureSample(e, t, r, i, s);
        }
        generateTextureGrad(e, t, r, i, s, n = this.shaderStage) {
          if ("fragment" === n)
            return `textureSampleGrad( ${t}, ${t}_sampler, ${r},  ${i[0]}, ${i[1]} )`;
          console.error(
            `WebGPURenderer: THREE.TextureNode.gradient() does not support ${n} shader.`
          );
        }
        generateTextureCompare(e, t, r, i, s, n = this.shaderStage) {
          if ("fragment" === n)
            return `textureSampleCompare( ${t}, ${t}_sampler, ${r}, ${i} )`;
          console.error(
            `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${n} shader.`
          );
        }
        generateTextureLevel(e, t, r, i, s, n = this.shaderStage) {
          let a = null;
          return !0 === e.isVideoTexture
            ? this._generateVideoSample(t, r, n)
            : this._generateTextureSampleLevel(e, t, r, i, s, n);
        }
        generateTextureBias(e, t, r, i, s, n = this.shaderStage) {
          if ("fragment" === n)
            return `textureSampleBias( ${t}, ${t}_sampler, ${r}, ${i} )`;
          console.error(
            `WebGPURenderer: THREE.TextureNode.biasNode does not support ${n} shader.`
          );
        }
        getPropertyName(e, t = this.shaderStage) {
          if (!0 === e.isNodeVarying && !0 === e.needsInterpolation) {
            if ("vertex" === t) return `varyings.${e.name}`;
          } else if (!0 === e.isNodeUniform) {
            let t = e.name,
              r = e.type;
            return "texture" === r ||
              "cubeTexture" === r ||
              "storageTexture" === r ||
              "texture3D" === r
              ? t
              : "buffer" !== r &&
                "storageBuffer" !== r &&
                "indirectStorageBuffer" !== r
              ? e.groupNode.name + "." + t
              : this.isCustomStruct(e)
              ? t
              : t + ".value";
          }
          return super.getPropertyName(e);
        }
        getOutputStructName() {
          return "output";
        }
        getFunctionOperator(e) {
          let t = fF[e];
          return void 0 !== t ? (this._include(t), t) : null;
        }
        getNodeAccess(e, t) {
          return "compute" !== t ? F.READ_ONLY : e.access;
        }
        getStorageAccess(e, t) {
          return fE[this.getNodeAccess(e, t)];
        }
        getUniformFromNode(e, t, r, i = null) {
          let s = super.getUniformFromNode(e, t, r, i),
            n = this.getDataFromNode(e, r, this.globalCache);
          if (void 0 === n.uniformGPU) {
            let a,
              o = e.groupNode,
              l = o.name,
              u = this.getBindGroupArray(l, r);
            if (
              "texture" === t ||
              "cubeTexture" === t ||
              "storageTexture" === t ||
              "texture3D" === t
            ) {
              let i = null,
                n = this.getNodeAccess(e, r);
              if (
                ("texture" === t || "storageTexture" === t
                  ? (i = new mR(s.name, s.node, o, n))
                  : "cubeTexture" === t
                  ? (i = new mA(s.name, s.node, o, n))
                  : "texture3D" === t && (i = new mC(s.name, s.node, o, n)),
                (i.store = !0 === e.isStorageTextureNode),
                i.setVisibility(fM[r]),
                ("fragment" === r || "compute" === r) &&
                  !1 === this.isUnfilterable(e.value) &&
                  !1 === i.store)
              ) {
                let e = new fc(`${s.name}_sampler`, s.node, o);
                e.setVisibility(fM[r]), u.push(e, i), (a = [e, i]);
              } else u.push(i), (a = [i]);
            } else if (
              "buffer" === t ||
              "storageBuffer" === t ||
              "indirectStorageBuffer" === t
            ) {
              let n = new ("buffer" === t ? mb : fm)(e, o);
              n.setVisibility(fM[r]),
                u.push(n),
                (a = n),
                (s.name = i || "NodeBuffer_" + s.id);
            } else {
              let e = this.uniformGroups[r] || (this.uniformGroups[r] = {}),
                i = e[l];
              void 0 === i &&
                ((i = new mv(l, o)).setVisibility(fM[r]),
                (e[l] = i),
                u.push(i)),
                (a = this.getNodeUniform(s, t)),
                i.addUniform(a);
            }
            n.uniformGPU = a;
          }
          return s;
        }
        getBuiltin(e, t, r, i = this.shaderStage) {
          let s = this.builtins[i] || (this.builtins[i] = new Map());
          return (
            !1 === s.has(e) && s.set(e, { name: e, property: t, type: r }), t
          );
        }
        hasBuiltin(e, t = this.shaderStage) {
          return void 0 !== this.builtins[t] && this.builtins[t].has(e);
        }
        getVertexIndex() {
          return "vertex" === this.shaderStage
            ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute")
            : "vertexIndex";
        }
        buildFunctionCode(e) {
          let t = e.layout,
            r = this.flowShaderNode(e),
            i = [];
          for (let e of t.inputs) i.push(e.name + " : " + this.getType(e.type));
          let s = `fn ${t.name}( ${i.join(", ")} ) -> ${this.getType(t.type)} {
${r.vars}
${r.code}
`;
          return (
            r.result &&
              (s += `	return ${r.result};
`),
            (s += "\n}\n")
          );
        }
        getInstanceIndex() {
          return "vertex" === this.shaderStage
            ? this.getBuiltin(
                "instance_index",
                "instanceIndex",
                "u32",
                "attribute"
              )
            : "instanceIndex";
        }
        getInvocationLocalIndex() {
          return this.getBuiltin(
            "local_invocation_index",
            "invocationLocalIndex",
            "u32",
            "attribute"
          );
        }
        getSubgroupSize() {
          return (
            this.enableSubGroups(),
            this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute")
          );
        }
        getInvocationSubgroupIndex() {
          return (
            this.enableSubGroups(),
            this.getBuiltin(
              "subgroup_invocation_id",
              "invocationSubgroupIndex",
              "u32",
              "attribute"
            )
          );
        }
        getSubgroupIndex() {
          return (
            this.enableSubGroups(),
            this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute")
          );
        }
        getDrawIndex() {
          return null;
        }
        getFrontFacing() {
          return this.getBuiltin("front_facing", "isFront", "bool");
        }
        getFragCoord() {
          return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
        }
        getFragDepth() {
          return (
            "output." + this.getBuiltin("frag_depth", "depth", "f32", "output")
          );
        }
        getClipDistance() {
          return "varyings.hw_clip_distances";
        }
        isFlipY() {
          return !1;
        }
        enableDirective(e, t = this.shaderStage) {
          (this.directives[t] || (this.directives[t] = new Set())).add(e);
        }
        getDirectives(e) {
          let t = [],
            r = this.directives[e];
          if (void 0 !== r) for (let e of r) t.push(`enable ${e};`);
          return t.join("\n");
        }
        enableSubGroups() {
          this.enableDirective("subgroups");
        }
        enableSubgroupsF16() {
          this.enableDirective("subgroups-f16");
        }
        enableClipDistances() {
          this.enableDirective("clip_distances");
        }
        enableShaderF16() {
          this.enableDirective("f16");
        }
        enableDualSourceBlending() {
          this.enableDirective("dual_source_blending");
        }
        enableHardwareClipping(e) {
          this.enableClipDistances(),
            this.getBuiltin(
              "clip_distances",
              "hw_clip_distances",
              `array<f32, ${e} >`,
              "vertex"
            );
        }
        getBuiltins(e) {
          let t = [],
            r = this.builtins[e];
          if (void 0 !== r)
            for (let { name: e, property: i, type: s } of r.values())
              t.push(`@builtin( ${e} ) ${i} : ${s}`);
          return t.join(",\n	");
        }
        getScopedArray(e, t, r, i) {
          return (
            !1 === this.scopedArrays.has(e) &&
              this.scopedArrays.set(e, {
                name: e,
                scope: t,
                bufferType: r,
                bufferCount: i,
              }),
            e
          );
        }
        getScopedArrays(e) {
          if ("compute" !== e) return;
          let t = [];
          for (let {
            name: e,
            scope: r,
            bufferType: i,
            bufferCount: s,
          } of this.scopedArrays.values()) {
            let n = this.getType(i);
            t.push(`var<${r}> ${e}: array< ${n}, ${s} >;`);
          }
          return t.join("\n");
        }
        getAttributes(e) {
          let t = [];
          if (
            ("compute" === e &&
              (this.getBuiltin(
                "global_invocation_id",
                "globalId",
                "vec3<u32>",
                "attribute"
              ),
              this.getBuiltin(
                "workgroup_id",
                "workgroupId",
                "vec3<u32>",
                "attribute"
              ),
              this.getBuiltin(
                "local_invocation_id",
                "localId",
                "vec3<u32>",
                "attribute"
              ),
              this.getBuiltin(
                "num_workgroups",
                "numWorkgroups",
                "vec3<u32>",
                "attribute"
              ),
              this.renderer.hasFeature("subgroups") &&
                (this.enableDirective("subgroups", e),
                this.getBuiltin(
                  "subgroup_size",
                  "subgroupSize",
                  "u32",
                  "attribute"
                ))),
            "vertex" === e || "compute" === e)
          ) {
            let e = this.getBuiltins("attribute");
            e && t.push(e);
            let r = this.getAttributesArray();
            for (let e = 0, i = r.length; e < i; e++) {
              let i = r[e],
                s = i.name,
                n = this.getType(i.type);
              t.push(`@location( ${e} ) ${s} : ${n}`);
            }
          }
          return t.join(",\n	");
        }
        getStructMembers(e) {
          let t = [];
          for (let r of e.members) {
            let i = e.output ? "@location( " + r.index + " ) " : "",
              s = this.getType(r.type);
            r.atomic && (s = "atomic< " + s + " >"),
              t.push(`	${i + r.name} : ${s}`);
          }
          return (
            e.output && t.push(`	${this.getBuiltins("output")}`), t.join(",\n")
          );
        }
        getStructs(e) {
          let t = "",
            r = this.structs[e];
          if (r.length > 0) {
            let e = [];
            for (let t of r) {
              let r = `struct ${t.name} {
`;
              (r += this.getStructMembers(t)), (r += "\n};"), e.push(r);
            }
            t = "\n" + e.join("\n\n") + "\n";
          }
          return t;
        }
        getVar(e, t, r = null) {
          let i = `var ${t} : `;
          return (
            null !== r
              ? (i += this.generateArrayDeclaration(e, r))
              : (i += this.getType(e)),
            i
          );
        }
        getVars(e) {
          let t = [],
            r = this.vars[e];
          if (void 0 !== r)
            for (let e of r) t.push(`	${this.getVar(e.type, e.name, e.count)};`);
          return `
${t.join("\n")}
`;
        }
        getVaryings(e) {
          let t = [];
          if (
            ("vertex" === e &&
              this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"),
            "vertex" === e || "fragment" === e)
          ) {
            let r = this.varyings,
              i = this.vars[e];
            for (let s = 0; s < r.length; s++) {
              let n = r[s];
              if (n.needsInterpolation) {
                let e = `@location( ${s} )`;
                /^(int|uint|ivec|uvec)/.test(n.type) &&
                  (e += " @interpolate( flat )"),
                  t.push(`${e} ${n.name} : ${this.getType(n.type)}`);
              } else "vertex" === e && !1 === i.includes(n) && i.push(n);
            }
          }
          let r = this.getBuiltins(e);
          r && t.push(r);
          let i = t.join(",\n	");
          return "vertex" === e
            ? this._getWGSLStruct("VaryingsStruct", "	" + i)
            : i;
        }
        isCustomStruct(e) {
          return (
            e.value.isStorageBufferAttribute && null !== e.node.structTypeNode
          );
        }
        getUniforms(e) {
          let t = this.uniforms[e],
            r = [],
            i = [],
            s = [],
            n = {};
          for (let s of t) {
            let t = s.groupNode.name,
              a = this.bindingsIndexes[t];
            if (
              "texture" === s.type ||
              "cubeTexture" === s.type ||
              "storageTexture" === s.type ||
              "texture3D" === s.type
            ) {
              let t,
                i = s.node.value;
              ("fragment" === e || "compute" === e) &&
                !1 === this.isUnfilterable(i) &&
                !0 !== s.node.isStorageTextureNode &&
                (this.isSampleCompare(i)
                  ? r.push(
                      `@binding( ${a.binding++} ) @group( ${a.group} ) var ${
                        s.name
                      }_sampler : sampler_comparison;`
                    )
                  : r.push(
                      `@binding( ${a.binding++} ) @group( ${a.group} ) var ${
                        s.name
                      }_sampler : sampler;`
                    ));
              let n = "",
                { primarySamples: o } =
                  this.renderer.backend.utils.getTextureSampleData(i);
              if ((o > 1 && (n = "_multisampled"), !0 === i.isCubeTexture))
                t = "texture_cube<f32>";
              else if (
                !0 === i.isDataArrayTexture ||
                !0 === i.isCompressedArrayTexture
              )
                t = "texture_2d_array<f32>";
              else if (!0 === i.isDepthTexture) t = `texture_depth${n}_2d`;
              else if (!0 === i.isVideoTexture) t = "texture_external";
              else if (!0 === i.isData3DTexture) t = "texture_3d<f32>";
              else if (!0 === s.node.isStorageTextureNode) {
                let r = fT(i),
                  n = this.getStorageAccess(s.node, e);
                t = `texture_storage_2d<${r}, ${n}>`;
              } else {
                let e = this.getComponentTypeFromTexture(i).charAt(0);
                t = `texture${n}_2d<${e}32>`;
              }
              r.push(
                `@binding( ${a.binding++} ) @group( ${a.group} ) var ${
                  s.name
                } : ${t};`
              );
            } else if (
              "buffer" === s.type ||
              "storageBuffer" === s.type ||
              "indirectStorageBuffer" === s.type
            ) {
              let t = s.node,
                r = this.getType(t.getNodeType(this)),
                n = t.bufferCount,
                o = n > 0 && "buffer" === s.type ? ", " + n : "",
                l = t.isStorageBufferNode
                  ? `storage, ${this.getStorageAccess(t, e)}`
                  : "uniform";
              if (this.isCustomStruct(s))
                i.push(
                  `@binding( ${a.binding++} ) @group( ${a.group} ) var<${l}> ${
                    s.name
                  } : ${r};`
                );
              else {
                let e = t.isAtomic ? `atomic<${r}>` : `${r}`,
                  n = `	value : array< ${e}${o} >`;
                i.push(
                  this._getWGSLStructBinding(s.name, n, l, a.binding++, a.group)
                );
              }
            } else {
              let e = this.getType(this.getVectorType(s.type)),
                t = s.groupNode.name;
              (
                n[t] ||
                (n[t] = { index: a.binding++, id: a.group, snippets: [] })
              ).snippets.push(`	${s.name} : ${e}`);
            }
          }
          for (let e in n) {
            let t = n[e];
            s.push(
              this._getWGSLStructBinding(
                e,
                t.snippets.join(",\n"),
                "uniform",
                t.index,
                t.id
              )
            );
          }
          let a = r.join("\n");
          return (a += i.join("\n")), (a += s.join("\n"));
        }
        buildCode() {
          let e =
            null !== this.material
              ? { fragment: {}, vertex: {} }
              : { compute: {} };
          for (let t in (this.sortBindingGroups(), e)) {
            this.shaderStage = t;
            let r = e[t];
            (r.uniforms = this.getUniforms(t)),
              (r.attributes = this.getAttributes(t)),
              (r.varyings = this.getVaryings(t)),
              (r.structs = this.getStructs(t)),
              (r.vars = this.getVars(t)),
              (r.codes = this.getCodes(t)),
              (r.directives = this.getDirectives(t)),
              (r.scopedArrays = this.getScopedArrays(t));
            let i = "// code\n\n";
            i += this.flowCode[t];
            let s = this.flowNodes[t],
              n = s[s.length - 1],
              a = n.outputNode,
              o = void 0 !== a && !0 === a.isOutputStructNode;
            for (let e of s) {
              let s = this.getFlowData(e),
                l = e.name;
              if (
                (l &&
                  (i.length > 0 && (i += "\n"),
                  (i += `	// flow -> ${l}
`)),
                (i += `${s.code}
	`),
                e === n && "compute" !== t)
              ) {
                if (((i += "// result\n\n	"), "vertex" === t))
                  i += `varyings.Vertex = ${s.result};`;
                else if ("fragment" === t)
                  if (o)
                    (r.returnType = a.getNodeType(this)),
                      (r.structs +=
                        "var<private> output : " + r.returnType + ";"),
                      (i += `return ${s.result};`);
                  else {
                    let e = "	@location(0) color: vec4<f32>",
                      t = this.getBuiltins("output");
                    t && (e += ",\n	" + t),
                      (r.returnType = "OutputStruct"),
                      (r.structs += this._getWGSLStruct("OutputStruct", e)),
                      (r.structs += "\nvar<private> output : OutputStruct;"),
                      (i += `output.color = ${s.result};

	return output;`);
                  }
              }
            }
            r.flow = i;
          }
          (this.shaderStage = null),
            null !== this.material
              ? ((this.vertexShader = this._getWGSLVertexCode(e.vertex)),
                (this.fragmentShader = this._getWGSLFragmentCode(e.fragment)))
              : (this.computeShader = this._getWGSLComputeCode(
                  e.compute,
                  (this.object.workgroupSize || [64]).join(", ")
                ));
        }
        getMethod(e, t = null) {
          let r;
          return (
            null !== t && (r = this._getWGSLMethod(e + "_" + t)),
            void 0 === r && (r = this._getWGSLMethod(e)),
            r || e
          );
        }
        getType(e) {
          return fU[e] || e;
        }
        isAvailable(e) {
          let t = fB[e];
          return (
            void 0 === t &&
              ("float32Filterable" === e
                ? (t = this.renderer.hasFeature("float32-filterable"))
                : "clipDistance" === e &&
                  (t = this.renderer.hasFeature("clip-distances")),
              (fB[e] = t)),
            t
          );
        }
        _getWGSLMethod(e) {
          return void 0 !== fP[e] && this._include(e), fL[e];
        }
        _include(e) {
          let t = fP[e];
          return (
            t.build(this),
            null !== this.currentFunctionNode &&
              this.currentFunctionNode.includes.push(t),
            t
          );
        }
        _getWGSLVertexCode(e) {
          return `${this.getSignature()}
// directives
${e.directives}

// structs
${e.structs}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
        }
        _getWGSLFragmentCode(e) {
          return `${this.getSignature()}
// global
${fD}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        _getWGSLComputeCode(e, t) {
          return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${t} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${t}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${t});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        _getWGSLStruct(e, t) {
          return `
struct ${e} {
${t}
};`;
        }
        _getWGSLStructBinding(e, t, r, i = 0, s = 0) {
          let n = e + "Struct",
            a = this._getWGSLStruct(n, t);
          return `${a}
@binding( ${i} ) @group( ${s} )
var<${r}> ${e} : ${n};`;
        }
      }
      class fO {
        constructor(e) {
          this.backend = e;
        }
        getCurrentDepthStencilFormat(e) {
          let t;
          return (
            null !== e.depthTexture
              ? (t = this.getTextureFormatGPU(e.depthTexture))
              : e.depth && e.stencil
              ? (t = m5.Depth24PlusStencil8)
              : e.depth && (t = m5.Depth24Plus),
            t
          );
        }
        getTextureFormatGPU(e) {
          return this.backend.get(e).format;
        }
        getTextureSampleData(e) {
          let t;
          if (e.isFramebufferTexture) t = 1;
          else if (e.isDepthTexture && !e.renderTarget) {
            let e = this.backend.renderer,
              r = e.getRenderTarget();
            t = r ? r.samples : e.samples;
          } else e.renderTarget && (t = e.renderTarget.samples);
          let r =
              (t = t || 1) > 1 &&
              null !== e.renderTarget &&
              !0 !== e.isDepthTexture &&
              !0 !== e.isFramebufferTexture,
            i = r ? 1 : t;
          return { samples: t, primarySamples: i, isMSAA: r };
        }
        getCurrentColorFormat(e) {
          let t;
          return null !== e.textures
            ? this.getTextureFormatGPU(e.textures[0])
            : this.getPreferredCanvasFormat();
        }
        getCurrentColorSpace(e) {
          return null !== e.textures
            ? e.textures[0].colorSpace
            : this.backend.renderer.outputColorSpace;
        }
        getPrimitiveTopology(e, t) {
          return e.isPoints
            ? mJ.PointList
            : e.isLineSegments || (e.isMesh && !0 === t.wireframe)
            ? mJ.LineList
            : e.isLine
            ? mJ.LineStrip
            : e.isMesh
            ? mJ.TriangleList
            : void 0;
        }
        getSampleCount(e) {
          let t = 1;
          return (
            e > 1 &&
              2 === (t = Math.pow(2, Math.floor(Math.log2(e)))) &&
              (t = 4),
            t
          );
        }
        getSampleCountRenderContext(e) {
          return null !== e.textures
            ? this.getSampleCount(e.sampleCount)
            : this.getSampleCount(this.backend.renderer.samples);
        }
        getPreferredCanvasFormat() {
          let e = this.backend.parameters.outputType;
          if (void 0 === e) return navigator.gpu.getPreferredCanvasFormat();
          if (e === u.OUM) return m5.BGRA8Unorm;
          if (e === u.ix0) return m5.RGBA16Float;
          throw Error("Unsupported outputType");
        }
      }
      let fG = new Map([
          [Int8Array, ["sint8", "snorm8"]],
          [Uint8Array, ["uint8", "unorm8"]],
          [Int16Array, ["sint16", "snorm16"]],
          [Uint16Array, ["uint16", "unorm16"]],
          [Int32Array, ["sint32", "snorm32"]],
          [Uint32Array, ["uint32", "unorm32"]],
          [Float32Array, ["float32"]],
        ]),
        fk = new Map([[u.Oax, ["float16"]]]),
        fz = new Map([
          [Int32Array, "sint32"],
          [Int16Array, "sint32"],
          [Uint32Array, "uint32"],
          [Uint16Array, "uint32"],
          [Float32Array, "float32"],
        ]);
      class f$ {
        constructor(e) {
          this.backend = e;
        }
        createAttribute(e, t) {
          let r = this._getBufferAttribute(e),
            i = this.backend,
            s = i.get(r),
            n = s.buffer;
          if (void 0 === n) {
            let a = i.device,
              o = r.array;
            if (!1 === e.normalized) {
              if (o.constructor === Int16Array) o = new Int32Array(o);
              else if (
                o.constructor === Uint16Array &&
                ((o = new Uint32Array(o)), t & GPUBufferUsage.INDEX)
              )
                for (let e = 0; e < o.length; e++)
                  65535 === o[e] && (o[e] = 0xffffffff);
            }
            if (
              ((r.array = o),
              (r.isStorageBufferAttribute ||
                r.isStorageInstancedBufferAttribute) &&
                3 === r.itemSize)
            ) {
              o = new o.constructor(4 * r.count);
              for (let e = 0; e < r.count; e++)
                o.set(r.array.subarray(3 * e, 3 * e + 3), 4 * e);
              (r.itemSize = 4),
                (r.array = o),
                (s._force3to4BytesAlignment = !0);
            }
            let l = o.byteLength + ((4 - (o.byteLength % 4)) % 4);
            (n = a.createBuffer({
              label: r.name,
              size: l,
              usage: t,
              mappedAtCreation: !0,
            })),
              new o.constructor(n.getMappedRange()).set(o),
              n.unmap(),
              (s.buffer = n);
          }
        }
        updateAttribute(e) {
          let t = this._getBufferAttribute(e),
            r = this.backend,
            i = r.device,
            s = r.get(t),
            n = r.get(t).buffer,
            a = t.array;
          if (!0 === s._force3to4BytesAlignment) {
            a = new a.constructor(4 * t.count);
            for (let e = 0; e < t.count; e++)
              a.set(t.array.subarray(3 * e, 3 * e + 3), 4 * e);
            t.array = a;
          }
          let o = this._isTypedArray(a),
            l = t.updateRanges;
          if (0 === l.length) i.queue.writeBuffer(n, 0, a, 0);
          else {
            let e = o ? 1 : a.BYTES_PER_ELEMENT;
            for (let t = 0, r = l.length; t < r; t++) {
              let r,
                o,
                u = l[t];
              if (!0 === s._force3to4BytesAlignment) {
                let t = Math.floor(u.start / 3),
                  i = Math.ceil(u.count / 3);
                (r = 4 * t * e), (o = 4 * i * e);
              } else (r = u.start * e), (o = u.count * e);
              i.queue.writeBuffer(n, 0, a, r, o);
            }
            t.clearUpdateRanges();
          }
        }
        createShaderVertexBuffers(e) {
          let t = e.getAttributes(),
            r = new Map();
          for (let e = 0; e < t.length; e++) {
            let i = t[e],
              s = i.array.BYTES_PER_ELEMENT,
              n = this._getBufferAttribute(i),
              a = r.get(n);
            if (void 0 === a) {
              let e, t;
              !0 === i.isInterleavedBufferAttribute
                ? ((e = i.data.stride * s),
                  (t = i.data.isInstancedInterleavedBuffer
                    ? fu.Instance
                    : fu.Vertex))
                : ((e = i.itemSize * s),
                  (t = i.isInstancedBufferAttribute ? fu.Instance : fu.Vertex)),
                !1 === i.normalized &&
                  (i.array.constructor === Int16Array ||
                    i.array.constructor === Uint16Array) &&
                  (e = 4),
                (a = { arrayStride: e, attributes: [], stepMode: t }),
                r.set(n, a);
            }
            let o = this._getVertexFormat(i),
              l = !0 === i.isInterleavedBufferAttribute ? i.offset * s : 0;
            a.attributes.push({ shaderLocation: e, offset: l, format: o });
          }
          return Array.from(r.values());
        }
        destroyAttribute(e) {
          let t = this.backend;
          t.get(this._getBufferAttribute(e)).buffer.destroy(), t.delete(e);
        }
        async getArrayBufferAsync(e) {
          let t = this.backend,
            r = t.device,
            i = t.get(this._getBufferAttribute(e)).buffer,
            s = i.size,
            n = r.createBuffer({
              label: `${e.name}_readback`,
              size: s,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            }),
            a = r.createCommandEncoder({ label: `readback_encoder_${e.name}` });
          a.copyBufferToBuffer(i, 0, n, 0, s);
          let o = a.finish();
          r.queue.submit([o]), await n.mapAsync(GPUMapMode.READ);
          let l = n.getMappedRange(),
            u = new e.array.constructor(l.slice(0));
          return n.unmap(), u.buffer;
        }
        _getVertexFormat(e) {
          let t,
            { itemSize: r, normalized: i } = e,
            s = e.array.constructor,
            n = e.constructor;
          if (1 === r) t = fz.get(s);
          else {
            let e = (fk.get(n) || fG.get(s))[+!!i];
            if (e) {
              let i =
                (4 * Math.floor((s.BYTES_PER_ELEMENT * r + 3) / 4)) /
                s.BYTES_PER_ELEMENT;
              if (i % 1)
                throw Error(
                  "THREE.WebGPUAttributeUtils: Bad vertex format item size."
                );
              t = `${e}x${i}`;
            }
          }
          return (
            t ||
              console.error(
                "THREE.WebGPUAttributeUtils: Vertex format not supported yet."
              ),
            t
          );
        }
        _isTypedArray(e) {
          return ArrayBuffer.isView(e) && !(e instanceof DataView);
        }
        _getBufferAttribute(e) {
          return e.isInterleavedBufferAttribute && (e = e.data), e;
        }
      }
      class fW {
        constructor(e) {
          (this.backend = e), (this.bindGroupLayoutCache = new WeakMap());
        }
        createBindingsLayout(e) {
          let t = this.backend,
            r = t.device,
            i = [],
            s = 0;
          for (let r of e.bindings) {
            let e = { binding: s++, visibility: r.visibility };
            if (r.isUniformBuffer || r.isStorageBuffer) {
              let t = {};
              r.isStorageBuffer &&
                (4 & r.visibility &&
                (r.access === F.READ_WRITE || r.access === F.WRITE_ONLY)
                  ? (t.type = fi.Storage)
                  : (t.type = fi.ReadOnlyStorage)),
                (e.buffer = t);
            } else if (r.isSampler) {
              let t = {};
              r.texture.isDepthTexture &&
                null !== r.texture.compareFunction &&
                (t.type = "comparison"),
                (e.sampler = t);
            } else if (r.isSampledTexture && r.texture.isVideoTexture)
              e.externalTexture = {};
            else if (r.isSampledTexture && r.store) {
              let t = {};
              t.format = this.backend.get(r.texture).texture.format;
              let i = r.access;
              i === F.READ_WRITE
                ? (t.access = fs.ReadWrite)
                : i === F.WRITE_ONLY
                ? (t.access = fs.WriteOnly)
                : (t.access = fs.ReadOnly),
                (e.storageTexture = t);
            } else if (r.isSampledTexture) {
              let i = {},
                { primarySamples: s } = t.utils.getTextureSampleData(r.texture);
              if (
                (s > 1 &&
                  ((i.multisampled = !0),
                  r.texture.isDepthTexture ||
                    (i.sampleType = fn.UnfilterableFloat)),
                r.texture.isDepthTexture)
              )
                i.sampleType = fn.Depth;
              else if (
                r.texture.isDataTexture ||
                r.texture.isDataArrayTexture ||
                r.texture.isData3DTexture
              ) {
                let e = r.texture.type;
                e === u.Yuy
                  ? (i.sampleType = fn.SInt)
                  : e === u.bkx
                  ? (i.sampleType = fn.UInt)
                  : e === u.RQf &&
                    (this.backend.hasFeature("float32-filterable")
                      ? (i.sampleType = fn.Float)
                      : (i.sampleType = fn.UnfilterableFloat));
              }
              r.isSampledCubeTexture
                ? (i.viewDimension = fo.Cube)
                : r.texture.isDataArrayTexture ||
                  r.texture.isCompressedArrayTexture
                ? (i.viewDimension = fo.TwoDArray)
                : r.isSampledTexture3D && (i.viewDimension = fo.ThreeD),
                (e.texture = i);
            } else
              console.error(`WebGPUBindingUtils: Unsupported binding "${r}".`);
            i.push(e);
          }
          return r.createBindGroupLayout({ entries: i });
        }
        createBindings(e, t, r, i = 0) {
          let s,
            { backend: n, bindGroupLayoutCache: a } = this,
            o = n.get(e),
            l = a.get(e.bindingsReference);
          void 0 === l &&
            ((l = this.createBindingsLayout(e)), a.set(e.bindingsReference, l)),
            r > 0 &&
              (void 0 === o.groups && ((o.groups = []), (o.versions = [])),
              o.versions[r] === i && (s = o.groups[r])),
            void 0 === s &&
              ((s = this.createBindGroup(e, l)),
              r > 0 && ((o.groups[r] = s), (o.versions[r] = i))),
            (o.group = s),
            (o.layout = l);
        }
        updateBinding(e) {
          let t = this.backend,
            r = t.device,
            i = e.buffer,
            s = t.get(e).buffer;
          r.queue.writeBuffer(s, 0, i, 0);
        }
        createBindGroupIndex(e, t) {
          let r = this.backend.device,
            i = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            s = e[0],
            n = r.createBuffer({
              label: "bindingCameraIndex_" + s,
              size: 16,
              usage: i,
            });
          r.queue.writeBuffer(n, 0, e, 0);
          let a = [{ binding: 0, resource: { buffer: n } }];
          return r.createBindGroup({
            label: "bindGroupCameraIndex_" + s,
            layout: t,
            entries: a,
          });
        }
        createBindGroup(e, t) {
          let r = this.backend,
            i = r.device,
            s = 0,
            n = [];
          for (let t of e.bindings) {
            if (t.isUniformBuffer) {
              let e = r.get(t);
              if (void 0 === e.buffer) {
                let r = t.byteLength,
                  s = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
                e.buffer = i.createBuffer({
                  label: "bindingBuffer_" + t.name,
                  size: r,
                  usage: s,
                });
              }
              n.push({ binding: s, resource: { buffer: e.buffer } });
            } else if (t.isStorageBuffer) {
              let e = r.get(t);
              if (void 0 === e.buffer) {
                let i = t.attribute;
                e.buffer = r.get(i).buffer;
              }
              n.push({ binding: s, resource: { buffer: e.buffer } });
            } else if (t.isSampler) {
              let e = r.get(t.texture);
              n.push({ binding: s, resource: e.sampler });
            } else if (t.isSampledTexture) {
              let e,
                a = r.get(t.texture);
              if (void 0 !== a.externalTexture)
                e = i.importExternalTexture({ source: a.externalTexture });
              else {
                let r = t.store ? 1 : a.texture.mipLevelCount,
                  i = `view-${a.texture.width}-${a.texture.height}-${r}`;
                if (void 0 === (e = a[i])) {
                  let s,
                    n = fl.All;
                  (s = t.isSampledCubeTexture
                    ? fo.Cube
                    : t.isSampledTexture3D
                    ? fo.ThreeD
                    : t.texture.isDataArrayTexture ||
                      t.texture.isCompressedArrayTexture
                    ? fo.TwoDArray
                    : fo.TwoD),
                    (e = a[i] =
                      a.texture.createView({
                        aspect: n,
                        dimension: s,
                        mipLevelCount: r,
                      }));
                }
              }
              n.push({ binding: s, resource: e });
            }
            s++;
          }
          return i.createBindGroup({
            label: "bindGroup_" + e.name,
            layout: t,
            entries: n,
          });
        }
      }
      class fH {
        constructor(e) {
          this.backend = e;
        }
        _getSampleCount(e) {
          return this.backend.utils.getSampleCountRenderContext(e);
        }
        createRenderPipeline(e, t) {
          let r,
            { object: i, material: s, geometry: n, pipeline: a } = e,
            { vertexProgram: o, fragmentProgram: l } = a,
            d = this.backend,
            h = d.device,
            c = d.utils,
            p = d.get(a),
            g = [];
          for (let t of e.getBindings()) {
            let e = d.get(t);
            g.push(e.layout);
          }
          let m = d.attributeUtils.createShaderVertexBuffers(e);
          !0 === s.transparent &&
            s.blending !== u.XIg &&
            (r = this._getBlending(s));
          let f = {};
          !0 === s.stencilWrite &&
            (f = {
              compare: this._getStencilCompare(s),
              failOp: this._getStencilOperation(s.stencilFail),
              depthFailOp: this._getStencilOperation(s.stencilZFail),
              passOp: this._getStencilOperation(s.stencilZPass),
            });
          let y = this._getColorWriteMask(s),
            x = [];
          if (null !== e.context.textures) {
            let t = e.context.textures;
            for (let e = 0; e < t.length; e++) {
              let i = c.getTextureFormatGPU(t[e]);
              x.push({ format: i, blend: r, writeMask: y });
            }
          } else {
            let t = c.getCurrentColorFormat(e.context);
            x.push({ format: t, blend: r, writeMask: y });
          }
          let b = d.get(o).module,
            T = d.get(l).module,
            _ = this._getPrimitiveState(i, n, s),
            v = this._getDepthCompare(s),
            N = c.getCurrentDepthStencilFormat(e.context),
            S = this._getSampleCount(e.context),
            R = {
              label: `renderPipeline_${s.name || s.type}_${s.id}`,
              vertex: Object.assign({}, b, { buffers: m }),
              fragment: Object.assign({}, T, { targets: x }),
              primitive: _,
              multisample: {
                count: S,
                alphaToCoverageEnabled: s.alphaToCoverage && S > 1,
              },
              layout: h.createPipelineLayout({ bindGroupLayouts: g }),
            },
            A = {},
            C = e.context.depth,
            E = e.context.stencil;
          if (
            ((!0 === C || !0 === E) &&
              (!0 === C &&
                ((A.format = N),
                (A.depthWriteEnabled = s.depthWrite),
                (A.depthCompare = v)),
              !0 === E &&
                ((A.stencilFront = f),
                (A.stencilBack = {}),
                (A.stencilReadMask = s.stencilFuncMask),
                (A.stencilWriteMask = s.stencilWriteMask)),
              !0 === s.polygonOffset &&
                ((A.depthBias = s.polygonOffsetUnits),
                (A.depthBiasSlopeScale = s.polygonOffsetFactor),
                (A.depthBiasClamp = 0)),
              (R.depthStencil = A)),
            null === t)
          )
            p.pipeline = h.createRenderPipeline(R);
          else {
            let e = new Promise((e) => {
              h.createRenderPipelineAsync(R).then((t) => {
                (p.pipeline = t), e();
              });
            });
            t.push(e);
          }
        }
        createBundleEncoder(e) {
          let { utils: t, device: r } = this.backend,
            i = t.getCurrentDepthStencilFormat(e),
            s = t.getCurrentColorFormat(e),
            n = this._getSampleCount(e);
          return r.createRenderBundleEncoder({
            label: "renderBundleEncoder",
            colorFormats: [s],
            depthStencilFormat: i,
            sampleCount: n,
          });
        }
        createComputePipeline(e, t) {
          let r = this.backend,
            i = r.device,
            s = r.get(e.computeProgram).module,
            n = r.get(e),
            a = [];
          for (let e of t) {
            let t = r.get(e);
            a.push(t.layout);
          }
          n.pipeline = i.createComputePipeline({
            compute: s,
            layout: i.createPipelineLayout({ bindGroupLayouts: a }),
          });
        }
        _getBlending(e) {
          let t,
            r,
            i = e.blending,
            s = e.blendSrc,
            n = e.blendDst,
            a = e.blendEquation;
          if (i === u.bCz) {
            let i = null !== e.blendSrcAlpha ? e.blendSrcAlpha : s,
              o = null !== e.blendDstAlpha ? e.blendDstAlpha : n,
              l = null !== e.blendEquationAlpha ? e.blendEquationAlpha : a;
            (t = {
              srcFactor: this._getBlendFactor(s),
              dstFactor: this._getBlendFactor(n),
              operation: this._getBlendOperation(a),
            }),
              (r = {
                srcFactor: this._getBlendFactor(i),
                dstFactor: this._getBlendFactor(o),
                operation: this._getBlendOperation(l),
              });
          } else {
            let s = e.premultipliedAlpha,
              n = (e, i, s, n) => {
                (t = { srcFactor: e, dstFactor: i, operation: fe.Add }),
                  (r = { srcFactor: s, dstFactor: n, operation: fe.Add });
              };
            if (s)
              switch (i) {
                case u.NTi:
                  n(m7.One, m7.OneMinusSrcAlpha, m7.One, m7.OneMinusSrcAlpha);
                  break;
                case u.EZo:
                  n(m7.One, m7.One, m7.One, m7.One);
                  break;
                case u.Kwu:
                  n(m7.Zero, m7.OneMinusSrc, m7.Zero, m7.One);
                  break;
                case u.EdD:
                  n(m7.Zero, m7.Src, m7.Zero, m7.SrcAlpha);
              }
            else
              switch (i) {
                case u.NTi:
                  n(
                    m7.SrcAlpha,
                    m7.OneMinusSrcAlpha,
                    m7.One,
                    m7.OneMinusSrcAlpha
                  );
                  break;
                case u.EZo:
                  n(m7.SrcAlpha, m7.One, m7.SrcAlpha, m7.One);
                  break;
                case u.Kwu:
                  n(m7.Zero, m7.OneMinusSrc, m7.Zero, m7.One);
                  break;
                case u.EdD:
                  n(m7.Zero, m7.Src, m7.Zero, m7.Src);
              }
          }
          if (void 0 !== t && void 0 !== r) return { color: t, alpha: r };
          console.error("THREE.WebGPURenderer: Invalid blending: ", i);
        }
        _getBlendFactor(e) {
          let t;
          switch (e) {
            case u.ojh:
              t = m7.Zero;
              break;
            case u.qad:
              t = m7.One;
              break;
            case u.f4X:
              t = m7.Src;
              break;
            case u.LiQ:
              t = m7.OneMinusSrc;
              break;
            case u.ie2:
              t = m7.SrcAlpha;
              break;
            case u.OuU:
              t = m7.OneMinusSrcAlpha;
              break;
            case u.wn6:
              t = m7.Dst;
              break;
            case u.aEY:
              t = m7.OneMinusDstColor;
              break;
            case u.hdd:
              t = m7.DstAlpha;
              break;
            case u.Nt7:
              t = m7.OneMinusDstAlpha;
              break;
            case u.hgQ:
              t = m7.SrcAlphaSaturated;
              break;
            case 211:
              t = m7.Constant;
              break;
            case 212:
              t = m7.OneMinusConstant;
              break;
            default:
              console.error(
                "THREE.WebGPURenderer: Blend factor not supported.",
                e
              );
          }
          return t;
        }
        _getStencilCompare(e) {
          let t,
            r = e.stencilFunc;
          switch (r) {
            case u.HPb:
              t = m0.Never;
              break;
            case u.sKt:
              t = m0.Always;
              break;
            case u.kYr:
              t = m0.Less;
              break;
            case u.CR7:
              t = m0.LessEqual;
              break;
            case u.jsO:
              t = m0.Equal;
              break;
            case u.TMh:
              t = m0.GreaterEqual;
              break;
            case u.RcT:
              t = m0.Greater;
              break;
            case u.klZ:
              t = m0.NotEqual;
              break;
            default:
              console.error(
                "THREE.WebGPURenderer: Invalid stencil function.",
                r
              );
          }
          return t;
        }
        _getStencilOperation(e) {
          let t;
          switch (e) {
            case u.VVr:
              t = fr.Keep;
              break;
            case u.kqe:
              t = fr.Zero;
              break;
            case u.kG0:
              t = fr.Replace;
              break;
            case u.oVO:
              t = fr.Invert;
              break;
            case u.HLH:
              t = fr.IncrementClamp;
              break;
            case u.ROr:
              t = fr.DecrementClamp;
              break;
            case u.Ru$:
              t = fr.IncrementWrap;
              break;
            case u.fJr:
              t = fr.DecrementWrap;
              break;
            default:
              console.error(
                "THREE.WebGPURenderer: Invalid stencil operation.",
                t
              );
          }
          return t;
        }
        _getBlendOperation(e) {
          let t;
          switch (e) {
            case u.gO9:
              t = fe.Add;
              break;
            case u.FXf:
              t = fe.Subtract;
              break;
            case u.nST:
              t = fe.ReverseSubtract;
              break;
            case u.znC:
              t = fe.Min;
              break;
            case u.$ei:
              t = fe.Max;
              break;
            default:
              console.error(
                "THREE.WebGPUPipelineUtils: Blend equation not supported.",
                e
              );
          }
          return t;
        }
        _getPrimitiveState(e, t, r) {
          let i = {};
          switch (
            ((i.topology = this.backend.utils.getPrimitiveTopology(e, r)),
            null !== t.index &&
              !0 === e.isLine &&
              !0 !== e.isLineSegments &&
              (i.stripIndexFormat =
                t.index.array instanceof Uint16Array ? m6.Uint16 : m6.Uint32),
            r.side)
          ) {
            case u.hB5:
              (i.frontFace = m3.CCW), (i.cullMode = m4.Back);
              break;
            case u.hsX:
              (i.frontFace = m3.CCW), (i.cullMode = m4.Front);
              break;
            case u.$EB:
              (i.frontFace = m3.CCW), (i.cullMode = m4.None);
              break;
            default:
              console.error(
                "THREE.WebGPUPipelineUtils: Unknown material.side value.",
                r.side
              );
          }
          return i;
        }
        _getColorWriteMask(e) {
          return !0 === e.colorWrite ? ft.All : ft.None;
        }
        _getDepthCompare(e) {
          let t;
          if (!1 === e.depthTest) t = m0.Always;
          else {
            let r = e.depthFunc;
            switch (r) {
              case u.eHc:
                t = m0.Never;
                break;
              case u.lGu:
                t = m0.Always;
                break;
              case u.brA:
                t = m0.Less;
                break;
              case u.xSv:
                t = m0.LessEqual;
                break;
              case u.U3G:
                t = m0.Equal;
                break;
              case u.Gwm:
                t = m0.GreaterEqual;
                break;
              case u.K52:
                t = m0.Greater;
                break;
              case u.bw0:
                t = m0.NotEqual;
                break;
              default:
                console.error(
                  "THREE.WebGPUPipelineUtils: Invalid depth function.",
                  r
                );
            }
          }
          return t;
        }
      }
      class fq extends mK {
        constructor(e, t, r = 2048) {
          super(r),
            (this.device = e),
            (this.type = t),
            (this.querySet = this.device.createQuerySet({
              type: "timestamp",
              count: this.maxQueries,
              label: `queryset_global_timestamp_${t}`,
            }));
          let i = 8 * this.maxQueries;
          (this.resolveBuffer = this.device.createBuffer({
            label: `buffer_timestamp_resolve_${t}`,
            size: i,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
          })),
            (this.resultBuffer = this.device.createBuffer({
              label: `buffer_timestamp_result_${t}`,
              size: i,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            }));
        }
        allocateQueriesForContext(e) {
          if (!this.trackTimestamp || this.isDisposed) return null;
          if (this.currentQueryIndex + 2 > this.maxQueries)
            return (
              (0, u.mcG)(
                `WebGPUTimestampQueryPool [${
                  this.type
                }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`
              ),
              null
            );
          let t = this.currentQueryIndex;
          return (
            (this.currentQueryIndex += 2), this.queryOffsets.set(e.id, t), t
          );
        }
        async resolveQueriesAsync() {
          if (
            !this.trackTimestamp ||
            0 === this.currentQueryIndex ||
            this.isDisposed
          )
            return this.lastValue;
          if (this.pendingResolve) return this.pendingResolve;
          this.pendingResolve = this._resolveQueries();
          try {
            return await this.pendingResolve;
          } finally {
            this.pendingResolve = null;
          }
        }
        async _resolveQueries() {
          if (this.isDisposed) return this.lastValue;
          try {
            if ("unmapped" !== this.resultBuffer.mapState)
              return this.lastValue;
            let e = new Map(this.queryOffsets),
              t = this.currentQueryIndex,
              r = 8 * t;
            (this.currentQueryIndex = 0), this.queryOffsets.clear();
            let i = this.device.createCommandEncoder();
            i.resolveQuerySet(this.querySet, 0, t, this.resolveBuffer, 0),
              i.copyBufferToBuffer(
                this.resolveBuffer,
                0,
                this.resultBuffer,
                0,
                r
              );
            let s = i.finish();
            if (
              (this.device.queue.submit([s]),
              "unmapped" !== this.resultBuffer.mapState)
            )
              return this.lastValue;
            if (
              (await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, r),
              this.isDisposed)
            )
              return (
                "mapped" === this.resultBuffer.mapState &&
                  this.resultBuffer.unmap(),
                this.lastValue
              );
            let n = new BigUint64Array(this.resultBuffer.getMappedRange(0, r)),
              a = 0;
            for (let [, t] of e) {
              let e = n[t],
                r = n[t + 1],
                i = Number(r - e) / 1e6;
              a += i;
            }
            return this.resultBuffer.unmap(), (this.lastValue = a), a;
          } catch (e) {
            return (
              console.error("Error resolving queries:", e),
              "mapped" === this.resultBuffer.mapState &&
                this.resultBuffer.unmap(),
              this.lastValue
            );
          }
        }
        async dispose() {
          if (!this.isDisposed) {
            if (((this.isDisposed = !0), this.pendingResolve))
              try {
                await this.pendingResolve;
              } catch (e) {
                console.error("Error waiting for pending resolve:", e);
              }
            if (this.resultBuffer && "mapped" === this.resultBuffer.mapState)
              try {
                this.resultBuffer.unmap();
              } catch (e) {
                console.error("Error unmapping buffer:", e);
              }
            this.querySet && (this.querySet.destroy(), (this.querySet = null)),
              this.resolveBuffer &&
                (this.resolveBuffer.destroy(), (this.resolveBuffer = null)),
              this.resultBuffer &&
                (this.resultBuffer.destroy(), (this.resultBuffer = null)),
              this.queryOffsets.clear(),
              (this.pendingResolve = null);
          }
        }
      }
      class fj extends mP {
        constructor(e = {}) {
          super(e),
            (this.isWebGPUBackend = !0),
            (this.parameters.alpha = void 0 === e.alpha || e.alpha),
            (this.parameters.requiredLimits =
              void 0 === e.requiredLimits ? {} : e.requiredLimits),
            (this.trackTimestamp = !0 === e.trackTimestamp),
            (this.device = null),
            (this.context = null),
            (this.colorBuffer = null),
            (this.defaultRenderPassdescriptor = null),
            (this.utils = new fO(this)),
            (this.attributeUtils = new f$(this)),
            (this.bindingUtils = new fW(this)),
            (this.pipelineUtils = new fH(this)),
            (this.textureUtils = new fb(this)),
            (this.occludedResolveCache = new Map());
        }
        async init(e) {
          let t;
          await super.init(e);
          let r = this.parameters;
          if (void 0 === r.device) {
            let e = { powerPreference: r.powerPreference },
              i =
                "undefined" != typeof navigator
                  ? await navigator.gpu.requestAdapter(e)
                  : null;
            if (null === i)
              throw Error("WebGPUBackend: Unable to create WebGPU adapter.");
            let s = Object.values(fd),
              n = [];
            for (let e of s) i.features.has(e) && n.push(e);
            let a = { requiredFeatures: n, requiredLimits: r.requiredLimits };
            t = await i.requestDevice(a);
          } else t = r.device;
          t.lost.then((t) => {
            let r = {
              api: "WebGPU",
              message: t.message || "Unknown reason",
              reason: t.reason || null,
              originalEvent: t,
            };
            e.onDeviceLost(r);
          });
          let i =
            void 0 !== r.context
              ? r.context
              : e.domElement.getContext("webgpu");
          (this.device = t), (this.context = i);
          let s = r.alpha ? "premultiplied" : "opaque";
          (this.trackTimestamp =
            this.trackTimestamp && this.hasFeature(fd.TimestampQuery)),
            this.context.configure({
              device: this.device,
              format: this.utils.getPreferredCanvasFormat(),
              usage:
                GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
              alphaMode: s,
            }),
            this.updateSize();
        }
        get coordinateSystem() {
          return u.i7u;
        }
        async getArrayBufferAsync(e) {
          return await this.attributeUtils.getArrayBufferAsync(e);
        }
        getContext() {
          return this.context;
        }
        _getDefaultRenderPassDescriptor() {
          let e = this.defaultRenderPassdescriptor;
          if (null === e) {
            let t = this.renderer;
            (e = { colorAttachments: [{ view: null }] }),
              (!0 === this.renderer.depth || !0 === this.renderer.stencil) &&
                (e.depthStencilAttachment = {
                  view: this.textureUtils
                    .getDepthBuffer(t.depth, t.stencil)
                    .createView(),
                });
            let r = e.colorAttachments[0];
            this.renderer.samples > 0
              ? (r.view = this.colorBuffer.createView())
              : (r.resolveTarget = void 0),
              (this.defaultRenderPassdescriptor = e);
          }
          let t = e.colorAttachments[0];
          return (
            this.renderer.samples > 0
              ? (t.resolveTarget = this.context
                  .getCurrentTexture()
                  .createView())
              : (t.view = this.context.getCurrentTexture().createView()),
            e
          );
        }
        _getRenderPassDescriptor(e, t = {}) {
          let r = e.renderTarget,
            i = this.get(r),
            s = i.descriptors;
          if (
            void 0 === s ||
            i.width !== r.width ||
            i.height !== r.height ||
            i.dimensions !== r.dimensions ||
            i.activeMipmapLevel !== r.activeMipmapLevel ||
            i.activeCubeFace !== e.activeCubeFace ||
            i.samples !== r.samples ||
            i.loadOp !== t.loadOp
          ) {
            i.descriptors = s = {};
            let e = () => {
              r.removeEventListener("dispose", e), this.delete(r);
            };
            r.addEventListener("dispose", e);
          }
          let n = e.getCacheKey(),
            a = s[n];
          if (void 0 === a) {
            let o,
              l = e.textures,
              u = [];
            for (let i = 0; i < l.length; i++) {
              let s,
                n,
                a = this.get(l[i]),
                d = {
                  label: `colorAttachment_${i}`,
                  baseMipLevel: e.activeMipmapLevel,
                  mipLevelCount: 1,
                  baseArrayLayer: e.activeCubeFace,
                  arrayLayerCount: 1,
                  dimension: fo.TwoD,
                };
              r.isRenderTarget3D
                ? ((o = e.activeCubeFace),
                  (d.baseArrayLayer = 0),
                  (d.dimension = fo.ThreeD),
                  (d.depthOrArrayLayers = l[i].image.depth))
                : r.isRenderTargetArray &&
                  ((d.dimension = fo.TwoDArray),
                  (d.depthOrArrayLayers = l[i].image.depth));
              let h = a.texture.createView(d);
              void 0 !== a.msaaTexture
                ? ((s = a.msaaTexture.createView()), (n = h))
                : ((s = h), (n = void 0));
              let c = { r: 0, g: 0, b: 0, a: 1 };
              0 === i && t.clearValue && (c = t.clearValue),
                u.push({
                  view: s,
                  depthSlice: o,
                  resolveTarget: n,
                  loadOp: t.loadOP || m2.Load,
                  storeOp: t.storeOP || m1.Store,
                  clearValue: c,
                });
            }
            if (((a = { colorAttachments: u }), e.depth)) {
              let t = { view: this.get(e.depthTexture).texture.createView() };
              a.depthStencilAttachment = t;
            }
            (s[n] = a),
              (i.width = r.width),
              (i.height = r.height),
              (i.samples = r.samples),
              (i.activeMipmapLevel = e.activeMipmapLevel),
              (i.activeCubeFace = e.activeCubeFace),
              (i.dimensions = r.dimensions),
              (i.depthSlice = o),
              (i.loadOp = u[0].loadOp);
          }
          return a;
        }
        beginRender(e) {
          let t,
            r,
            i = this.get(e),
            s = this.device,
            n = e.occlusionQueryCount;
          n > 0 &&
            (i.currentOcclusionQuerySet && i.currentOcclusionQuerySet.destroy(),
            i.currentOcclusionQueryBuffer &&
              i.currentOcclusionQueryBuffer.destroy(),
            (i.currentOcclusionQuerySet = i.occlusionQuerySet),
            (i.currentOcclusionQueryBuffer = i.occlusionQueryBuffer),
            (i.currentOcclusionQueryObjects = i.occlusionQueryObjects),
            (i.occlusionQuerySet = t =
              s.createQuerySet({
                type: "occlusion",
                count: n,
                label: `occlusionQuerySet_${e.id}`,
              })),
            (i.occlusionQueryIndex = 0),
            (i.occlusionQueryObjects = Array(n)),
            (i.lastOcclusionObject = null)),
            (r =
              null === e.textures
                ? this._getDefaultRenderPassDescriptor()
                : this._getRenderPassDescriptor(e, { loadOp: m2.Load })),
            this.initTimestampQuery(e, r),
            (r.occlusionQuerySet = t);
          let a = r.depthStencilAttachment;
          if (null !== e.textures) {
            let t = r.colorAttachments;
            for (let r = 0; r < t.length; r++) {
              let i = t[r];
              e.clearColor
                ? ((i.clearValue =
                    0 === r ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }),
                  (i.loadOp = m2.Clear))
                : (i.loadOp = m2.Load),
                (i.storeOp = m1.Store);
            }
          } else {
            let t = r.colorAttachments[0];
            e.clearColor
              ? ((t.clearValue = e.clearColorValue), (t.loadOp = m2.Clear))
              : (t.loadOp = m2.Load),
              (t.storeOp = m1.Store);
          }
          e.depth &&
            (e.clearDepth
              ? ((a.depthClearValue = e.clearDepthValue),
                (a.depthLoadOp = m2.Clear))
              : (a.depthLoadOp = m2.Load),
            (a.depthStoreOp = m1.Store)),
            e.stencil &&
              (e.clearStencil
                ? ((a.stencilClearValue = e.clearStencilValue),
                  (a.stencilLoadOp = m2.Clear))
                : (a.stencilLoadOp = m2.Load),
              (a.stencilStoreOp = m1.Store));
          let o = s.createCommandEncoder({ label: "renderContext_" + e.id }),
            l = o.beginRenderPass(r);
          if (
            ((i.descriptor = r),
            (i.encoder = o),
            (i.currentPass = l),
            (i.currentSets = {
              attributes: {},
              bindingGroups: [],
              pipeline: null,
              index: null,
            }),
            (i.renderBundles = []),
            e.viewport && this.updateViewport(e),
            e.scissor)
          ) {
            let { x: t, y: r, width: i, height: s } = e.scissorValue;
            l.setScissorRect(t, r, i, s);
          }
        }
        finishRender(e) {
          let t = this.get(e),
            r = e.occlusionQueryCount;
          if (
            (t.renderBundles.length > 0 &&
              t.currentPass.executeBundles(t.renderBundles),
            r > t.occlusionQueryIndex && t.currentPass.endOcclusionQuery(),
            t.currentPass.end(),
            r > 0)
          ) {
            let i = 8 * r,
              s = this.occludedResolveCache.get(i);
            void 0 === s &&
              ((s = this.device.createBuffer({
                size: i,
                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
              })),
              this.occludedResolveCache.set(i, s));
            let n = this.device.createBuffer({
              size: i,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });
            t.encoder.resolveQuerySet(t.occlusionQuerySet, 0, r, s, 0),
              t.encoder.copyBufferToBuffer(s, 0, n, 0, i),
              (t.occlusionQueryBuffer = n),
              this.resolveOccludedAsync(e);
          }
          if (
            (this.device.queue.submit([t.encoder.finish()]),
            null !== e.textures)
          ) {
            let t = e.textures;
            for (let e = 0; e < t.length; e++) {
              let r = t[e];
              !0 === r.generateMipmaps && this.textureUtils.generateMipmaps(r);
            }
          }
        }
        isOccluded(e, t) {
          let r = this.get(e);
          return r.occluded && r.occluded.has(t);
        }
        async resolveOccludedAsync(e) {
          let t = this.get(e),
            {
              currentOcclusionQueryBuffer: r,
              currentOcclusionQueryObjects: i,
            } = t;
          if (r && i) {
            let e = new WeakSet();
            (t.currentOcclusionQueryObjects = null),
              (t.currentOcclusionQueryBuffer = null),
              await r.mapAsync(GPUMapMode.READ);
            let s = new BigUint64Array(r.getMappedRange());
            for (let t = 0; t < i.length; t++)
              s[t] === BigInt(0) && e.add(i[t]);
            r.destroy(), (t.occluded = e);
          }
        }
        updateViewport(e) {
          let { currentPass: t } = this.get(e),
            {
              x: r,
              y: i,
              width: s,
              height: n,
              minDepth: a,
              maxDepth: o,
            } = e.viewportValue;
          t.setViewport(r, i, s, n, a, o);
        }
        getClearColor() {
          let e = super.getClearColor();
          return (
            !0 === this.renderer.alpha &&
              ((e.r *= e.a), (e.g *= e.a), (e.b *= e.a)),
            e
          );
        }
        clear(e, t, r, i = null) {
          let s,
            n,
            a,
            o,
            l = this.device,
            u = this.renderer,
            d = [];
          if (e) {
            let e = this.getClearColor();
            n = { r: e.r, g: e.g, b: e.b, a: e.a };
          }
          if (null === i) {
            (a = u.depth), (o = u.stencil);
            let t = this._getDefaultRenderPassDescriptor();
            if (e) {
              let e = (d = t.colorAttachments)[0];
              (e.clearValue = n), (e.loadOp = m2.Clear), (e.storeOp = m1.Store);
            }
            (a || o) && (s = t.depthStencilAttachment);
          } else
            (a = i.depth),
              (o = i.stencil),
              e &&
                (d = this._getRenderPassDescriptor(i, {
                  loadOp: m2.Clear,
                  clearValue: n,
                }).colorAttachments),
              (a || o) &&
                (s = { view: this.get(i.depthTexture).texture.createView() });
          a &&
            (t
              ? ((s.depthLoadOp = m2.Clear),
                (s.depthClearValue = u.getClearDepth()))
              : (s.depthLoadOp = m2.Load),
            (s.depthStoreOp = m1.Store)),
            o &&
              (r
                ? ((s.stencilLoadOp = m2.Clear),
                  (s.stencilClearValue = u.getClearStencil()))
                : (s.stencilLoadOp = m2.Load),
              (s.stencilStoreOp = m1.Store));
          let h = l.createCommandEncoder({ label: "clear" });
          h
            .beginRenderPass({ colorAttachments: d, depthStencilAttachment: s })
            .end(),
            l.queue.submit([h.finish()]);
        }
        beginCompute(e) {
          let t = this.get(e),
            r = { label: "computeGroup_" + e.id };
          this.initTimestampQuery(e, r),
            (t.cmdEncoderGPU = this.device.createCommandEncoder({
              label: "computeGroup_" + e.id,
            })),
            (t.passEncoderGPU = t.cmdEncoderGPU.beginComputePass(r));
        }
        compute(e, t, r, i) {
          let { passEncoderGPU: s } = this.get(e),
            n = this.get(i).pipeline;
          s.setPipeline(n);
          for (let e = 0, t = r.length; e < t; e++) {
            let t = r[e],
              i = this.get(t);
            s.setBindGroup(e, i.group);
          }
          let a = this.device.limits.maxComputeWorkgroupsPerDimension,
            o = this.get(t);
          void 0 === o.dispatchSize && (o.dispatchSize = { x: 0, y: 1, z: 1 });
          let { dispatchSize: l } = o;
          t.dispatchCount > a
            ? ((l.x = Math.min(t.dispatchCount, a)),
              (l.y = Math.ceil(t.dispatchCount / a)))
            : (l.x = t.dispatchCount),
            s.dispatchWorkgroups(l.x, l.y, l.z);
        }
        finishCompute(e) {
          let t = this.get(e);
          t.passEncoderGPU.end(),
            this.device.queue.submit([t.cmdEncoderGPU.finish()]);
        }
        async waitForGPU() {
          await this.device.queue.onSubmittedWorkDone();
        }
        draw(e, t) {
          let { object: r, material: i, context: s, pipeline: n } = e,
            a = e.getBindings(),
            o = this.get(s),
            l = this.get(n).pipeline,
            d = o.currentSets,
            h = o.currentPass,
            c = e.getDrawParameters();
          if (null === c) return;
          d.pipeline !== l && (h.setPipeline(l), (d.pipeline = l));
          let p = d.bindingGroups;
          for (let e = 0, t = a.length; e < t; e++) {
            let t = a[e],
              r = this.get(t);
            p[t.index] !== t.id &&
              (h.setBindGroup(t.index, r.group), (p[t.index] = t.id));
          }
          let g = e.getIndex(),
            m = null !== g;
          if (!0 === m && d.index !== g) {
            let e = this.get(g).buffer,
              t = g.array instanceof Uint16Array ? m6.Uint16 : m6.Uint32;
            h.setIndexBuffer(e, t), (d.index = g);
          }
          let f = e.getVertexBuffers();
          for (let e = 0, t = f.length; e < t; e++) {
            let t = f[e];
            if (d.attributes[e] !== t) {
              let r = this.get(t).buffer;
              h.setVertexBuffer(e, r), (d.attributes[e] = t);
            }
          }
          if (void 0 !== o.occlusionQuerySet) {
            let e = o.lastOcclusionObject;
            e !== r &&
              (null !== e &&
                !0 === e.occlusionTest &&
                (h.endOcclusionQuery(), o.occlusionQueryIndex++),
              !0 === r.occlusionTest &&
                (h.beginOcclusionQuery(o.occlusionQueryIndex),
                (o.occlusionQueryObjects[o.occlusionQueryIndex] = r)),
              (o.lastOcclusionObject = r));
          }
          !0 === s.stencil &&
            !0 === i.stencilWrite &&
            o.currentStencilRef !== i.stencilRef &&
            (h.setStencilReference(i.stencilRef),
            (o.currentStencilRef = i.stencilRef));
          let y = () => {
            if (!0 === r.isBatchedMesh) {
              let e = r._multiDrawStarts,
                i = r._multiDrawCounts,
                s = r._multiDrawCount,
                n = r._multiDrawInstances;
              null !== n &&
                (0, u.mcG)(
                  "THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
                );
              for (let a = 0; a < s; a++) {
                let s = n ? n[a] : 1,
                  o = s > 1 ? 0 : a;
                !0 === m
                  ? h.drawIndexed(
                      i[a],
                      s,
                      e[a] / g.array.BYTES_PER_ELEMENT,
                      0,
                      o
                    )
                  : h.draw(i[a], s, e[a], o),
                  t.update(r, i[a], s);
              }
            } else if (!0 === m) {
              let { vertexCount: i, instanceCount: s, firstVertex: n } = c,
                a = e.getIndirect();
              if (null !== a) {
                let e = this.get(a).buffer;
                h.drawIndexedIndirect(e, 0);
              } else h.drawIndexed(i, s, n, 0, 0);
              t.update(r, i, s);
            } else {
              let { vertexCount: i, instanceCount: s, firstVertex: n } = c,
                a = e.getIndirect();
              if (null !== a) {
                let e = this.get(a).buffer;
                h.drawIndirect(e, 0);
              } else h.draw(i, s, n, 0);
              t.update(r, i, s);
            }
          };
          if (e.camera.isArrayCamera && e.camera.cameras.length > 0) {
            let t = this.get(e.camera),
              i = e.camera.cameras,
              n = e.getBindingGroup("cameraIndex");
            if (void 0 === t.indexesGPU || t.indexesGPU.length !== i.length) {
              let e = this.get(n),
                r = [],
                s = new Uint32Array([0, 0, 0, 0]);
              for (let t = 0, n = i.length; t < n; t++) {
                s[0] = t;
                let i = this.bindingUtils.createBindGroupIndex(s, e.layout);
                r.push(i);
              }
              t.indexesGPU = r;
            }
            let a = this.renderer.getPixelRatio();
            for (let e = 0, o = i.length; e < o; e++) {
              let o = i[e];
              if (r.layers.test(o.layers)) {
                let r = o.viewport;
                h.setViewport(
                  Math.floor(r.x * a),
                  Math.floor(r.y * a),
                  Math.floor(r.width * a),
                  Math.floor(r.height * a),
                  s.viewportValue.minDepth,
                  s.viewportValue.maxDepth
                ),
                  h.setBindGroup(n.index, t.indexesGPU[e]),
                  y();
              }
            }
          } else y();
        }
        needsRenderUpdate(e) {
          let t = this.get(e),
            { object: r, material: i } = e,
            s = this.utils,
            n = s.getSampleCountRenderContext(e.context),
            a = s.getCurrentColorSpace(e.context),
            o = s.getCurrentColorFormat(e.context),
            l = s.getCurrentDepthStencilFormat(e.context),
            u = s.getPrimitiveTopology(r, i),
            d = !1;
          return (
            (t.material !== i ||
              t.materialVersion !== i.version ||
              t.transparent !== i.transparent ||
              t.blending !== i.blending ||
              t.premultipliedAlpha !== i.premultipliedAlpha ||
              t.blendSrc !== i.blendSrc ||
              t.blendDst !== i.blendDst ||
              t.blendEquation !== i.blendEquation ||
              t.blendSrcAlpha !== i.blendSrcAlpha ||
              t.blendDstAlpha !== i.blendDstAlpha ||
              t.blendEquationAlpha !== i.blendEquationAlpha ||
              t.colorWrite !== i.colorWrite ||
              t.depthWrite !== i.depthWrite ||
              t.depthTest !== i.depthTest ||
              t.depthFunc !== i.depthFunc ||
              t.stencilWrite !== i.stencilWrite ||
              t.stencilFunc !== i.stencilFunc ||
              t.stencilFail !== i.stencilFail ||
              t.stencilZFail !== i.stencilZFail ||
              t.stencilZPass !== i.stencilZPass ||
              t.stencilFuncMask !== i.stencilFuncMask ||
              t.stencilWriteMask !== i.stencilWriteMask ||
              t.side !== i.side ||
              t.alphaToCoverage !== i.alphaToCoverage ||
              t.sampleCount !== n ||
              t.colorSpace !== a ||
              t.colorFormat !== o ||
              t.depthStencilFormat !== l ||
              t.primitiveTopology !== u ||
              t.clippingContextCacheKey !== e.clippingContextCacheKey) &&
              ((t.material = i),
              (t.materialVersion = i.version),
              (t.transparent = i.transparent),
              (t.blending = i.blending),
              (t.premultipliedAlpha = i.premultipliedAlpha),
              (t.blendSrc = i.blendSrc),
              (t.blendDst = i.blendDst),
              (t.blendEquation = i.blendEquation),
              (t.blendSrcAlpha = i.blendSrcAlpha),
              (t.blendDstAlpha = i.blendDstAlpha),
              (t.blendEquationAlpha = i.blendEquationAlpha),
              (t.colorWrite = i.colorWrite),
              (t.depthWrite = i.depthWrite),
              (t.depthTest = i.depthTest),
              (t.depthFunc = i.depthFunc),
              (t.stencilWrite = i.stencilWrite),
              (t.stencilFunc = i.stencilFunc),
              (t.stencilFail = i.stencilFail),
              (t.stencilZFail = i.stencilZFail),
              (t.stencilZPass = i.stencilZPass),
              (t.stencilFuncMask = i.stencilFuncMask),
              (t.stencilWriteMask = i.stencilWriteMask),
              (t.side = i.side),
              (t.alphaToCoverage = i.alphaToCoverage),
              (t.sampleCount = n),
              (t.colorSpace = a),
              (t.colorFormat = o),
              (t.depthStencilFormat = l),
              (t.primitiveTopology = u),
              (t.clippingContextCacheKey = e.clippingContextCacheKey),
              (d = !0)),
            d
          );
        }
        getRenderCacheKey(e) {
          let { object: t, material: r } = e,
            i = this.utils,
            s = e.context;
          return [
            r.transparent,
            r.blending,
            r.premultipliedAlpha,
            r.blendSrc,
            r.blendDst,
            r.blendEquation,
            r.blendSrcAlpha,
            r.blendDstAlpha,
            r.blendEquationAlpha,
            r.colorWrite,
            r.depthWrite,
            r.depthTest,
            r.depthFunc,
            r.stencilWrite,
            r.stencilFunc,
            r.stencilFail,
            r.stencilZFail,
            r.stencilZPass,
            r.stencilFuncMask,
            r.stencilWriteMask,
            r.side,
            i.getSampleCountRenderContext(s),
            i.getCurrentColorSpace(s),
            i.getCurrentColorFormat(s),
            i.getCurrentDepthStencilFormat(s),
            i.getPrimitiveTopology(t, r),
            e.getGeometryCacheKey(),
            e.clippingContextCacheKey,
          ].join();
        }
        createSampler(e) {
          this.textureUtils.createSampler(e);
        }
        destroySampler(e) {
          this.textureUtils.destroySampler(e);
        }
        createDefaultTexture(e) {
          this.textureUtils.createDefaultTexture(e);
        }
        createTexture(e, t) {
          this.textureUtils.createTexture(e, t);
        }
        updateTexture(e, t) {
          this.textureUtils.updateTexture(e, t);
        }
        generateMipmaps(e) {
          this.textureUtils.generateMipmaps(e);
        }
        destroyTexture(e) {
          this.textureUtils.destroyTexture(e);
        }
        async copyTextureToBuffer(e, t, r, i, s, n) {
          return this.textureUtils.copyTextureToBuffer(e, t, r, i, s, n);
        }
        initTimestampQuery(e, t) {
          if (!this.trackTimestamp) return;
          let r = e.isComputeNode ? "compute" : "render";
          this.timestampQueryPool[r] ||
            (this.timestampQueryPool[r] = new fq(this.device, r, 2048));
          let i = this.timestampQueryPool[r],
            s = i.allocateQueriesForContext(e);
          t.timestampWrites = {
            querySet: i.querySet,
            beginningOfPassWriteIndex: s,
            endOfPassWriteIndex: s + 1,
          };
        }
        createNodeBuilder(e, t) {
          return new fV(e, t);
        }
        createProgram(e) {
          this.get(e).module = {
            module: this.device.createShaderModule({
              code: e.code,
              label: e.stage + ("" !== e.name ? `_${e.name}` : ""),
            }),
            entryPoint: "main",
          };
        }
        destroyProgram(e) {
          this.delete(e);
        }
        createRenderPipeline(e, t) {
          this.pipelineUtils.createRenderPipeline(e, t);
        }
        createComputePipeline(e, t) {
          this.pipelineUtils.createComputePipeline(e, t);
        }
        beginBundle(e) {
          let t = this.get(e);
          (t._currentPass = t.currentPass),
            (t._currentSets = t.currentSets),
            (t.currentSets = {
              attributes: {},
              bindingGroups: [],
              pipeline: null,
              index: null,
            }),
            (t.currentPass = this.pipelineUtils.createBundleEncoder(e));
        }
        finishBundle(e, t) {
          let r = this.get(e),
            i = r.currentPass.finish();
          (this.get(t).bundleGPU = i),
            (r.currentSets = r._currentSets),
            (r.currentPass = r._currentPass);
        }
        addBundle(e, t) {
          this.get(e).renderBundles.push(this.get(t).bundleGPU);
        }
        createBindings(e, t, r, i) {
          this.bindingUtils.createBindings(e, t, r, i);
        }
        updateBindings(e, t, r, i) {
          this.bindingUtils.createBindings(e, t, r, i);
        }
        updateBinding(e) {
          this.bindingUtils.updateBinding(e);
        }
        createIndexAttribute(e) {
          this.attributeUtils.createAttribute(
            e,
            GPUBufferUsage.INDEX |
              GPUBufferUsage.COPY_SRC |
              GPUBufferUsage.COPY_DST
          );
        }
        createAttribute(e) {
          this.attributeUtils.createAttribute(
            e,
            GPUBufferUsage.VERTEX |
              GPUBufferUsage.COPY_SRC |
              GPUBufferUsage.COPY_DST
          );
        }
        createStorageAttribute(e) {
          this.attributeUtils.createAttribute(
            e,
            GPUBufferUsage.STORAGE |
              GPUBufferUsage.VERTEX |
              GPUBufferUsage.COPY_SRC |
              GPUBufferUsage.COPY_DST
          );
        }
        createIndirectStorageAttribute(e) {
          this.attributeUtils.createAttribute(
            e,
            GPUBufferUsage.STORAGE |
              GPUBufferUsage.INDIRECT |
              GPUBufferUsage.COPY_SRC |
              GPUBufferUsage.COPY_DST
          );
        }
        updateAttribute(e) {
          this.attributeUtils.updateAttribute(e);
        }
        destroyAttribute(e) {
          this.attributeUtils.destroyAttribute(e);
        }
        updateSize() {
          (this.colorBuffer = this.textureUtils.getColorBuffer()),
            (this.defaultRenderPassdescriptor = null);
        }
        getMaxAnisotropy() {
          return 16;
        }
        hasFeature(e) {
          return this.device.features.has(e);
        }
        copyTextureToTexture(e, t, r = null, i = null, s = 0) {
          let n = 0,
            a = 0,
            o = 0,
            l = 0,
            u = 0,
            d = 0,
            h = e.image.width,
            c = e.image.height;
          null !== r &&
            ((l = r.x),
            (u = r.y),
            (d = r.z || 0),
            (h = r.width),
            (c = r.height)),
            null !== i && ((n = i.x), (a = i.y), (o = i.z || 0));
          let p = this.device.createCommandEncoder({
              label: "copyTextureToTexture_" + e.id + "_" + t.id,
            }),
            g = this.get(e).texture,
            m = this.get(t).texture;
          p.copyTextureToTexture(
            { texture: g, mipLevel: s, origin: { x: l, y: u, z: d } },
            { texture: m, mipLevel: s, origin: { x: n, y: a, z: o } },
            [h, c, 1]
          ),
            this.device.queue.submit([p.finish()]);
        }
        copyFramebufferToTexture(e, t, r) {
          let i,
            s = this.get(t),
            n = null;
          n = t.renderTarget
            ? e.isDepthTexture
              ? this.get(t.depthTexture).texture
              : this.get(t.textures[0]).texture
            : e.isDepthTexture
            ? this.textureUtils.getDepthBuffer(t.depth, t.stencil)
            : this.context.getCurrentTexture();
          let a = this.get(e).texture;
          if (n.format !== a.format)
            return void console.error(
              "WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",
              n.format,
              a.format
            );
          if (
            (s.currentPass
              ? (s.currentPass.end(), (i = s.encoder))
              : (i = this.device.createCommandEncoder({
                  label: "copyFramebufferToTexture_" + e.id,
                })),
            i.copyTextureToTexture(
              { texture: n, origin: [r.x, r.y, 0] },
              { texture: a },
              [r.z, r.w]
            ),
            e.generateMipmaps && this.textureUtils.generateMipmaps(e),
            s.currentPass)
          ) {
            let { descriptor: e } = s;
            for (let t = 0; t < e.colorAttachments.length; t++)
              e.colorAttachments[t].loadOp = m2.Load;
            if (
              (t.depth && (e.depthStencilAttachment.depthLoadOp = m2.Load),
              t.stencil && (e.depthStencilAttachment.stencilLoadOp = m2.Load),
              (s.currentPass = i.beginRenderPass(e)),
              (s.currentSets = {
                attributes: {},
                bindingGroups: [],
                pipeline: null,
                index: null,
              }),
              t.viewport && this.updateViewport(t),
              t.scissor)
            ) {
              let { x: e, y: r, width: i, height: n } = t.scissorValue;
              s.currentPass.setScissorRect(e, r, i, n);
            }
          } else this.device.queue.submit([i.finish()]);
        }
      }
      class fX extends u.nCl {
        constructor(e, t, r, i, s, n) {
          super(e, t, r, i, s, n), (this.iesMap = null);
        }
        copy(e, t) {
          return super.copy(e, t), (this.iesMap = e.iesMap), this;
        }
      }
      class fQ extends g6 {
        constructor() {
          super(),
            this.addMaterial(oG, "MeshPhongMaterial"),
            this.addMaterial(ul, "MeshStandardMaterial"),
            this.addMaterial(ud, "MeshPhysicalMaterial"),
            this.addMaterial(uf, "MeshToonMaterial"),
            this.addMaterial(oM, "MeshBasicMaterial"),
            this.addMaterial(oV, "MeshLambertMaterial"),
            this.addMaterial(of, "MeshNormalMaterial"),
            this.addMaterial(uT, "MeshMatcapMaterial"),
            this.addMaterial(oa, "LineBasicMaterial"),
            this.addMaterial(ol, "LineDashedMaterial"),
            this.addMaterial(uA, "PointsMaterial"),
            this.addMaterial(uS, "SpriteMaterial"),
            this.addMaterial(uw, "ShadowMaterial"),
            this.addLight(po, u.HiM),
            this.addLight(gF, u.ZyN),
            this.addLight(gL, u.ure),
            this.addLight(gD, u.nCl),
            this.addLight(gO, u.$p8),
            this.addLight(gG, u.dth),
            this.addLight(gk, u.FZo),
            this.addLight(gV, fX),
            this.addToneMapping(h$, u.kyO),
            this.addToneMapping(hW, u.Mjd),
            this.addToneMapping(hH, u.nNL),
            this.addToneMapping(hj, u.FV),
            this.addToneMapping(hY, u.LAk),
            this.addToneMapping(hZ, u.aJ8);
        }
      }
      class fK extends mg {
        constructor(e = {}) {
          let t;
          e.forceWebGL
            ? (t = mZ)
            : ((t = fj),
              (e.getFallback = () => (
                console.warn(
                  "THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."
                ),
                new mZ(e)
              ))),
            super(new t(e), e),
            (this.library = new fQ()),
            (this.isWebGPURenderer = !0);
        }
      }
      class fY extends u.YJl {
        constructor() {
          super(),
            (this.isBundleGroup = !0),
            (this.type = "BundleGroup"),
            (this.static = !0),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
      }
      class fZ {
        constructor(e, t = eX(0, 0, 1, 1)) {
          (this.renderer = e),
            (this.outputNode = t),
            (this.outputColorTransform = !0),
            (this.needsUpdate = !0);
          let r = new os();
          (r.name = "PostProcessing"), (this._quadMesh = new d2(r));
        }
        render() {
          this._update();
          let e = this.renderer,
            t = e.toneMapping,
            r = e.outputColorSpace;
          (e.toneMapping = u.y_p), (e.outputColorSpace = u.Zr2);
          let i = e.xr.enabled;
          (e.xr.enabled = !1),
            this._quadMesh.render(e),
            (e.xr.enabled = i),
            (e.toneMapping = t),
            (e.outputColorSpace = r);
        }
        dispose() {
          this._quadMesh.material.dispose();
        }
        _update() {
          if (!0 === this.needsUpdate) {
            let e = this.renderer,
              t = e.toneMapping,
              r = e.outputColorSpace;
            (this._quadMesh.material.fragmentNode =
              !0 === this.outputColorTransform
                ? iQ(this.outputNode, t, r)
                : this.outputNode.context({
                    toneMapping: t,
                    outputColorSpace: r,
                  })),
              (this._quadMesh.material.needsUpdate = !0),
              (this.needsUpdate = !1);
          }
        }
        async renderAsync() {
          this._update();
          let e = this.renderer,
            t = e.toneMapping,
            r = e.outputColorSpace;
          (e.toneMapping = u.y_p), (e.outputColorSpace = u.Zr2);
          let i = e.xr.enabled;
          (e.xr.enabled = !1),
            await this._quadMesh.renderAsync(e),
            (e.xr.enabled = i),
            (e.toneMapping = t),
            (e.outputColorSpace = r);
        }
      }
      class fJ extends u.gPd {
        constructor(e = 1, t = 1) {
          super(),
            (this.image = { width: e, height: t }),
            (this.magFilter = u.k6q),
            (this.minFilter = u.k6q),
            (this.isStorageTexture = !0);
        }
      }
      class f0 extends he {
        constructor(e, t) {
          super(e, t, Uint32Array),
            (this.isIndirectStorageBufferAttribute = !0);
        }
      }
      class f1 extends u.aHM {
        constructor(e) {
          super(e), (this.textures = {}), (this.nodes = {});
        }
        load(e, t, r, i) {
          let s = new u.Y9S(this.manager);
          s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              (r) => {
                try {
                  t(this.parse(JSON.parse(r)));
                } catch (t) {
                  i ? i(t) : console.error(t), this.manager.itemError(e);
                }
              },
              r,
              i
            );
        }
        parseNodes(e) {
          let t = {};
          if (void 0 !== e) {
            for (let r of e) {
              let { uuid: e, type: i } = r;
              (t[e] = this.createNodeFromType(i)), (t[e].uuid = e);
            }
            let r = { nodes: t, textures: this.textures };
            for (let i of e)
              (i.meta = r), t[i.uuid].deserialize(i), delete i.meta;
          }
          return t;
        }
        parse(e) {
          let t = this.createNodeFromType(e.type);
          t.uuid = e.uuid;
          let r = { nodes: this.parseNodes(e.nodes), textures: this.textures };
          return (e.meta = r), t.deserialize(e), delete e.meta, t;
        }
        setTextures(e) {
          return (this.textures = e), this;
        }
        setNodes(e) {
          return (this.nodes = e), this;
        }
        createNodeFromType(e) {
          return void 0 === this.nodes[e]
            ? (console.error("THREE.NodeLoader: Node type not found:", e), eL())
            : eR(new this.nodes[e]());
        }
      }
      class f2 extends u.jut {
        constructor(e) {
          super(e), (this.nodes = {}), (this.nodeMaterials = {});
        }
        parse(e) {
          let t = super.parse(e),
            r = this.nodes,
            i = e.inputNodes;
          for (let e in i) {
            let s = i[e];
            t[e] = r[s];
          }
          return t;
        }
        setNodes(e) {
          return (this.nodes = e), this;
        }
        setNodeMaterials(e) {
          return (this.nodeMaterials = e), this;
        }
        createMaterialFromType(e) {
          let t = this.nodeMaterials[e];
          return void 0 !== t ? new t() : super.createMaterialFromType(e);
        }
      }
      class f3 extends u.XTe {
        constructor(e) {
          super(e),
            (this.nodes = {}),
            (this.nodeMaterials = {}),
            (this._nodesJSON = null);
        }
        setNodes(e) {
          return (this.nodes = e), this;
        }
        setNodeMaterials(e) {
          return (this.nodeMaterials = e), this;
        }
        parse(e, t) {
          this._nodesJSON = e.nodes;
          let r = super.parse(e, t);
          return (this._nodesJSON = null), r;
        }
        parseNodes(e, t) {
          if (void 0 !== e) {
            let r = new f1();
            return r.setNodes(this.nodes), r.setTextures(t), r.parseNodes(e);
          }
          return {};
        }
        parseMaterials(e, t) {
          let r = {};
          if (void 0 !== e) {
            let i = this.parseNodes(this._nodesJSON, t),
              s = new f2();
            s.setTextures(t),
              s.setNodes(i),
              s.setNodeMaterials(this.nodeMaterials);
            for (let t = 0, i = e.length; t < i; t++) {
              let i = e[t];
              r[i.uuid] = s.parse(i);
            }
          }
          return r;
        }
      }
      class f4 extends u.YJl {
        constructor() {
          super(),
            (this.isClippingGroup = !0),
            (this.clippingPlanes = []),
            (this.enabled = !0),
            (this.clipIntersection = !1),
            (this.clipShadows = !1);
        }
      }
    },
  },
]);
